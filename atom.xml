<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神秘的小胖纸</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-25T13:53:37.525Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3.Hibernate继承关系映射</title>
    <link href="http://yoursite.com/2020/02/25/3-Hibernate%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84/"/>
    <id>http://yoursite.com/2020/02/25/3-Hibernate%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84/</id>
    <published>2020-02-25T13:19:02.000Z</published>
    <updated>2020-02-25T13:53:37.525Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font size=5 color=#ff0000>每个具体的类实现继承关系映射</strong></font></p><p><strong><font size=5 color=#ff0000>父类对应一个表的继承关系映射</strong></font></p><p><strong><font size=5 color=#ff0000>每个类对应一个表的继承关系映射</strong></font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;font size=5 color=#ff0000&gt;每个具体的类实现继承关系映射&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font size=5 color=#ff0000&gt;父类对应一个表的继承关系映射&lt;/strong&gt;&lt;/font
      
    
    </summary>
    
    
    
      <category term="mysterious" scheme="http://yoursite.com/tags/mysterious/"/>
    
  </entry>
  
  <entry>
    <title>2.Hibernate的单实体映射</title>
    <link href="http://yoursite.com/2020/02/25/2-Hibernate%E7%9A%84%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/"/>
    <id>http://yoursite.com/2020/02/25/2-Hibernate%E7%9A%84%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/</id>
    <published>2020-02-25T05:05:21.000Z</published>
    <updated>2020-02-25T13:53:39.795Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font size=5 color=#ff0000>单实体的属性映射</strong></font></p><ol><li><p>setter 和 getter 方法优点：有效控制属性的访问权限。<br></p></li><li><p>property元素的 access 属性；field : 不需要getset方法，通过Java反射机制绕过hibernate直接访问属性值。<br><code>&lt;property name=&quot;userName&quot; access=&quot;field&quot; /&gt;</code></p></li><li><p>实体映射技巧：实体类属性与表字段不对称时，可以在 setter 和 getter 方法中加入程序逻辑<br><br> 例：User 类中没有 username 属性，而是改为了 firstName 和 lastName 两个属性</p><pre><code>public String getUserName() {    return firstName + &quot; &quot; + lastName;}public void setUserName(String userName) {    String[] strName = userName.split(&quot; &quot;);    this.firstName = strName[0];    this.lastName = strName[1];}</code></pre></li><li><p>特殊需求：<br> 例：User 需要订单总额属性，但数据库表中没有这个字段，在property元素的 formula 属性设置查询语句</p><pre><code>&lt;property name=&quot;totalPrice&quot; formula=&quot;(select sum(o.price) from orders as o where o.userId=id)&quot;/&gt;</code></pre></li><li><p>控制持久化类的insert和update</p></li></ol><table><thead><tr><th align="left">映射属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">&lt;property&gt;元素的 insert 属性</td><td align="left">insert语句中是否包含该属性，默认值为true</td></tr><tr><td align="left">&lt;property&gt;元素的 update 属性</td><td align="left">update语句中是否包含该属性，默认值为true</td></tr><tr><td align="left">&lt;class&gt;元素的 mutable 属性</td><td align="left">等价于所有property节点的update属性，默认值为true</td></tr><tr><td align="left">&lt;class&gt;元素的 dynamic-insert 属性</td><td align="left">值为true等价于所有的property元素dynamic-insert属性为true</td></tr><tr><td align="left">&lt;class&gt;元素的 dynamic-update 属性</td><td align="left">值为true等价于所有的property元素dynamic-update属性为true</td></tr></tbody></table><p><em>注：</em><br><br>    1. 会过滤过值为null的属性<br><br>    2. 如果在一个表有很多字段的时候,在做初次insert的时候有比较多的字段为空值,或者经常update某少部分字段,应该在配置文件的<class>元素上将dynamic-insert和dynamic-update设置为true.其默认值都为false.<br><br>    3. dynamic-insert，dynamic-update，提升了数据库的效率，只对需要插入修改的数据进行变动<br></p><p><strong><font size=5 color=#ff0000>单实体的对象标识符映射</strong></font></p><p>Java程序中区分不同对象：</p><ol><li>“==” 比较两个变量引用的内存地址是否相同；</li><li>equals可以比较两个变量引用的对象的值是否相同。</li><li>用户自定义的类也可以覆盖Object的equals方法实现对象按值进行比较</li><li>Hibernate 采用对象标识符（OID）区分对象。</li></ol><p><img src="https://i.imgur.com/GoQES5W.png" alt=""></p><p><strong><font size=5 color=#ff0000>使用注解映射单实体</strong></font></p><p>User.java类：</p><pre><code>@Entity                                //声明一个实体类。@Table(name=&quot;USER&quot;)                    //为实体类指定对应的数据库表@DynamicInsert(true)@DynamicUpdate(true)public class User {    @Id                       //声明实体类的OID属性    @GeneratedValue(generator=&quot;my_gen&quot;)        //声明OID的生成策略    @GenericGenerator(name = &quot;my_gen&quot;, strategy = &quot;increment&quot;)    //使用Hibernate提供的生成策略    private int id;    @Column(name=&quot;USERNAME&quot;, insertable=true)    private String userName;    @Access(AccessType.FIELD)    private String password;    @Formula(value = &quot;(select sum(o.price) from orders as o where o.userid=id)&quot;)//查询语句    private Double totalPrice;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getUserName() {        return userName;    }    public void setUserName(String userName) {        this.userName = userName;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public Double getTotalPrice() {        return totalPrice;    }    public void setTotalPrice(Double totalPrice) {        this.totalPrice = totalPrice;    }}</code></pre><p>@Column(name=”columnName”) ：将属性映射到列。<br/></p><ol><li>name=”columnName”    字段名称；<br/></li><li>unique=false            是否在该字段上设置唯一约束；<br/></li><li>nullable=true            字段是否能为空；<br/></li><li>insertable=true        控制 insert语句；<br/></li><li>updatable=true        控制 update语句；<br/></li><li>length=255            指定字段长度。<br/></li></ol><p>@Access(AccessType.PROPERTY)：<br/></p><ol><li>通过 getter 和 setter 方法访问实体类的属性；<br/></li><li>需要在 getter 方法上定义字段的属性。<br/></li></ol><p>@Access(AccessType.FIELD)：<br/></p><ol><li>直接访问实体类的属性，可以不定义 getter 和 setter 方法，但是需要将变量定义为public；<br/></li><li>需要在变量上定义字段的属性。<br/></li></ol><p>@Formula：将属性映射到SQL语句。<br/><br><code>@Formula(value = &quot;(select sum(o.price) from                 orders as o where o.userid=id)&quot;)</code></p><p>@DynamicInsert：动态生成 INSERT 语句。<br/></p><p>@DynamicUpdate：动态生成 UPDATE 语句。<br/></p><p><font color=#0000FF size=10 >使用注解和xml方式的区别：</font></p><ol><li><p><font color=#0000FF size=4 >hibernate.hbm.xml 文件中把引用：xxx.hbm.xml改为引用实体类：</font></p><p> 即把：&lt;mapping resource=”com/db/entity/Person.hbm.xml”/&gt;改为：&lt;mapping class=”com.db.entity.Person” /&gt;</p></li><li><p><font color=#0000FF size=4 >注解方式不需要在xxx.hbm.xml把实体类与表进行映射。而采用在实体类中进行注解。</font></p><ol><li>实体类属性注解的时候，都注解在<font color=#ff0000>get方法前</font></li><li>如果在实体类中某些属性不注解：（属性和get都不写注解），默认为表字段名与实体类属性名一致。</li><li>如果实体类的某个成员属性不需要存入数据库中，使用@Transient 进行注解就可以了。即类似于：(xxx.hbm.Xml配置中的某些字段不写(就是不需要对这个成员属性进行映射))</li><li>表名称可以在实体类前进行注解。</li><li>所有这些注解在：javax.persistence包下。而不是在hibernate包中。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;font size=5 color=#ff0000&gt;单实体的属性映射&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;setter 和 getter 方法优点：有效控制属性的访问权限。&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;proper
      
    
    </summary>
    
    
    
      <category term="mysterious" scheme="http://yoursite.com/tags/mysterious/"/>
    
  </entry>
  
  <entry>
    <title>1.Hibernate框架的搭建</title>
    <link href="http://yoursite.com/2020/02/25/1-Hibernate%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/02/25/1-Hibernate%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2020-02-25T04:06:04.000Z</published>
    <updated>2020-02-25T13:53:39.795Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>三层体系结构</em></strong></p><p><img src="https://i.imgur.com/XOwibmV.png" alt=""></p><ol><li>定义：将系统的组件<strong>分隔到不同的层</strong>中，每一层中的组件应保持内聚性； 每一层都应与它下面的各层保持松散耦合。<br></li><li>层与层之间存在自上而下的<strong>依赖关系</strong>，即上层组件会访问下层组件的API，而下层组件不应该依赖上层组件。<br></li><li>每个层对上层<strong>公开AP</strong>I，但具体的实现细节对外透明。当某一层的实现发生变化，只要它的API不变，不会影响其他层的实现。</li><li>持久层：将数据访问细节和业务逻辑分开（也就是在业务逻辑层和数据库层新添持久层）</li><li>持久化：将程序数据在瞬时状态和持久化状态之间转换的机制<ol><li>瞬时状态：保存在内存中的数据</li><li>持久状态：保存在数据库（磁盘）的程序数据</li></ol></li><li>持久层的作用：为业务逻辑层提供面向对象的API，<strong><em>使业务逻辑层可以专注于实现业务逻辑</em></strong></li><li>持久层的目标：<ol><li>代码可重用性高，能够完成对象持久化操作；</li><li>支持多种数据库平台；</li><li>具有相对独立性，当持久层发生变化时，不会影响上层实现。</li></ol></li><li>Hibernate是持久化层框架。</li></ol><blockquote><p>软件的模型及ORM<br></p></blockquote><p><strong><em>不同类型的模型：</em></strong></p><p>分析阶段–创建概念模型<br/><br>设计阶段–域模型（面向对象）和数据模型（面向关系）——形成<strong>对象关系映射（ORM）</strong></p><pre><code>通过ORM模式在操作实体对象的时候，就不需要再去和复杂的 SQL语句打交道，只需简单的操作实体对象的属性和方法</code></pre><blockquote><p>Hibernate介绍<br></p></blockquote><ol><li>在分层体系结构中Hibernate位于持久化层，是完成对象持久化的持久化层框架；<br/></li><li>Hibernate是连接Java应用程序和关系型数据库的框架，能够建立对象模型和关系数据模型之间的映射，是一种自动ORM框架；<br/></li><li>Hibernate是对JDBC API的封装，是JDBC轻量级封装框架。<br/></li></ol><blockquote><p>第一个Hibernate程序<br></p></blockquote><ol><li><p>安装Eclipse、Mysql；<br></p></li><li><p>下载Hibernate，并解压缩,获得jar包；<br></p></li><li><p>使用Eclipse创建新的项目；<br></p></li><li><p>引入Hibernate及其依赖库（jar包）；<br></p></li><li><p>引入Mysql数据库驱动包；<br></p></li><li><p><font color=#FF0000 size=5 >编写Hibernate配置文件(hibernate.cfg.xml<br>)；</font><br></p> <?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"> <hibernate-configuration> <session-factory>     <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>     <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>     <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/test</property>     <property name="hibernate.connection.characterEncoding">UTF-8</property>     <property name="hibernate.connection.username">root</property>     <property name="hibernate.connection.password"></property>     <property name="hibernate.show_sql">true</property>     <property name="hibernate.format_sql">true</property><pre><code>&lt;mapping resource=&quot;com/hibernate/entity/Customer.hbm.xml&quot; /&gt;</code></pre> </session-factory> </hibernate-configuration></li><li><p><font color=#FF0000 size=5 >创建Java持久化类XXX.java；</font><br></p></li></ol><p><em>持久化类与数据库之间是一一对应关系</em><br/><br><em>Custom.java文件：</em></p><pre><code>public class Customer {    private int id;    private String name;    private int sex;    private int age;    /*set，get方法*/}</code></pre><ol start="8"><li><font color=#FF0000 size=5 >编写持久化类的映射配置文件XXX.hbm.xml；</font><br></li></ol><p><em>Customer.hbm.xml文件：</em></p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.hibernate.entity&quot;&gt;    &lt;class name=&quot;Customer&quot; table=&quot;customer&quot;&gt;        &lt;id name=&quot;id&quot; type=&quot;int&quot; column=&quot;id&quot;&gt;            &lt;generator class=&quot;native&quot; /&gt;        &lt;/id&gt;        &lt;property name=&quot;name&quot; not-null=&quot;true&quot; type=&quot;java.lang.String&quot; column=&quot;name&quot; /&gt;        &lt;property name=&quot;sex&quot; type=&quot;int&quot; column=&quot;sex&quot; /&gt;        &lt;property name=&quot;age&quot; type=&quot;int&quot; column=&quot;age&quot; /&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;</code></pre><p><em>介绍配置文件</em><br>    1. class元素指定类与表之间的映射<br>        1. name：类名<br>        2. table：对应的表名<br>    2. id子元素设定持久化类的OID和表的主键的映射关系<br>        1. column：指定表字段的名称<br>        2. generator：元素指定OID的生成器<br>            1. increment：采用 Hibernate 数值递增的方式；（不适合集群情况）<br>            2. identity：采用数据库提供的自增长方式；（需设置数据库自增字段）<br>            3. assigned：主键由应用逻辑产生；（自个设置ID）<br>            4. native：自动选择合适的标识符生成器；<br>    3. property 子元素设定类的其他属性和表的字段的映射关系<br>        1. name：对应类的属性名称；<br>        2. type：指定属性的类型；<br>        3. column：指定表字段的名称；<br>        4. not-null：指定属性是否允许为空。</p><ol start="9"><li><font color=#FF0000 size=5 >使用Hibernate API 完成对象的持久化。</font><br></li></ol><p><strong>HibernateUtil工具类</strong></p><pre><code>public class HibernateUtil {    //SessionFactory是线程安全的，多个应用线程间进行共享，一般整个应用有且只有一个SessionFactory    private static SessionFactory sessionFactory = null;    /**     * 静态初始化 Hibernate：创建 StandardServiceRegistry 实例（标准注册服务）     */    static {        StandardServiceRegistry registry = new StandardServiceRegistryBuilder()//创建 StandardServiceRegistryBuilder 实例（标准注册服务生成器）                                                .configure()//从 hibernate.cfg.xml 配置文件中读取配置信息                                                .build();//构建 StandardServiceRegistry实例（标准注册服务）        try {            // 2 创建 SessionFactory 实例（会话工厂）            // 2.1 根据标准注册服务创建一个 MetadataSources 实例（元数据资源集）            // 2.2 构建元数据            // 2.3 生成SessionFactory 实例（会话工厂）            sessionFactory = new MetadataSources(registry)                                        .buildMetadata().buildSessionFactory();        } catch (Exception e) {            // 2.4 创建失败手动释放 StandardServiceRegistry            StandardServiceRegistryBuilder.destroy(registry);            e.printStackTrace();        }    }    public static SessionFactory getSessionFactory() {        return sessionFactory;    }    public static void closeSessionFactory() {        sessionFactory.close();    }</code></pre><p><strong>测试类test.java</strong></p><pre><code>Session session = HibernateUtil.getSessionFactory().openSession();//打开SessionTransaction tx = session.beginTransaction();//开始一个事务Customer customer = new Customer();//创建需要持久化的对象customer.setName(&quot;胡宗南&quot;);customer.setSex(2);customer.setAge(30);session.save(customer); //保存    /*    Customer customer2=session.get(Customer.class, new Integer(1));//查询    customer2.setName(&quot;李四&quot;);//修改    session.update(customer2);    session.delete(customer2);//删除    */tx.commit();//提交事务session.close();关闭 Session,SessionFactoryHibernateUtil.closeSessionFactory();</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;三层体系结构&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/XOwibmV.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义：将系统的组件&lt;strong&gt;分隔到不同的层&lt;/strong&gt;
      
    
    </summary>
    
    
    
      <category term="mysterious" scheme="http://yoursite.com/tags/mysterious/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/02/25/hello-world/"/>
    <id>http://yoursite.com/2020/02/25/hello-world/</id>
    <published>2020-02-25T03:38:07.680Z</published>
    <updated>2020-02-25T03:38:07.680Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
