<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mysterious Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kangxh.xyz/"/>
  <updated>2021-02-14T01:16:41.368Z</updated>
  <id>http://www.kangxh.xyz/</id>
  
  <author>
    <name>Mystery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>考研复试必问九个问题</title>
    <link href="http://www.kangxh.xyz/2021/12/14/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95%E5%BF%85%E9%97%AE%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://www.kangxh.xyz/2021/12/14/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95%E5%BF%85%E9%97%AE%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-14T12:39:43.000Z</published>
    <updated>2021-02-14T01:16:41.368Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>考研复试必问九个问题(刘晓燕)：</p><p><strong>1. 为什么考研，为什么选择这个专业？</strong></p><p>真心想考研，在大学期间，我发现我读的书很少，除了专业课的书以外，我发现我几乎没有收获什么东西，当我觉得我需要学习的时候，已经来到了大二的下半学期，所以我决定我一定要考研，更好的提升我自己，把大学没读的书，把大学错过的一些很多的提升自己的机会全都给补上</p><a id="more"></a><p><strong>2. 对未来有什么规划（三、五年内的计划、研究生如何度过）</strong></p><p>一、认真学习专业知识，听导师的一切安排，听导师的话，学好专业知识；</p><p>二、实践能力，训练实践能力，多参加实践活动，如果导师有任何项目需要我帮助，我全力以赴去做，如果没有，我要去社会上找一些工作来练习我自己，把我的专业知识转化成实践能力；</p><p>三、学会团队合作。（三年规划）</p><p>四、走入社会后为社会多做贡献（五年规划）</p><p><strong>3. 介绍你的家乡</strong></p><p>首先我的家乡非常美，我爱家乡，希望您能去看看，接着简绍著名景点、名人、特产，欢迎老师去</p><p><strong>4. 介绍家庭(目的在于上研究生)</strong></p><p>指明几口人后，挑一个人讲，牵涉到自己即可。<br>我家几口人 我最爱的人是#，#对我性格产生很大的影响。#是(身份，我以为对#是…，其实是…，我以后也要成为ta这样的人。</p><p><strong>5. 介绍一下你的本科学校</strong><br>答案：首先我很爱我的本科学校，我的本科学校可能没有那么有名气，他的名字是河北师范大学。虽然他的名气不大，但是我很爱它，因为我在这所学校里认识了许多善良和诚实的老师，我还认识了很多好朋友，他们教会了我成长，我从他们身上学到了很多，所以我特别感谢河北师范大学。以后如果有机会读河北师范大学，我希望我能够更好的提高自己的专业知识，更好的学会团队合作，更好的提高时间能力。</p><p><strong>6. 对英语的态度</strong><br>答案：首先，小时候对英语充满了兴趣，但是后来不太喜欢英语老师，把英语的学习给耽误了。当我在考四级的时候再次学习英语，我发现英语真的很有趣，我在英语中找到了人生的乐趣，并且相信我是可以学好英语的。如果我有幸被贵校录取，我将会更加的加强我的专业英语水平，提升我的英语能力。</p><p><strong>7. 对该学校和专业了解多少</strong><br>答案：首先，学校非常有名气，院校有很多著名导师，该老师曾经参加过什么什么东西（专业项目）———–查一下</p><p><strong>8. 说自己的优缺点</strong><br>答案：（与性格爱好相似，若自我介绍中有老师一般不替问）<br>优点要与专业相关，缺点不能与专业相关(读的书很少)，如果我能被录取一定好好改正缺点，尽量让自己变优秀</p><p><strong>9.为什么换专业（选）</strong></p><p>（不要表达对本科专业的延误以及考该专业简单）<br>对本科的专业（是当时爸妈选的）虽然也在努力的学习（也有一定的兴趣），但是我对现在的专业更感兴趣，想要在这方面有所突破。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;考研复试必问九个问题(刘晓燕)：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为什么考研，为什么选择这个专业？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;真心想考研，在大学期间，我发现我读的书很少，除了专业课的书以外，我发现我几乎没有收获什么东西，当我觉得我需要学习的时候，已经来到了大二的下半学期，所以我决定我一定要考研，更好的提升我自己，把大学没读的书，把大学错过的一些很多的提升自己的机会全都给补上&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://www.kangxh.xyz/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="考研复试" scheme="http://www.kangxh.xyz/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>C语言面试题3</title>
    <link href="http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%983/"/>
    <id>http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%983/</id>
    <published>2021-03-09T14:39:43.000Z</published>
    <updated>2021-03-09T13:19:07.522Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-用变量a给出下面的定义"><a href="#1-用变量a给出下面的定义" class="headerlink" title="1.用变量a给出下面的定义."></a>1.用变量a给出下面的定义.</h3><p>a) 一个整型数<br>b) 一个指向整型数的指针<br>c) 一个指向指针的的指针，它指向的指针是指向一个整型数<br>d) 一个有10个整型数的数组<br>e) 一个有10个指针的数组，该指针是指向一个整型数的<br>f) 一个指向有10个整型数数组的指针<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数<br>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数</p><p>答案是:<br>a) int a;<br>b) int <em>a;<br>c) int *</em>a;<br>d) int a[10];<br>e) int <em>a[10];<br>f) int (</em>a)[10];<br>g) int (<em>a)(int);<br>h) int (</em>a[10])(int);</p><h3 id="2-写一个“标准”宏MIN，这个输入两个参数并返回较小的一个。"><a href="#2-写一个“标准”宏MIN，这个输入两个参数并返回较小的一个。" class="headerlink" title="2.写一个“标准”宏MIN，这个输入两个参数并返回较小的一个。"></a>2.写一个“标准”宏MIN，这个输入两个参数并返回较小的一个。</h3><p>#define Min(a,b) ( ((a)&gt;=(b))?(b):(a))</p><h3 id="3-嵌入式经常用到死循环，你怎么样用C来编写死循环呢"><a href="#3-嵌入式经常用到死循环，你怎么样用C来编写死循环呢" class="headerlink" title="3.嵌入式经常用到死循环，你怎么样用C来编写死循环呢?"></a>3.嵌入式经常用到死循环，你怎么样用C来编写死循环呢?</h3><p>我的首选就是：<br>while(1){}，一些有经验的程序员喜欢用for( ; ; ){} ,还有一种是写汇编语言的程序员常用的写法:<br>Loop:<br>…<br>goto Loop;</p><h3 id="4-引用和指针的区别？"><a href="#4-引用和指针的区别？" class="headerlink" title="4.引用和指针的区别？"></a>4.引用和指针的区别？</h3><p>答：1.引用必须要初始化，指针可以不用初始化；2.不存在指向空值的引用，但是存在指向空值的指针；3.引用初始化后不能改变，但存在指向空值的指针；4.引用是变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间;</p><h3 id="5-关键字static的作用是什么"><a href="#5-关键字static的作用是什么" class="headerlink" title="5.关键字static的作用是什么?"></a>5.关键字static的作用是什么?</h3><p>在c语言中static有三个明显的作用:<br>1）static在修饰局部变量的时候，其使得局部变量的生命周期发生改变，使得其放在data段，直到程序运行结束才结束。<br>2）static在修饰全局变量的时候，作用是改变其作用域，使得全局变量只能在定义的文件中使用。<br>3）static在修饰函数的时候，同样也是只能时函数只能在当前的文件中使用。</p><h3 id="6-请填写bool-float-指针变量-与“零值”比较的if语句。"><a href="#6-请填写bool-float-指针变量-与“零值”比较的if语句。" class="headerlink" title="6.请填写bool , float, 指针变量 与“零值”比较的if语句。"></a>6.请填写bool , float, 指针变量 与“零值”比较的if语句。</h3><p>1）if ( flag ) if ( !flag )<br>2）const float EPSINON = 0.00001;<br>if ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON)<br>3）if (p == NULL) if (p != NULL)</p><h3 id="7-用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"><a href="#7-用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）" class="headerlink" title="7.用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"></a>7.用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</h3><p>#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</p><h3 id="8-extern-c-作用"><a href="#8-extern-c-作用" class="headerlink" title="8.extern c 作用"></a>8.extern c 作用</h3><p>告诉编译器该段代码以C语言进行编译。</p><h3 id="9-头文件中的-ifndef-define-endif-干什么用？"><a href="#9-头文件中的-ifndef-define-endif-干什么用？" class="headerlink" title="9.头文件中的 ifndef/define/endif 干什么用？"></a>9.头文件中的 ifndef/define/endif 干什么用？</h3><p>预处理，防止头文件被重复使用。</p><h3 id="10-do……while和while……do有什么区别？"><a href="#10-do……while和while……do有什么区别？" class="headerlink" title="10.do……while和while……do有什么区别？"></a>10.do……while和while……do有什么区别？</h3><p>前一个循环一遍再判断，后一个判断以后再循环。</p><h3 id="11-C语言链表与数组的区别"><a href="#11-C语言链表与数组的区别" class="headerlink" title="11.C语言链表与数组的区别?"></a>11.C语言链表与数组的区别?</h3><p>链表跟数组都属于一种数据结构。可以分为两个点来看：<br>从逻辑结构来看<br>1)数组必须事先定义固定的长度，不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；数组可以根据下标直接存取。<br>2) 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。链表必须根据next指针找到下一个元素。<br>从内存存储来看<br>1）(静态)数组从栈中分配空间, 对于程序员方便快速,但是自由度小<br>2）链表从堆中分配空间, 自由度大但是申请管理比较麻烦</p><h3 id="12-队列和栈有什么区别？"><a href="#12-队列和栈有什么区别？" class="headerlink" title="12.队列和栈有什么区别？"></a>12.队列和栈有什么区别？</h3><p>队列先进先出，栈后进先出。</p><h3 id="13-const-有什么用途？"><a href="#13-const-有什么用途？" class="headerlink" title="13.const 有什么用途？"></a>13.const 有什么用途？</h3><p>1）可以定义const常量。<br>2）修饰函数的返回值和形参。</p><h3 id="14-include-lt-…h-gt-和-include-“…h”-有什么区别？"><a href="#14-include-lt-…h-gt-和-include-“…h”-有什么区别？" class="headerlink" title="14 . #include &lt;…h&gt; 和#include “…h” 有什么区别？"></a>14 . #include &lt;…h&gt; 和#include “…h” 有什么区别？</h3><p>对于#include &lt;…h&gt; ，编译器从标准库路径开始搜索.h<br>对于#include “…h” ，编译器从用户的工作路径开始搜索.h</p><h3 id="15-请写出下列代码的输出内容"><a href="#15-请写出下列代码的输出内容" class="headerlink" title="15.请写出下列代码的输出内容"></a>15.请写出下列代码的输出内容</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line">a=<span class="number">10</span>;</span><br><span class="line">b=a++;</span><br><span class="line">c=++a;</span><br><span class="line">d=<span class="number">10</span>*a++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b，c ，d：%d，%d，%d"</span>，b，c，d ）;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10，12，120</p><h3 id="16-关键字volatile有什么含意？"><a href="#16-关键字volatile有什么含意？" class="headerlink" title="16.关键字volatile有什么含意？"></a>16.关键字volatile有什么含意？</h3><p>提示编译对象的值可能在编译器未检测到的情况改变。</p><h3 id="18-不用标准库函数，写一个字符串拷贝函数strcpy。"><a href="#18-不用标准库函数，写一个字符串拷贝函数strcpy。" class="headerlink" title="18.不用标准库函数，写一个字符串拷贝函数strcpy。"></a>18.不用标准库函数，写一个字符串拷贝函数strcpy。</h3><p>1)不考虑重叠问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert((dst != <span class="literal">NULL</span> )&amp;&amp;(src != <span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">char</span> * ret = dst;</span><br><span class="line"><span class="keyword">while</span> ((*dst ++ = *src ++) != <span class="string">'\0'</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)strcpy考虑重叠与不重叠问题:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">char</span> *ret = dst;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">strlen</span>(src) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (dst &gt; src  || dst &lt; src + szie)</span><br><span class="line">&#123;</span><br><span class="line">dst = dst + <span class="built_in">size</span> <span class="number">-1</span>;</span><br><span class="line">  src = src + <span class="built_in">size</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">size</span> -- )</span><br><span class="line">&#123;</span><br><span class="line">*dst ++ = *src ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">size</span> --)</span><br><span class="line">&#123;</span><br><span class="line">*dst ++ = *src ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-在下面语句中-fd的具体含义"><a href="#19-在下面语句中-fd的具体含义" class="headerlink" title="19.在下面语句中,fd的具体含义?"></a>19.在下面语句中,fd的具体含义?</h3><p>void <em>(</em>(<em>fp)(int))[10];<br>1).（）的优先级最高所以先看（</em>fp），fp是个指针；<br>2). 假设 func=(*fp); func(void ) 是个指针函数返回值是个指针，参数是（void），所以fp是指向指针函数的函数指针；</p><h3 id="20-有一个16位整数，每4位为一个数，写函数求他们的和。"><a href="#20-有一个16位整数，每4位为一个数，写函数求他们的和。" class="headerlink" title="20.有一个16位整数，每4位为一个数，写函数求他们的和。"></a>20.有一个16位整数，每4位为一个数，写函数求他们的和。</h3><p>解析:<br>整数1101010110110111<br>和 1101+0101+1011+0111</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">SumOfQuaters</span><span class="params">(<span class="keyword">unsigned</span> short n)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">c += n &amp; <span class="number">15</span>;</span><br><span class="line">n = n &gt;&gt;<span class="number">4</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(--i);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-用c语言写一个冒泡排序函数。"><a href="#21-用c语言写一个冒泡排序函数。" class="headerlink" title="21.用c语言写一个冒泡排序函数。"></a>21.用c语言写一个冒泡排序函数。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">冒泡排序: 比较相邻的元素，如果第一个比第二个大，交换他们两个；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;<span class="built_in">size</span> -i <span class="number">-1</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>] =temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-堆栈溢出一般是由什么原因导致的？"><a href="#22-堆栈溢出一般是由什么原因导致的？" class="headerlink" title="22.堆栈溢出一般是由什么原因导致的？"></a>22.堆栈溢出一般是由什么原因导致的？</h3><p>1）.内存泄露，比如某一数组原先已定义好大小，但是在后续操作中存放的个数超出这一既定长度，会导致堆栈溢出。<br>2）.由于程序员动态申请的内存块使用后未立即释放，导致内存区不够用，也会导致堆栈溢出 。</p><h3 id="23-请用指针实现一个函数，函数的功能是交换2个整数，并要求写出如何调用这个函数。"><a href="#23-请用指针实现一个函数，函数的功能是交换2个整数，并要求写出如何调用这个函数。" class="headerlink" title="23.请用指针实现一个函数，函数的功能是交换2个整数，并要求写出如何调用这个函数。"></a>23.请用指针实现一个函数，函数的功能是交换2个整数，并要求写出如何调用这个函数。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>  *x,<span class="keyword">int</span>  *y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=*x;</span><br><span class="line">*x=*y;</span><br><span class="line">*y=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入a和b："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">fun(&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n = %d ,b = %d\n"</span>,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-c语言程序运行的时候内存分布？"><a href="#24-c语言程序运行的时候内存分布？" class="headerlink" title="24.c语言程序运行的时候内存分布？"></a>24.c语言程序运行的时候内存分布？</h3><p>1）.堆区：在动态申请内存的时候，在堆里开辟内存。<br>2）.栈区： 主要存放局部变量（在函数内部，或复合语句内部定义的变量）。<br>3）.静态/全局区<br>3.1）：未初始化的静态全局区 （bss区）：<br>静态变量（定义的时候，前面加 static 修饰），或全局变量 ，没有初始化的。<br>3.2）：初始化的静态全局区 全局变量、静态变量，赋过初值的，存放在此区 。</p><p>4.代码区：存放咱们的程序代码<br>5.文字常量区 ：存放常量的。</p><h3 id="25-写一个链表逆序？"><a href="#25-写一个链表逆序？" class="headerlink" title="25.写一个链表逆序？"></a>25.写一个链表逆序？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    link* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">link* <span class="title">reverse</span><span class="params">(link *head)</span></span>&#123;</span><br><span class="line">    link *p,*q,*r;</span><br><span class="line">    <span class="keyword">if</span> (head ==<span class="literal">NULL</span> ||head -&gt;next ==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    p = head;</span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        r = q -&gt;next;</span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    head -&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">    head = p;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-怎么判断链表中是否有环？"><a href="#26-怎么判断链表中是否有环？" class="headerlink" title="26.怎么判断链表中是否有环？"></a>26.怎么判断链表中是否有环？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：用两个指针来遍历这个单向链表，第一个指针p1，每次走一步；第二个指针p2，每次走两步；当p2 指针追上p1的时候，就表明链表当中有环路了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">link* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Isloop</span><span class="params">(link* head)</span></span>&#123;</span><br><span class="line">link *p1;</span><br><span class="line">link *p2;</span><br><span class="line">p1 = head;</span><br><span class="line">p2 = head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head -&gt; next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">p1 = p1 -&gt;next;</span><br><span class="line">p2 = p2 -&gt;next-&gt;next;</span><br><span class="line">&#125;<span class="keyword">while</span>(p2&amp;&amp;p2-&gt;next&amp;&amp;p1!=p2);</span><br><span class="line"><span class="keyword">if</span> (p1 == p2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="学习" scheme="http://www.kangxh.xyz/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C语言" scheme="http://www.kangxh.xyz/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>钉钉视频下载</title>
    <link href="http://www.kangxh.xyz/2021/03/09/%E9%92%89%E9%92%89%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD/"/>
    <id>http://www.kangxh.xyz/2021/03/09/%E9%92%89%E9%92%89%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD/</id>
    <published>2021-03-09T13:53:58.000Z</published>
    <updated>2021-03-09T12:49:52.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="钉钉视频下载"><a href="#钉钉视频下载" class="headerlink" title="钉钉视频下载"></a>钉钉视频下载</h2><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>Fiddler+m3u8下载器</p><p>具体下载自己百度吧</p><h3 id="fiddle设置"><a href="#fiddle设置" class="headerlink" title="fiddle设置"></a>fiddle设置</h3><ol><li>工具—设置–勾选解密htts流量（一路按是或确定就行）<img src="https://gitee.com/LYmystery/PicGo/raw/master/img/20210309180421.png" alt="image-20210309180419287"></li><li>勾选过滤器–使用过滤器—勾选URL—填写.m3u8<img src="https://gitee.com/LYmystery/PicGo/raw/master/img/20210309180709.png" alt="image-20210309180708201"></li><li>重启软件</li><li>播放钉钉视频—-右击抓取包地址（仅复制URL）</li><li>放到m3u8下载中解析地址得到多个.ts文件  之后进行合并mp4就可以</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;钉钉视频下载&quot;&gt;&lt;a href=&quot;#钉钉视频下载&quot; class=&quot;headerlink&quot; title=&quot;钉钉视频下载&quot;&gt;&lt;/a&gt;钉钉视频下载&lt;/h2&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="http://www.kangxh.xyz/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>C语言面试题2</title>
    <link href="http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <id>http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%982/</id>
    <published>2021-03-09T13:39:43.000Z</published>
    <updated>2021-03-09T13:06:56.727Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一部分：基本概念及其它问答题</p><h3 id="1、关键字static的作用是什么？"><a href="#1、关键字static的作用是什么？" class="headerlink" title="1、关键字static的作用是什么？"></a>1、关键字static的作用是什么？</h3><p>这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：</p><p>1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</p><p>2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</p><p>3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</p><p>大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数</p><p>据和代码范围的好处和重要性。</p><h3 id="2、“引用”与指针的区别是什么？"><a href="#2、“引用”与指针的区别是什么？" class="headerlink" title="2、“引用”与指针的区别是什么？"></a>2、“引用”与指针的区别是什么？</h3><p>答 、1) 引用必须被初始化，指针不必。</p><p>2) 引用初始化以后不能被改变，指针可以改变所指的对象。</p><p>3) 不存在指向空值的引用，但是存在指向空值的指针。</p><p>指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。</p><p>流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用</p><h3 id="3、-h头文件中的ifndef-define-endif-的作用？"><a href="#3、-h头文件中的ifndef-define-endif-的作用？" class="headerlink" title="3、.h头文件中的ifndef/define/endif 的作用？"></a>3、.h头文件中的ifndef/define/endif 的作用？</h3><p>答：防止该头文件被重复引用。</p><h3 id="4、-include-与-include-“file-h”的区别？"><a href="#4、-include-与-include-“file-h”的区别？" class="headerlink" title="4、#include 与 #include “file.h”的区别？"></a>4、#include 与 #include “file.h”的区别？</h3><p>答：前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。</p><h3 id="5、描述实时系统的基本特性"><a href="#5、描述实时系统的基本特性" class="headerlink" title="5、描述实时系统的基本特性"></a>5、描述实时系统的基本特性</h3><p>答 ：在特定时间内完成特定的任务，实时性与可靠性。</p><h3 id="6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"><a href="#6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？" class="headerlink" title="6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"></a>6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</h3><p>答 ：全局变量储存在静态数据区，局部变量在堆栈中。</p><h3 id="7、什么是平衡二叉树？"><a href="#7、什么是平衡二叉树？" class="headerlink" title="7、什么是平衡二叉树？"></a>7、什么是平衡二叉树？</h3><p>答 ：左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。</p><h3 id="8、堆栈溢出一般是由什么原因导致的？"><a href="#8、堆栈溢出一般是由什么原因导致的？" class="headerlink" title="8、堆栈溢出一般是由什么原因导致的？"></a>8、堆栈溢出一般是由什么原因导致的？</h3><p>答 ：1.没有回收垃圾资源</p><p>2.层次太深的递归调用</p><h3 id="9、冒泡排序算法的时间复杂度是什么？"><a href="#9、冒泡排序算法的时间复杂度是什么？" class="headerlink" title="9、冒泡排序算法的时间复杂度是什么？"></a>9、冒泡排序算法的时间复杂度是什么？</h3><p>答 ：O(n^2)</p><h3 id="10、什么函数不能声明为虚函数？"><a href="#10、什么函数不能声明为虚函数？" class="headerlink" title="10、什么函数不能声明为虚函数？"></a>10、什么函数不能声明为虚函数？</h3><p>答：constructor</p><h3 id="11、队列和栈有什么区别？"><a href="#11、队列和栈有什么区别？" class="headerlink" title="11、队列和栈有什么区别？"></a>11、队列和栈有什么区别？</h3><p>答：队列先进先出，栈后进先出</p><h3 id="12、不能做switch-的参数类型"><a href="#12、不能做switch-的参数类型" class="headerlink" title="12、不能做switch()的参数类型"></a>12、不能做switch()的参数类型</h3><p>答 ：switch的参数不能为实型。</p><h3 id="13、局部变量能否和全局变量重名？"><a href="#13、局部变量能否和全局变量重名？" class="headerlink" title="13、局部变量能否和全局变量重名？"></a>13、局部变量能否和全局变量重名？</h3><p>答：能，局部会屏蔽全局。要用全局变量，需要使用”::”</p><p>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</p><h3 id="14、如何引用一个已经定义过的全局变量？"><a href="#14、如何引用一个已经定义过的全局变量？" class="headerlink" title="14、如何引用一个已经定义过的全局变量？"></a>14、如何引用一个已经定义过的全局变量？</h3><p>答 、可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</p><h3 id="15、全局变量可不可以定义在可被多个-C文件包含的头文件中？为什么？"><a href="#15、全局变量可不可以定义在可被多个-C文件包含的头文件中？为什么？" class="headerlink" title="15、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？"></a>15、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？</h3><p>答 、可以，在不同的C文件中以static形式来声明同名全局变量。</p><p>可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。</p><h3 id="16、语句for-；1-；-有什么问题？它是什么意思？"><a href="#16、语句for-；1-；-有什么问题？它是什么意思？" class="headerlink" title="16、语句for( ；1 ；)有什么问题？它是什么意思？"></a>16、语句for( ；1 ；)有什么问题？它是什么意思？</h3><p>答 、和while(1)相同，无限循环。</p><h3 id="17、do……while和while……do有什么区别？"><a href="#17、do……while和while……do有什么区别？" class="headerlink" title="17、do……while和while……do有什么区别？"></a>17、do……while和while……do有什么区别？</h3><p>答 、前一个循环一遍再判断，后一个判断以后再循环。</p><h3 id="18、statac-全局变量、局部变量、函数与普通全局变量、局部变量、函数"><a href="#18、statac-全局变量、局部变量、函数与普通全局变量、局部变量、函数" class="headerlink" title="18、statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数"></a>18、statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数</h3><p>static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？</p><p>答 、全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p><p>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。</p><p>static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件</p><p>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;</p><p>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；</p><p>static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷</p><h3 id="19、程序的内存分配"><a href="#19、程序的内存分配" class="headerlink" title="19、程序的内存分配"></a>19、程序的内存分配</h3><p>答：一个由c/C++编译的程序占用的内存分为以下几个部分</p><p>1、栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><p>2、堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</p><p>3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p><p>4、文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。</p><p>5、程序代码区—存放函数体的二进制代码</p><p>例子程序</p><p>//main.cpp</p><p>int a=0; //全局初始化区</p><p>char *p1; //全局未初始化区</p><p>main()</p><p>{</p><p>intb;栈</p><p>char s[]=”abc”; //栈</p><p>char *p2; //栈</p><p>char *p3=”123456”; //123456在常量区，p3在栈上。</p><p>static int c=0； //全局（静态）初始化区</p><p>p1 = (char*)malloc(10);</p><p>p2 = (char*)malloc(20); //分配得来得10和20字节的区域就在堆区。</p><p>strcpy(p1,”123456”); //123456放在常量区，编译器可能会将它与p3所向”123456”优化成一个地方。</p><p>}</p><h3 id="20、解释堆和栈的区别"><a href="#20、解释堆和栈的区别" class="headerlink" title="20、解释堆和栈的区别"></a>20、解释堆和栈的区别</h3><p>答：堆（heap）和栈(stack)的区别</p><p>（1）申请方式</p><p>stack:由系统自动分配。例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间</p><p>heap:需要程序员自己申请，并指明大小，在c中malloc函数</p><p>如p1=(char*)malloc(10);</p><p>在C++中用new运算符</p><p>如p2=(char*)malloc(10);</p><p>但是注意p1、p2本身是在栈中的。</p><p>（2）申请后系统的响应</p><p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p><p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p><p>（3）申请大小的限制</p><p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><p>（4）申请效率的比较：</p><p>栈:由系统自动分配，速度较快。但程序员是无法控制的。</p><p>堆:是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p><p>另外，在WINDOWS下，最好的方式是用Virtual Alloc分配内存，他不是在堆，也不是在栈,而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</p><p>（5）堆和栈中的存储内容</p><p>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p><p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><p>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p><p>（6）存取效率的比较</p><p>char s1[]=”aaaaaaaaaaaaaaa”;</p><p>char *s2=”bbbbbbbbbbbbbbbbb”;</p><p>aaaaaaaaaaa是在运行时刻赋值的；</p><p>而bbbbbbbbbbb是在编译时就确定的；</p><p>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</p><p>比如：</p><p>#include</p><p>voidmain()</p><p>{</p><p>char a=1;</p><p>char c[]=”1234567890”;</p><p>char *p=”1234567890”;</p><p>a = c[1];</p><p>a = p[1];</p><p>return;</p><p>}</p><p>对应的汇编代码</p><p>10:a=c[1];</p><p>004010678A4DF1movcl,byteptr[ebp-0Fh]</p><p>0040106A884DFCmovbyteptr[ebp-4],cl</p><p>11:a=p[1];</p><p>0040106D8B55ECmovedx,dwordptr[ebp-14h]</p><p>004010708A4201moval,byteptr[edx+1]</p><p>004010738845FCmovbyteptr[ebp-4],al</p><p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。</p><h3 id="21、什么是预编译-何时需要预编译"><a href="#21、什么是预编译-何时需要预编译" class="headerlink" title="21、什么是预编译,何时需要预编译?"></a>21、什么是预编译,何时需要预编译?</h3><p>答：预编译又称为预处理,是做些代码文本的替换工作。处理#开头的指令,比如拷贝#include包含的文件代码，#define宏定义的替换,条件编译等，就是为编译做的预备工作的阶段，主要处理#开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。</p><p>c编译系统在对程序进行通常的编译之前，先进行预处理。c提供的预处理功能主要有以下三种：</p><p>1）宏定义</p><p>2）文件包含</p><p>3）条件编译</p><p>1、 总是使用不经常改动的大型代码体。</p><p>２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。</p><h3 id="22、关键字const是什么含意？"><a href="#22、关键字const是什么含意？" class="headerlink" title="22、关键字const是什么含意？"></a>22、关键字const是什么含意？</h3><p>答：我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？</p><p>const int a;</p><p>int const a;</p><p>const int *a;</p><p>int * const a;</p><p>int const * a const;</p><p>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：</p><p>1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）</p><p>2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</p><p>3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现</p><h3 id="23、关键字volatile有什么含意-并给出三个不同的例子。"><a href="#23、关键字volatile有什么含意-并给出三个不同的例子。" class="headerlink" title="23、关键字volatile有什么含意 并给出三个不同的例子。"></a>23、关键字volatile有什么含意 并给出三个不同的例子。</h3><p>答：一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p><p>1). 并行设备的硬件寄存器（如：状态寄存器）</p><p>2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</p><p>3). 多线程应用中被几个任务共享的变量</p><p>回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。</p><p>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。</p><p>1). 一个参数既可以是const还可以是volatile吗？解释为什么。</p><p>2). 一个指针可以是volatile 吗？解释为什么。</p><p>3). 下面的函数有什么错误：</p><p>int square(volatile int *ptr)</p><p>{</p><p>return *ptr * *ptr;</p><p>}</p><p>下面是答案：</p><p>1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p><p>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</p><p>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针<em>ptr指向值的平方，但是，由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p><p>int square(volatile int *ptr)</p><p>{</p><p>int a,b;</p><p>a = *ptr;</p><p>b = *ptr;</p><p>return a * b;</p><p>}</p><p>由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p><p>long square(volatile int *ptr)</p><p>{</p><p>int a;</p><p>a = *ptr;</p><p>return a * a;</p><p>}</p><h3 id="24、三种基本的数据模型"><a href="#24、三种基本的数据模型" class="headerlink" title="24、三种基本的数据模型"></a>24、三种基本的数据模型</h3><p>答：按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。</p><h3 id="25、结构与联合有和区别？"><a href="#25、结构与联合有和区别？" class="headerlink" title="25、结构与联合有和区别？"></a>25、结构与联合有和区别？</h3><p>答：(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。</p><p>(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的</p><h3 id="26、描述内存分配方式以及它们的区别"><a href="#26、描述内存分配方式以及它们的区别" class="headerlink" title="26、描述内存分配方式以及它们的区别?"></a>26、描述内存分配方式以及它们的区别?</h3><p>答：1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。</p><p>2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。</p><p>3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多</p><h3 id="27、请说出const与-define-相比，有何优点？"><a href="#27、请说出const与-define-相比，有何优点？" class="headerlink" title="27、请说出const与#define 相比，有何优点？"></a>27、请说出const与#define 相比，有何优点？</h3><p>答：Const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</p><p>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</p><p>2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p><h3 id="28、简述数组与指针的区别？"><a href="#28、简述数组与指针的区别？" class="headerlink" title="28、简述数组与指针的区别？"></a>28、简述数组与指针的区别？</h3><p>答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</p><p>(1)修改内容上的差别</p><p>char a[] = “hello”;</p><p>a[0] = ‘X’;</p><p>char *p = “world”; // 注意p 指向常量字符串</p><p>p[0] = ‘X’; // 编译器不能发现该错误，运行时错误</p><p>(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个 指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</p><p>char a[] = “hello world”;</p><p>char *p = a;</p><p>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节</p><p>cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节</p><p>计算数组和指针的内存容量</p><p>void Func(char a[100])</p><p>{</p><p>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节</p><p>}</p><h3 id="29、分别写出BOOL-int-float-指针类型的变量a-与“零”的比较语句。"><a href="#29、分别写出BOOL-int-float-指针类型的变量a-与“零”的比较语句。" class="headerlink" title="29、分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"></a>29、分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。</h3><p>答：BOOL : if ( !a ) or if(a)</p><p>int : if ( a == 0)</p><p>float : const EXPRESSION EXP = 0.000001</p><p>if ( a &lt; EXP &amp;&amp; a &gt;-EXP)</p><p>pointer : if ( a != NULL) or if(a == NULL)</p><h3 id="30、如何判断一段程序是由C-编译程序还是由C-编译程序编译的？"><a href="#30、如何判断一段程序是由C-编译程序还是由C-编译程序编译的？" class="headerlink" title="30、如何判断一段程序是由C 编译程序还是由C++编译程序编译的？"></a>30、如何判断一段程序是由C 编译程序还是由C++编译程序编译的？</h3><p>答：#ifdef __cplusplus</p><p>cout&lt;&lt;”c++”;</p><p>#else</p><p>cout&lt;&lt;”c”;</p><p>#endif</p><h3 id="31、论述含参数的宏与函数的优缺点"><a href="#31、论述含参数的宏与函数的优缺点" class="headerlink" title="31、论述含参数的宏与函数的优缺点"></a>31、论述含参数的宏与函数的优缺点</h3><p>答： 带参宏 函数</p><p>处理时间 编译时 程序运行时</p><p>参数类型 没有参数类型问题 定义实参、形参类型</p><p>处理过程 不分配内存 分配内存</p><p>程序长度 变长 不变</p><p>运行速度 不占运行时间 调用和返回占用时间</p><h3 id="32、用两个栈实现一个队列的功能？要求给出算法和思路！"><a href="#32、用两个栈实现一个队列的功能？要求给出算法和思路！" class="headerlink" title="32、用两个栈实现一个队列的功能？要求给出算法和思路！"></a>32、用两个栈实现一个队列的功能？要求给出算法和思路！</h3><p>答 、设2个栈为A,B, 一开始均为空.</p><p>入队:</p><p>将新元素push入栈A;</p><p>出队:</p><p>(1)判断栈B是否为空；</p><p>(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；</p><p>(3)将栈B的栈顶元素pop出；</p><p>这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好</p><h3 id="33、嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？"><a href="#33、嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？" class="headerlink" title="33、嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？"></a>33、嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？</h3><p>答：这个问题用几个解决方案。我首选的方案是：</p><p>while(1)</p><p>{</p><p>}</p><p>一些程序员更喜欢如下方案：</p><p>for(;;)</p><p>{</p><p>}</p><p>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的</p><p>基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。</p><p>第三个方案是用 goto</p><p>Loop:</p><p>…</p><p>goto Loop;</p><p>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。</p><h3 id="34、位操作（Bit-manipulation）"><a href="#34、位操作（Bit-manipulation）" class="headerlink" title="34、位操作（Bit manipulation）"></a>34、位操作（Bit manipulation）</h3><p>答： 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。</p><p>对这个问题有三种基本的反应</p><p>1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。</p><p>2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。</p><p>3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：</p><p>#define BIT3 (0x1 &lt;&lt; 3)</p><p>static int a;</p><p>void set_bit3(void)</p><p>{</p><p>a |= BIT3;</p><p>}</p><p>void clear_bit3(void)</p><p>{</p><p>a &amp;= ~BIT3;</p><p>}</p><p>一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&amp;=~操作。</p><h3 id="35、访问固定的内存位置（Accessing-fixed-memory-locations）"><a href="#35、访问固定的内存位置（Accessing-fixed-memory-locations）" class="headerlink" title="35、访问固定的内存位置（Accessing fixed memory locations）"></a>35、访问固定的内存位置（Accessing fixed memory locations）</h3><p>答：嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。</p><p>这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：</p><p>int *ptr;</p><p>ptr = (int *)0x67a9;</p><p>*ptr = 0xaa66;</p><p>A more obscure approach is:</p><p>一个较晦涩的方法是：</p><p>*(int * const)(0x67a9) = 0xaa55;</p><p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><h3 id="36、中断（Interrupts）"><a href="#36、中断（Interrupts）" class="headerlink" title="36、中断（Interrupts）"></a>36、中断（Interrupts）</h3><p>答： 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 <strong>interrupt。下面的代码就使用了</strong>interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。</p><p>__interrupt double compute_area (double radius)</p><p>{</p><p>double area = PI * radius * radius;</p><p>printf(“ Area = %f”, area);</p><p>return area;</p><p>}</p><p>这个函数有太多的错误了，以至让人不知从何说起了：</p><p>1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。</p><p>2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。</p><p>3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。</p><p>4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。</p><h3 id="37、动态内存分配（Dynamic-memory-allocation）"><a href="#37、动态内存分配（Dynamic-memory-allocation）" class="headerlink" title="37、动态内存分配（Dynamic memory allocation）"></a>37、动态内存分配（Dynamic memory allocation）</h3><p>答：尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？</p><p>这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：</p><p>下面的代码片段的输出是什么，为什么？</p><p>char *ptr;</p><p>if ((ptr = (char *)malloc(0)) == NULL)</p><p>puts(“Got a null pointer”);</p><p>else</p><p>puts(“Got a valid pointer”);</p><p>这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。</p><h3 id="38、Typedef"><a href="#38、Typedef" class="headerlink" title="38、Typedef"></a>38、Typedef</h3><p>答：Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：</p><p>#define dPS struct s *</p><p>typedef struct s * tPS;</p><p>以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？</p><p>这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：</p><p>dPS p1,p2;</p><p>tPS p3,p4;</p><p>第一个扩展为</p><p>struct s * p1, p2;</p><p>上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。</p><p>39、用变量a给出下面的定义</p><p>答：a) 一个整型数（An integer）</p><p>b) 一个指向整型数的指针（A pointer to an integer）</p><p>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）</p><p>d) 一个有10个整型数的数组（An array of 10 integers）</p><p>e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）</p><p>f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）</p><p>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）</p><p>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer</p><p>argument and return an integer ）</p><p>答案是：</p><p>a) int a; // An integer</p><p>b) int *a; // A pointer to an integer</p><p>c) int **a; // A pointer to a pointer to an integer</p><p>d) int a[10]; // An array of 10 integers</p><p>e) int *a[10]; // An array of 10 pointers to integers</p><p>f) int (*a)[10]; // A pointer to an array of 10 integers</p><p>g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer</p><p>h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p><h3 id="40、解释局部变量、全局变量和静态变量的含义。"><a href="#40、解释局部变量、全局变量和静态变量的含义。" class="headerlink" title="40、解释局部变量、全局变量和静态变量的含义。"></a>40、解释局部变量、全局变量和静态变量的含义。</h3><p>答：局部变量：在一个函数内部定义的变量是内部变量，它只在本函数范围内有效，也就是说只有在本函数内才能使用它们，在此函数以外时不能使用这些变量的，它们称为局部变量；</p><p>全局变量：在函数外定义的变量是外部变量，外部变量是全局变量，全局变量可以为本文件中其它函数所共用，它的有效范围从定义变量的位置开始到本源文件结束；</p><p>静态变量：在程序运行期间分配固定的存储空间的变量，叫做静态变量</p><h3 id="41、写一个“标准”宏"><a href="#41、写一个“标准”宏" class="headerlink" title="41、写一个“标准”宏"></a>41、写一个“标准”宏</h3><p>答：交换两个参数值的宏定义为：. #define SWAP(a,b)</p><p>(a)=(a)+(b);</p><p>(b)=(a)-(b);</p><p>(a)=(a)-(b);</p><p>输入两个参数，输出较小的一个：#define MIN(A,B) ((A) &lt; (B))? (A) : (B))</p><p>表明1年中有多少秒（忽略闰年问题）：#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</p><p>#define DOUBLE(x) x+x 与 #define DOUBLE(x) （（x）+（x））</p><p>i = 5<em>DOUBLE(5)； i为30 i = 5</em>DOUBLE(5)； i为50</p><p>已知一个数组table，用一个宏定义，求出数据的元素个数</p><p>#define NTBL</p><p>#define NTBL (sizeof(table)/sizeof(table[0]))</p><h3 id="42、A-c-和B-c两个c文件中使用了两个相同名字的static变量-编译的时候会不会有问题-这两个static变量会保存到哪里（栈还是堆或者其他的）"><a href="#42、A-c-和B-c两个c文件中使用了两个相同名字的static变量-编译的时候会不会有问题-这两个static变量会保存到哪里（栈还是堆或者其他的）" class="headerlink" title="42、A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?"></a>42、A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?</h3><p>答：static的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。</p><p>他们都放在数据区，但是编译器对他们的命名是不同的。</p><p>如果要使变量在其他模块也有意义的话，需要使用extern关键字。</p><h3 id="43、一个单向链表，不知道头节点-一个指针指向其中的一个节点，问如何删除这个指针指向的节点？"><a href="#43、一个单向链表，不知道头节点-一个指针指向其中的一个节点，问如何删除这个指针指向的节点？" class="headerlink" title="43、一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指向的节点？"></a>43、一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指向的节点？</h3><p>答：将这个指针指向的next节点值copy到本节点，将next指向next-&gt;next,并随后删除原next指向的节点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="学习" scheme="http://www.kangxh.xyz/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C语言" scheme="http://www.kangxh.xyz/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言中qsort用法</title>
    <link href="http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E4%B8%ADqsort%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <id>http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E4%B8%ADqsort%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</id>
    <published>2021-03-09T13:35:43.000Z</published>
    <updated>2021-03-09T13:26:13.436Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文实例汇总介绍了C语言中qsort函数用法,包括针对各种数据类型参数的排序,非常具有实用价值非常具有实用价值。</p><p>分享给大家供大家参考。C语言中的qsort函数包含在**的头文件里，本文中排序都是采用的从小到大排序。</p><h3 id="一、对int类型数组排序"><a href="#一、对int类型数组排序" class="headerlink" title="一、对int类型数组排序"></a>一、对int类型数组排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">100</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a , <span class="keyword">const</span> <span class="keyword">void</span> *b )</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b; </span><br><span class="line">&#125; </span><br><span class="line">qsort(num,<span class="number">100</span>,<span class="keyword">sizeof</span>(num[<span class="number">0</span>]),cmp);</span><br></pre></td></tr></table></figure><h3 id="二、对char类型数组排序（同int类型）"><a href="#二、对char类型数组排序（同int类型）" class="headerlink" title="二、对char类型数组排序（同int类型）"></a>二、对char类型数组排序（同int类型）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">word</span>[<span class="number">100</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a , <span class="keyword">const</span> <span class="keyword">void</span> *b )</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">char</span> *)a - *(<span class="keyword">char</span> *)b; </span><br><span class="line">&#125; </span><br><span class="line">qsort(<span class="keyword">word</span>,<span class="number">100</span>,<span class="keyword">sizeof</span>(<span class="keyword">word</span>[<span class="number">0</span>]),cmp);</span><br></pre></td></tr></table></figure><h3 id="三、对double类型数组排序（特别要注意）"><a href="#三、对double类型数组排序（特别要注意）" class="headerlink" title="三、对double类型数组排序（特别要注意）"></a>三、对double类型数组排序（特别要注意）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> in[<span class="number">100</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a , <span class="keyword">const</span> <span class="keyword">void</span> *b )</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">double</span> *)a &gt; *(<span class="keyword">double</span> *)b ? <span class="number">1</span> : <span class="number">-1</span>; </span><br><span class="line">&#125; </span><br><span class="line">qsort(in,<span class="number">100</span>,<span class="keyword">sizeof</span>(in[<span class="number">0</span>]),cmp);</span><br></pre></td></tr></table></figure><h3 id="四、对结构体一级排序"><a href="#四、对结构体一级排序" class="headerlink" title="四、对结构体一级排序"></a>四、对结构体一级排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">In</span> &#123;</span> </span><br><span class="line"><span class="keyword">double</span> data; </span><br><span class="line"><span class="keyword">int</span> other; </span><br><span class="line">&#125;s[<span class="number">100</span>]；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a ,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> (*(struct In *)a).data &gt; (*(struct In *)b).data ? <span class="number">1</span> : <span class="number">-1</span>; </span><br><span class="line">&#125; </span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),cmp);</span><br></pre></td></tr></table></figure><h3 id="五、对结构体二级排序"><a href="#五、对结构体二级排序" class="headerlink" title="五、对结构体二级排序"></a>五、对结构体二级排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">In</span> &#123;</span> </span><br><span class="line"><span class="keyword">int</span> x; </span><br><span class="line"><span class="keyword">int</span> y; </span><br><span class="line">&#125;s[<span class="number">100</span>]; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//按照x从小到大排序，当x相等时按照y从大到小排序 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a , <span class="keyword">const</span> <span class="keyword">void</span> *b )</span> </span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">In</span> *<span class="title">c</span> = (<span class="title">struct</span> <span class="title">In</span> *)<span class="title">a</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">In</span> *<span class="title">d</span> = (<span class="title">struct</span> <span class="title">In</span> *)<span class="title">b</span>;</span> </span><br><span class="line"><span class="keyword">if</span>(c-&gt;x != d-&gt;x) <span class="keyword">return</span> c-&gt;x - d-&gt;x; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> d-&gt;y - c-&gt;y; </span><br><span class="line">&#125; </span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),cmp);</span><br></pre></td></tr></table></figure><h3 id="六、对字符串进行排序"><a href="#六、对字符串进行排序" class="headerlink" title="六、对字符串进行排序"></a>六、对字符串进行排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">In</span> &#123;</span> </span><br><span class="line">  <span class="keyword">int</span> data; </span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">100</span>]; </span><br><span class="line">&#125;s[<span class="number">100</span>]; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//按照结构体中字符串str的字典顺序排序 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a , <span class="keyword">const</span> <span class="keyword">void</span> *b )</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>( (*(struct In *)a)-&gt;str , (*(struct In *)b)-&gt;str ); </span><br><span class="line">&#125; </span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),cmp);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="学习" scheme="http://www.kangxh.xyz/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C语言" scheme="http://www.kangxh.xyz/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言面试题4</title>
    <link href="http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%984/"/>
    <id>http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%984/</id>
    <published>2021-03-09T13:14:02.305Z</published>
    <updated>2021-03-09T13:19:25.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1 预处理<br>问题1：什么是预编译？何时需要预编译？<br>答：<br>预编译又称预处理，是整个编译过程最先做的工作，即程序执行前的一些预处理工作。主要处理#开头的指令。如拷贝#include包含的文件代码、替换#define定义的宏、条件编译#if等。.<br>何时需要预编译：<br>1、总是使用不经常改动的大型代码体。<br>2、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。<br>问题2：写一个“标准”宏，这个宏输入两个参数并返回较小的一个<br>答:#define MIN(x, y) ((x)&lt;(y)?(x):(y)) //结尾没有;<br>问题3：#与##的作用？<br>答：#是把宏参数转化为字符串的运算符，##是把两个宏参数连接的运算符。<br>例如：<br>#define STR(arg) #arg      则宏STR(hello)展开时为”hello”<br>#define NAME(y) name_y    则宏NAME(1)展开时仍为name_y<br>#define NAME(y) name_##y   则宏NAME(1)展开为name_1<br>#define DECLARE(name, type) typename##_##type##_type，<br>则宏DECLARE(val, int)展开为int val_int_type<br>问题4：如何避免头文件被重复包含？<br>答：<br>例如，为避免头文件my_head.h被重复包含，可在其中使用条件编译：<br>#ifndef _MY_HEAD_H<br>#define _MY_HEAD_H   /<em>空宏</em>/<br>/<em>其他语句</em>/<br>#endif<br>2 关键字<br>问题1：static关键字的作用？<br>答：<br>Static的用途主要有两个，一是用于修饰存储类型使之成为静态存储类型，二是用于修饰链接属性使之成为内部链接属性。<br>1静态存储类型：<br>在函数内定义的静态局部变量，该变量存在内存的静态区，所以即使该函数运行结束，静态变量的值不会被销毁，函数下次运行时能仍用到这个值。<br>在函数外定义的静态变量——静态全局变量，该变量的作用域只能在定义该变量的文件中，不能被其他文件通过extern引用。<br>2 内部链接属性<br>    静态函数只能在声明它的源文件中使用。<br>问题2：const关键字的作用？<br>答：<br>1声明常变量，使得指定的变量不能被修改。<br>const int a = 5;/<em>a的值一直为5，不能被改变</em>/<br>const int b; b = 10;/<em>b的值被赋值为10后，不能被改变</em>/<br>const int <em>ptr; /*ptr为指向整型常量的指针，ptr的值可以修改，但不能修改其所指向的值</em>/<br>int <em>const ptr;/*ptr为指向整型的常量指针，ptr的值不能修改，但可以修改其所指向的值</em>/<br>const int <em>const ptr;/*ptr为指向整型常量的常量指针，ptr及其指向的值都不能修改</em>/<br>2修饰函数形参，使得形参在函数内不能被修改，表示输入参数。<br>如int fun(const int a);或int fun(const char <em>str);<br>3修饰函数返回值，使得函数的返回值不能被修改。<br>const char <em>getstr(void);使用：const *str= getstr();<br>const int getint(void);  使用：const int a =getint();<br>问题3：volatile关键字的作用？<br>答：<br>volatile指定的关键字可能被系统、硬件、进程/线程改变，强制编译器每次从内存中取得该变量的值，而不是从被优化后的寄存器中读取。例子:硬件时钟;多线程中被多个任务共享的变量等。<br>问题4：extern关键字的作用？<br>答：<br>1用于修饰变量或函数，表明该变量或函数都是在别的文件中定义的，提示编译器在其他文件中寻找定义。<br>extern int a;<br>extern int *p;<br>extern int array[];<br>extern void fun(void);<br>其中，在函数的声明带有关键字extern，仅仅是暗示这个函数可能在别的源文件中定义，没有其他作用。如：<br>头文件A：A_MODULE.h中包含<br>extern int func(int a, int b);<br>源文件A: A_MODULE.c中<br>#include “A_MODULE.h”<br>int func(int a, int b)<br>{<br>     returna+b;<br>}<br>此时，展开头文件A_MODULE.h后，为<br>extern int func(int a, int b);/</em>虽然暗示可能在别的源文件中定义，但又在本文件中定义，所以extern并没有起到什么作用，但也不会产生错误</em>/<br>int func(int a, int b)<br>{<br>     returna+b;<br>}<br>而源文件B：B_MODULE.c中，<br>#include “A_MODULE.h”<br>int ret = func(10,5);/<br>展开头文件A_MODULE.h后，为<br>extern int func(int a, int b);/<em>暗示在别的源文件中定义，所以在下面使用func(5,10)时，在链接的时候到别的目标文件中寻找定义</em>/<br>int ret = func(10,5);<br>2 用于extern “c<br>extern “c”的作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的编译方式进行编译，而不是C++的。<br>C++作为一种与C兼容的语言，保留了一部分面向过程语言的特点，如可以定义不属于任何类的全局变量和函数，但C++毕竟是一种面向对象的语言，为了支持函数的重载，对函数的编译方式与C的不同。例如，在C++中，对函数void fun(int,int)编译后的名称可能是_fun_int_int，而C中没有重载机制，一般直接利用函数名来指定编译后函数的名称，如上面的函数编译后的名称可能是_fun。<br>这样问题就来了，如果在C++中调用的函数如上例中的fun(1,2)是用C语言在源文件a_module.c中实现和编译的，那么函数fun在目标文件a_module.obj中的函数名为_fun，而C++在源文件b_module.cpp通过调用其对外提供的头文件a_module.h引用后，调用fun，则直接以C++的编译方式来编译，使得fun编译后在目标文件b_module.obj的名称为_fun_int_int，这样在链接的时候，因为_fun_int_int的函数在目标文件a_module.obj中不存在，导致了链接错误。<br>解决方法是让b_module.cpp知道函数fun是用C语言实现和编译了，在调用的时候，采用与C语言一样的方式来编译。该方法可以通过extern “C”来实现（具体用法见下面）。一般，在用C语言实现函数的时候，要考虑到这个函数可能会被C++程序调用，所以在设计头文件时，应该这样声明头文件：<br>/<em>头文件a_module.h</em>/<br>/<em>头文件被CPP文件include时，CPP文件中都含有该自定义的宏__cplusplus</em>/<br>/<em>这样通过extern “C”告诉C++编译器，extern “C”{}里包含的函数都用C的方式来编译</em>/<br>#ifdef <strong>cplusplus<br>extern “C”<br>{<br>#endif<br>extern void fun(int a, int b);<br>#ifdef __cplusplus<br>}<br>#endif<br>extern “C”的使用方式<br>\1. 可以是单一语句<br>  extern “C” doublesqrt(double);<br>\2. 可以是复合语句, 相当于复合语句中的声明都加了extern “C”<br>  extern “C”<br>  {<br>    double sqrt(double);<br>    int min(int, int);<br>  }<br>3.可以包含头文件，相当于头文件中的声明都加了extern”C”<br>  extern “C”<br>  {<br>    #include <cmath><br> }<br>\4. 不可以将extern”C” 添加在函数内部<br>\5. 如果函数有多个声明，可以都加extern”C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。<br>\6. 除extern”C”, 还有extern “FORTRAN” 等。<br>问题5：sizeof关键字的作用？<br>答：<br>sizeof是在编译阶段处理，且不能被编译为机器码。sizeof的结果等于对象或类型所占的内存字节数。sizeof的返回值类型为size_t。<br>变量：int a;  sizeof(a)为4；<br>指针：int <em>p;  sizeof(p)为4；<br>数组：int b[10]; sizeof(b)为数组的大小，4<em>10；int c[0]; sizeof(c)等于0<br>结构体：struct (int a; char ch;)s1; sizeof(s1)为8 与结构体字节对齐有关。<br>注意：不能对结构体中的位域成员使用sizeof<br>sizeof(void)等于1<br>sizeof(void *)等于4<br>3 结构体<br>问题1：结构体的赋值？<br>答：<br>C语言中对结构体变量的赋值或者在初始化或者在定义后按字段赋值。<br>方式1：初始化<br>struct tag<br>{<br>   chara;<br>  int b;<br>}x = {‘A’, 1};/</em>初始化</em>/<br>或<br>struct tag<br>{<br>char a;<br>int b;<br>};<br>struct tag x = {‘A’,1};/<em>在定义变量时初始化</em>/<br>GNU C中可使用另外一种方式：<br>struct tag<br>{<br>char a;<br>int b;<br>}x =<br>{<br>.a = ‘A’,<br>.b =1;<br>};<br>或<br>struct tag<br>{<br>char a;<br>int b;<br>};<br>struct tag x =<br>{<br>   .a= ‘A’,<br>  .b=1,<br>};<br>方式2：定义变量后按字段赋值<br>struct tag<br>{<br>char a;<br>int b;<br>};<br>struct tag x;/<em>定义变量</em>/<br>x.a = ‘A’;/<em>按字段赋值</em>/<br>x.b = 1; /<em>按字段赋值</em>/<br>而当你使用初始化的方式来赋值时，如x = {‘A’,1};则出错。<br>方式3：结构变量间的赋值<br>struct tag<br>{<br>   chara;<br>  int b;<br>};<br>struct tag x,y;<br>x.a=’A’;<br>x.b=1;<br>y = x;/<em>结构变量间直接赋值</em>/<br>问题2：结构体变量如何比较？<br>答：虽然结构体变量之间可以通过=直接赋值，但不同通过比较符如==来比较，因为比较符只作用于基本数据类型。这个时候，只能通过int memcmp(const void <em>s1, const void <em>s2, size_t n);来进行内存上的比较。<br>问题3：结构体位域<br>答：<br>位域是一个或多个位的字段，不同长度的字段（如声明为unsigned int类型）存储于一个或多个其所声明类型的变量中（如整型变量中）。<br>位域的类型：可以是char、short、int，多数使用int，使用时最好带上signed或unsigned<br>位域的特点：字段可以不命名，如unsignedint :1;可用来填充；unsigned int :0; 0宽度用来强制在下一个整型（因此处是unsigned int类型）边界上对齐。<br>位域的定义：<br>struct st1<br>{<br>unsigned chara:7;/</em>字段a占用了一个字节的7个bit</em>/<br>unsigned charb:2;/<em>字段b占用了2个bit</em>/<br>unsigned charc:7;/<em>字段c占用了7个bit</em>/<br>}s1;<br>sizeof(s1)等于3。因为一个位域字段必须存储在其位域类型的一个单元所占空间中,不能横跨两个该位域类型的单元。也就是说，当某个位域字段正处于两个该位域类型的单元中间时，只使用第二个单元，第一个单元剩余的bit位置补（pad）0。<br>于是可知Sizeof(s2)等于3<em>sizeof(int)即12<br>struct st2<br>{<br>unsigned inta:31;<br>unsigned intb:2;/*前一个整型变量只剩下1个bit，容不下2个bit，所以只能存放在下一个整型变量</em>/<br>unsigned int c:31;<br>}s2;<br>位域的好处：<br>    1.有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态，用一位二进位即可。这样节省存储空间，而且处理简便。这样就可以把几个不同的对象用一个字节的二进制位域来表示。<br>    2.可以很方便的利用位域把一个变量给按位分解。比如只需要4个大小在0到3的随即数，就可以只rand()一次，然后每个位域取2个二进制位即可，省时省空间。<br>位域的缺点：<br>不同系统对位域的处理可能有不同的结果，如位段成员在内存中是从左向右分配的还是从右向左分配的，所以位域的使用不利于程序的可移植性。<br>问题4：结构体成员数组大小为0<br>结构体数组成员的大小为0是GNU C的一个特性。好处是可以在结构体中分配不定长的大小。如<br>typedef struct st<br>{<br>    inta;<br>int b;<br>char c[0];<br>}st_t;<br>sizeof(st_t)等于8，即char c[0]的大小为0.<br>#define SIZE 100<br>st_t *s = (st_t *)malloc(sizeof(st_t) + SIZE);<br>4 函数<br>问题1：函数参数入栈顺序<br>答：<br>C语言函数参数入栈顺序是从右向左的，这是由编译器决定的，更具体的说是函数调用约定决定了参数的入栈顺序。C语言采用是函数调用约定是</cmath></strong>cdecl的，所以对于函数的声明，完整的形式是：int __cdecl func(int a, int b);<br>问题2：inline内联函数<br>答：<br>inline关键字仅仅是建议编译器做内联展开处理，即是将函数直接嵌入调用程序的主体，省去了调用/返回指令。<br>5 内存分配回收<br>问题1： malloc/free与new/delete的区别<br>答：</p><p>1) malloc与free是C/C++语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>2) 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。<br>我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。<br>3) 既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。<br>如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。<br>问题2：malloc(0)返回值<br>答：如果请求的长度为0，则标准C语言函数malloc返回一个null指针或不能用于访问对象的非null指针，该指针能被free安全使用。<br>6 可变参数列表<br>可变参数列表是通过宏来实现的，这些宏定义在stdarg.h头文件，它是标准库的一部分。这个头文件声明了一个类型va_list和三个宏：va_start、va_arg和va_end。<br>typedef char <em>va_list;<br>#define va_start(ap, A)  (void)((ap) = (char *)&amp;(A) + _Bnd(A, _AUPBND))<br>#define va_arg(ap, T)  (</em>(T )((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND)))<br>#define va_end(ap) (void)0<br>int print(char <em>format, …)<br>宏va_start的第一个参数是va_list类型的变量，第二个参数是省略号前最后一个有名字的参数，功能是初始化va_list类型的变量，将其值设置为可变参数的第一个变量。<br>宏va_arg的第一个参数是va_list类型的变量，第二个参数是参数列表的下一个参数的类型。va_arg返回va_list变量的值，并使该变量指向下一个可变参数。<br>宏va_end是在va_arg访问完最后一个可变参数之后调用的。<br>问题1：实现printf函数<br>/*（转载）<br> \</em> A simple printf function. Only support the following format:<br> * Code Format<br> * %c character<br> * %d signed integers<br> * %i signed integers<br> * %s a string of characters<br> * %o octal<br> * %x unsigned hexadecimal<br> <em>/<br>int my_printf( const char</em> format, …)<br>{<br>  va_list arg;<br>  int done = 0;<br>  va_start (arg, format);<br>  while( <em>format != ‘\0’)<br>  {<br>    if( *format == ‘%’)<br>    {<br>      if( *(format+1) == ‘c’ )<br>      {<br>        char c = (char)va_arg(arg, int);<br>        putc(c, stdout);<br>      } else if( *(format+1) == ‘d’ || *(format+1) == ‘i’)<br>      {<br>        char store[20];<br>        int i = va_arg(arg, int);<br>        char</em> str = store;<br>        itoa(i, store, 10);<br>        while( <em>str != ‘\0’) putc(*str++, stdout);<br>      } else if( *(format+1) == ‘o’)<br>      {<br>        char store[20];<br>        int i = va_arg(arg, int);<br>        char</em> str = store;<br>        itoa(i, store, 8);<br>        while( <em>str != ‘\0’) putc(*str++, stdout);<br>      } else if( *(format+1) == ‘x’)<br>      {<br>        char store[20];<br>        int i = va_arg(arg, int);<br>        char</em> str = store;<br>        itoa(i, store, 16);<br>        while( <em>str != ‘\0’) putc(*str++, stdout);<br>      } else if( *(format+1) == ‘s’ )<br>      {<br>        char</em> str = va_arg(arg, char<em>);<br>        while( <em>str != ‘\0’) putc(</em>str++, stdout);<br>      }<br>      // Skip this two characters.<br>      format += 2;<br>    } else {<br>      putc(*format++, stdout);<br>    }<br>  }<br>  va_end (arg);<br>  return done;<br>}<br>7 其他<br>问题1：ASSERT()的作用<br>答:ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。例如，变量n在程序中不应该为0，如果为0可能导致错误，你可以这样写程序：<br>……<br>ASSERT( n != 0);<br>k = 10/ n;<br>…..<br>ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。<br>assert()的功能类似，它是ANSI C标准中规定的函数，它与ASSERT的一个重要区别是可以用在Release版本中。<br>问题2：system(“pause”);的作用<br>答:系统的暂停程序，按任意键继续，屏幕会打印，”按任意键继续。。。。。”省去了使用getchar（）；<br>问题3：请问C++的类和C里面的struct有什么区别？<br>答:c++中的类具有成员保护功能，并且具有继承，多态这类oo特点，而c里的struct没有。c里面的struct没有成员函数,不能继承,派生等等.<br>8 找错题<br>试题1：<br>void test1()<br>{<br>　　char string[10];<br>　　char</em> str1 = “0123456789”;<br>　　strcpy(string, str1);<br>}<br>解答：字符串str1有11个字节（包括末尾的结束符’\0’），而string只有10个字节，故而strcpy会导致数组string越界。<br>试题2：<br>void test2()<br>{<br>　　char string[10], str1[10];<br>　　int i;<br>　　for(i=0; i&lt;10; i++)<br>　　{<br>　　  str1= ‘a’;<br>　　}<br>　　strcpy(string, str1);<br>}<br>解答：因为str1没有结束符’\0’，故而strcpy复制的字符数不确定。strcpy源码如下：<br>[cpp] view plain copy<br>#include &lt;string.h&gt;<br>char <em>strcpy(char <em>s1, cosnt char *s2)<br>{<br>  char *s = s1;<br>  for (s = s1; (</em>s++ = <em>s2++) != ‘\0’;)/</em>最后的结束符’\0’也会被复制</em>/<br>    ;<br>  return s1;<br>}<br>试题3：<br>void test3(char* str1)<br>{<br>　　char string[10];<br>　　if(strlen(str1) &lt;= 10 )<br>　　{<br>　　  strcpy(string, str1);<br>　　}<br>}<br>解答：应修改为if (strlen(str1) &lt; 10)，因为strlen的结果未统计最后的结束符’\0’。strlen的源码如下：<br>[cpp] view plain copy<br>#include &lt;string.h&gt;<br>size_t strlen(const char <em>s)<br>{<br>  const char <em>sc;<br>  for (sc = s; *sc != ‘\0’; ++sc)/</em>不包含最后的结束符’\0’</em>/<br>    ;<br>  return (sc - s);<br>}<br>试题4：<br>void GetMemory(char <em>p)<br>{<br>　　p = (char <em>)malloc( 100 );<br>}<br>void Test( void )<br>{<br>　 char *str = NULL;<br>　 GetMemory(str);<br>　 strcpy(str,”hello world”);<br>　 printf(str);<br>}<br>解答：C语言中的函数参数为传值参数，在函数内对形参的修改并不能改变对应实参的值。故而调用GetMemory后，str仍为NULL。<br>试题5：<br>char *GetMemory( void )<br>{<br>　　char p[] = “hello world”;<br>　　return p;<br>}<br>void Test( void )<br>{<br>　　char *str = NULL;<br>　　str = GetMemory();<br>　　printf(str);<br>}<br>解答：GetMemory中，p为局部变量，在函数返回后，该局部变量被回收。故而str仍为NULL<br>试题6：<br>void GetMemory( char *</em>p, int num )<br>{<br>　　<em>p = (char *)malloc(num);<br>}<br>void Test( void )<br>{<br>　　char *str = NULL;<br>　　GetMemory(&amp;str, 100);<br>　　strcpy(str, “hello”);<br>　　printf(str);<br>}<br>解答：试题6避免了试题4的问题，但在GetMemory内，未对</em>p为NULL情况的判断。当*p不为NULL时，在printf后，也未对malloc的空间进行free<br>试题7：<br>void Test( void )<br>{<br>　　char *str = (char *)malloc( 100 );<br>　　strcpy(str, “hello” );<br>　　free(str);<br>　　… //省略的其它语句<br>}<br>解答：未对str为NULL的情况的判断，在free(str)后，str未设置为NULL，可能变成一个野指针（后面对str的操作可能会导致踩内存）。<br>试题8：<br>swap(int</em> p1,int* p2)<br>{<br>　　int <em>p;<br>　　*p = *p1;<br>　　*p1 = *p2;<br>　　*p2 = *p;<br>}<br>解答：在swap函数中，p是个野指针，可能指向系统区，导致程序运行的崩溃。故而，程序应改为：<br>swap(int</em> p1,int* p2)<br>{<br>　　int p;<br>　　p = *p1;<br>　　*p1 = *p2;<br>　　*p2 = p;<br>}<br>9 编程题<br>题1：判断字符串str2是否在字符串str1里。<br>[cpp] view plain copy<br>#include &lt;stdio.h&gt;  </p><p>#define OK   1<br>#define ERROR 0  </p><p>int str_str(const char *str1, const char *str2)<br>{<br>  const char *s1 = NULL;<br>  const char *s2 = NULL;  </p><p>  if (str1 == NULL)<br>  {<br>    return (str2 == NULL) ? OK : ERROR;<br>  }  </p><p>  if (str2 == NULL)<br>  {<br>    return OK;<br>  }  </p><p>  for (; <em>str1 != ‘\0’; str1++)<br>  {<br>    if (*str1 == *str2)<br>    {<br>      for (s1 = str1, s2 = str2; ; )<br>      {<br>        if (</em>++s2 == ‘\0’)<br>        {<br>          return OK;<br>        }<br>        else if (*++s1 != *s2)<br>        {<br>          break;<br>        }<br>      }<br>    }<br>  }  </p><p>  return ERROR;<br>}<br>转自：<a href="http://blog.csdn.net/lincoln_2012/article/details/49179503" target="_blank" rel="noopener">http://blog.csdn.net/lincoln_2012/article/details/49179503</a><br>﻿﻿<br>C语言面试宝典<br>第一部分：基本概念及其它问答题<br>1、关键字static的作用是什么？<br>这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：<br>1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。<br>大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数<br>据和代码范围的好处和重要性。</p><p>2、“引用”与指针的区别是什么？<br>答 、1) 引用必须被初始化，指针不必。<br>2) 引用初始化以后不能被改变，指针可以改变所指的对象。<br>3) 不存在指向空值的引用，但是存在指向空值的指针。<br>指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。<br>流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用</p><p>3、.h头文件中的ifndef/define/endif 的作用？<br>答：防止该头文件被重复引用。</p><p>4、#include&lt;file.h&gt; 与 #include “file.h”的区别？<br>答：前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。</p><p>5、描述实时系统的基本特性<br>答 ：在特定时间内完成特定的任务，实时性与可靠性。</p><p>6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？<br>答 ：全局变量储存在静态数据区，局部变量在堆栈中。</p><p>7、什么是平衡二叉树？<br>答 ：左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。</p><p>8、堆栈溢出一般是由什么原因导致的？<br>答 ：1.没有回收垃圾资源<br>    2.层次太深的递归调用</p><p>9、冒泡排序算法的时间复杂度是什么？<br>答 ：O(n^2)<br>10、什么函数不能声明为虚函数？<br>答：constructor</p><p>11、队列和栈有什么区别？<br>答：队列先进先出，栈后进先出</p><p>12、不能做switch()的参数类型<br>答 ：switch的参数不能为实型。</p><p>13、局部变量能否和全局变量重名？<br>答：能，局部会屏蔽全局。要用全局变量，需要使用”::”<br>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</p><p>14、如何引用一个已经定义过的全局变量？<br>答 、可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</p><p>15、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？<br>答 、可以，在不同的C文件中以static形式来声明同名全局变量。<br>可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。</p><p>16、语句for( ；1 ；)有什么问题？它是什么意思？<br>答 、和while(1)相同，无限循环。</p><p>17、do……while和while……do有什么区别？<br>答 、前一个循环一遍再判断，后一个判断以后再循环。</p><p>18、statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数<br>static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？<br>答 、全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。<br>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。<br>static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件<br>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;<br>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；<br>static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p><p>19、程序的内存分配<br>答：一个由c/C++编译的程序占用的内存分为以下几个部分<br>1、栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。<br>3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区—存放函数体的二进制代码</p><p>例子程序<br>这是一个前辈写的，非常详细<br>//main.cpp<br> int a=0;   //全局初始化区<br> char <em>p1;  //全局未初始化区<br> main()<br> {<br>  intb;栈<br>  char s[]=”abc”;  //栈<br>  char *p2;     //栈<br>  char *p3=”123456”;  //123456\0在常量区，p3在栈上。<br>  static int c=0；  //全局（静态）初始化区<br>  p1 = (char</em>)malloc(10);<br>  p2 = (char*)malloc(20);  //分配得来得10和20字节的区域就在堆区。<br>  strcpy(p1,”123456”);  //123456\0放在常量区，编译器可能会将它与p3所向”123456”优化成一个地方。<br>}</p><p>20、解释堆和栈的区别<br>答：堆（heap）和栈(stack)的区别<br>（1）申请方式<br>stack:由系统自动分配。例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间<br>heap:需要程序员自己申请，并指明大小，在c中malloc函数<br>如p1=(char<em>)malloc(10);<br>在C++中用new运算符<br>如p2=(char</em>)malloc(10);<br>但是注意p1、p2本身是在栈中的。<br>（2）申请后系统的响应<br>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，<br>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。<br>（3）申请大小的限制<br>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br>（4）申请效率的比较：<br>栈:由系统自动分配，速度较快。但程序员是无法控制的。<br>堆:是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br>另外，在WINDOWS下，最好的方式是用Virtual Alloc分配内存，他不是在堆，也不是在栈,而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。<br>（5）堆和栈中的存储内容<br>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。<br>（6）存取效率的比较<br>char s1[]=”aaaaaaaaaaaaaaa”;<br>char *s2=”bbbbbbbbbbbbbbbbb”;<br>aaaaaaaaaaa是在运行时刻赋值的；<br>而bbbbbbbbbbb是在编译时就确定的；<br>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。<br>比如：<br>#include<br>voidmain()<br>{<br>char a=1;<br>char c[]=”1234567890”;<br>char *p=”1234567890”;<br>a = c[1];<br>a = p[1];<br>return;<br>}<br>对应的汇编代码<br>10:a=c[1];<br>004010678A4DF1movcl,byteptr[ebp-0Fh]<br>0040106A884DFCmovbyteptr[ebp-4],cl<br>11:a=p[1];<br>0040106D8B55ECmovedx,dwordptr[ebp-14h]<br>004010708A4201moval,byteptr[edx+1]<br>004010738845FCmovbyteptr[ebp-4],al<br>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。<br>21、什么是预编译,何时需要预编译?<br>答：预编译又称为预处理,是做些代码文本的替换工作。处理#开头的指令,比如拷贝#include包含的文件代码，#define宏定义的替换,条件编译等，就是为编译做的预备工作的阶段，主要处理#开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。<br>c编译系统在对程序进行通常的编译之前，先进行预处理。c提供的预处理功能主要有以下三种：1）宏定义　2）文件包含　3）条件编译</p><p>1、 总是使用不经常改动的大型代码体。<br>２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。</p><p>22、关键字const是什么含意？<br>答：我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？<br>const int a;<br>int const a;<br>const int *a;<br>int * const a;<br>int const * a const;<br>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：<br>1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）<br>2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。<br>3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现</p><p>23、关键字volatile有什么含意 并给出三个不同的例子。<br>答：一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：<br>1). 并行设备的硬件寄存器（如：状态寄存器）<br>2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)<br>3). 多线程应用中被几个任务共享的变量<br>回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。<br>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。<br>1). 一个参数既可以是const还可以是volatile吗？解释为什么。<br>2). 一个指针可以是volatile 吗？解释为什么。<br>3). 下面的函数有什么错误：<br>int square(volatile int <em>ptr)<br>{<br>return *ptr * *ptr;<br>}<br>下面是答案：<br>1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。<br>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。<br>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针</em>ptr指向值的平方，但是，由于<em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：<br>int square(volatile int *ptr)<br>{<br>int a,b;<br>a = *ptr;<br>b = *ptr;<br>return a * b;<br>}<br>由于</em>ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：<br>long square(volatile int *ptr)<br>{<br>int a;<br>a = *ptr;<br>return a * a;<br>}</p><p>24、三种基本的数据模型<br>答：按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。</p><p>25、结构与联合有和区别？<br>答：(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。<br> (2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的</p><p>26、描述内存分配方式以及它们的区别?<br>答：1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。<br>2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。<br>3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多</p><p>27、请说出const与#define 相比，有何优点？<br>答：Const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。<br>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。<br>   2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p><p>28、简述数组与指针的区别？<br>答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。<br>  (1)修改内容上的差别<br>   char a[] = “hello”;<br>   a[0] = ‘X’;<br>   char *p = “world”; // 注意p 指向常量字符串<br>   p[0] = ‘X’; // 编译器不能发现该错误，运行时错误<br>  (2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个 指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br>   char a[] = “hello world”;<br>   char *p = a;<br>   cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节<br>   cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节<br>   计算数组和指针的内存容量<br>   void Func(char a[100])<br>   {<br>   cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节<br>   }</p><p>29、分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。<br>答：BOOL :   if ( !a ) or if(a)<br>int :   if ( a == 0)<br>float :  const EXPRESSION EXP = 0.000001<br>     if ( a &lt; EXP &amp;&amp; a &gt;-EXP)<br>pointer : if ( a != NULL) or if(a == NULL)</p><p>30、如何判断一段程序是由C 编译程序还是由C++编译程序编译的？<br>答：#ifdef __cplusplus<br>cout&lt;&lt;”c++”;<br>#else<br>cout&lt;&lt;”c”;<br>#endif<br>31、论述含参数的宏与函数的优缺点<br>答：     带参宏          函数<br>处理时间   编译时        程序运行时<br>参数类型  没有参数类型问题    定义实参、形参类型<br>处理过程  不分配内存       分配内存<br>程序长度  变长          不变<br>运行速度  不占运行时间      调用和返回占用时间<br>32、用两个栈实现一个队列的功能？要求给出算法和思路！<br>答 、设2个栈为A,B, 一开始均为空.<br>入队:<br>将新元素push入栈A;<br>出队:<br>(1)判断栈B是否为空；<br>(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；<br>(3)将栈B的栈顶元素pop出；<br>这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好</p><p>33、嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？<br>答：这个问题用几个解决方案。我首选的方案是：<br>while(1)<br>{<br>}<br>一些程序员更喜欢如下方案：<br>for(;;)<br>{<br>}<br>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的<br>基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。<br>第三个方案是用 goto<br>Loop:<br>…<br>goto Loop;<br>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。</p><p>34、位操作（Bit manipulation）<br>答： 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。<br>对这个问题有三种基本的反应<br>1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。<br>2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。<br>3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：<br>#define BIT3 (0x1 &lt;&lt; 3)<br>static int a;<br>void set_bit3(void)<br>{<br>  a |= BIT3;<br>}<br>void clear_bit3(void)<br>{<br>  a &amp;= <del>BIT3;<br>}<br>  一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&amp;=</del>操作。</p><p>35、访问固定的内存位置（Accessing fixed memory locations）<br>答：嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。<br>这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：<br>  int *ptr;<br>  ptr = (int *)0x67a9;<br>  *ptr = 0xaa66;<br> A more obscure approach is:<br>一个较晦涩的方法是：<br> *(int * const)(0x67a9) = 0xaa55;<br>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><p>36、中断（Interrupts）<br>答： 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 <strong>interrupt。下面的代码就使用了</strong>interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。<br>__interrupt double compute_area (double radius)<br>{<br>  double area = PI * radius * radius;<br>  printf(“\nArea = %f”, area);<br>  return area;<br>}<br>这个函数有太多的错误了，以至让人不知从何说起了：<br>1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。<br>2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。<br>3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。<br>4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。<br>37、动态内存分配（Dynamic memory allocation）<br>答：尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？<br>这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：<br>下面的代码片段的输出是什么，为什么？<br>char *ptr;<br>if ((ptr = (char *)malloc(0)) == NULL)<br>  puts(“Got a null pointer”);<br>else<br>  puts(“Got a valid pointer”);<br>  这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。<br>38、Typedef<br>答：Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：<br>#define dPS struct s *<br>typedef struct s * tPS;<br>  以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？<br>  这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：<br>dPS p1,p2;<br>tPS p3,p4;<br>第一个扩展为<br>struct s * p1, p2;<br>  上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。<br>39、用变量a给出下面的定义<br>答：a) 一个整型数（An integer）<br>b) 一个指向整型数的指针（A pointer to an integer）<br>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）<br>d) 一个有10个整型数的数组（An array of 10 integers）<br>e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）<br>f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）<br>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer<br>argument and return an integer ）</p><p>答案是：<br>a) int a; // An integer<br>b) int <em>a; // A pointer to an integer<br>c) int *</em>a; // A pointer to a pointer to an integer<br>d) int a[10]; // An array of 10 integers<br>e) int <em>a[10]; // An array of 10 pointers to integers<br>f) int (</em>a)[10]; // A pointer to an array of 10 integers<br>g) int (<em>a)(int); // A pointer to a function a that takes an integer argument and returns an integer<br>h) int (</em>a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p><p>40、解释局部变量、全局变量和静态变量的含义。<br>答：<br>41、写一个“标准”宏<br>答：交换两个参数值的宏定义为：. #define SWAP(a,b)<br> (a)=(a)+(b);<br>(b)=(a)-(b);<br>(a)=(a)-(b);<br>输入两个参数，输出较小的一个：#define MIN(A,B) ((A) &lt; (B))? (A) : (B))<br>表明1年中有多少秒（忽略闰年问题）：#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL<br>#define DOUBLE(x) x+x  与      #define DOUBLE(x) （（x）+（x））<br>i = 5<em>DOUBLE(5)； i为30      i = 5</em>DOUBLE(5)； i为50<br>已知一个数组table，用一个宏定义，求出数据的元素个数<br>#define NTBL<br>#define NTBL (sizeof(table)/sizeof(table[0]))</p><p>42、A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?<br>答：static的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。<br>他们都放在数据区，但是编译器对他们的命名是不同的。<br>如果要使变量在其他模块也有意义的话，需要使用extern关键字。</p><p>43、一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指向的节点？<br>答：将这个指针指向的next节点值copy到本节点，将next指向next-&gt;next,并随后删除原next指向的节点。<br>第二部分：程序代码评价或者找错<br>1、下面的代码输出是什么，为什么？<br>void foo(void)<br>{<br>  unsigned int a = 6;<br>  int b = -20;<br>  (a+b &gt; 6) ? puts(“&gt; 6”) : puts(“&lt;= 6”);<br>}<br>这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 “&gt;6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。<br>2、评价下面的代码片断：<br>unsigned int zero = 0;<br>unsigned int compzero = 0xFFFF;<br>/*1’s complement of zero */<br>对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：<br>unsigned int compzero = ~0;<br>  这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。<br>3、 C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？<br>int a = 5, b = 7, c;<br>c = a+++b;<br>这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：<br>c = a++ + b;<br>因此, 这段代码持行后a = 6, b = 7, c = 12。<br>如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。<br>4、设有以下说明和定义：<br>typedef union {long i; int k[5]; char c;} DATE;<br>struct data { int cat; DATE cow; double dog;} too;<br>DATE max;<br>则语句 printf(“%d”,sizeof(struct date)+sizeof(max));的执行结果是？<br>答 、结果是：52。DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20<br>data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32.<br>所以结果是 20 + 32 = 52.<br>当然…在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20</p><p>5、请写出下列代码的输出内容<br>#include&lt;stdio.h&gt;<br>main()<br>{<br>int a,b,c,d;<br>a=10;<br>b=a++;<br>c=++a;<br>d=10*a++;<br>printf(“b，c，d：%d，%d，%d”，b，c，d）;<br>return 0;<br>}<br>答：10，12，120</p><p>6、写出下列代码的输出内容<br>#include&lt;stdio.h&gt;<br>int inc(int a)<br>{<br>return(++a);<br>}<br>int multi(int<em>a,int<em>b,int</em>c)<br>{<br>return(<em>c=</em>a**b);<br>}<br>typedef int(FUNC1)(int in);<br>typedef int(FUNC2) (int</em>,int<em>,int</em>);</p><p>void show(FUNC2 fun,int arg1, int<em>arg2)<br>{<br>INCp=&inc;<br>int temp =p(arg1);<br>fun(&amp;temp,&amp;arg1, arg2);<br>printf(“%d\n”,</em>arg2);<br>}</p><p>main()<br>{<br>int a;<br>show(multi,10,&amp;a);<br>return 0;<br>}<br>答：110<br>7、请找出下面代码中的所以错误<br>说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”</p><p>1、#include”string.h”<br>2、main()<br>3、{<br>4、 char<em>src=”hello,world”;<br>5、 char</em> dest=NULL;<br>6、 int len=strlen(src);<br>7、 dest=(char<em>)malloc(len);<br>8、 char</em> d=dest;<br>9、 char* s=src[len];<br>10、 while(len–!=0)<br>11、 d++=s–;<br>12、 printf(“%s”,dest);<br>13、 return 0;<br>14、}<br>答：<br>方法1：<br>int main(){<br>char* src = “hello,world”;<br>int len = strlen(src);<br>char* dest = (char<em>)malloc(len+1);//要为\0分配一个空间<br>char</em> d = dest;<br>char* s = &amp;src[len-1];//指向最后一个字符<br>while( len– != 0 )<br><em>d++=</em>s–;<br>*d = 0;//尾部要加\0<br>printf(“%s\n”,dest);<br>free(dest);// 使用完，应当释放空间，以免造成内存汇泄露<br>return 0;<br>}<br>方法2：<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>main()<br>{<br>char str[]=”hello,world”;<br>int len=strlen(str);<br>char t;<br>for(int i=0; i&lt;len/2; i++)<br>{<br>t=str[i];<br>str[i]=str[len-i-1]; str[len-i-1]=t;<br>}<br>printf(“%s”,str);<br>return 0;<br>}<br>8、请问下面程序有什么错误?<br>  int a[60][250][1000],i,j,k;<br>  for(k=0;k&lt;=1000;k++)<br>  for(j=0;j&lt;250;j++)<br>   for(i=0;i&lt;60;i++)<br>   a[i][j][k]=0;<br>答案：把循环语句内外换一下</p><p>9、请问下面程序会出现什么情况?<br>.   #define Max_CB 500<br>  void LmiQueryCSmd(Struct MSgCB * pmsg)<br>   {<br>   unsigned char ucCmdNum;<br>   ……</p><p>   for(ucCmdNum=0;ucCmdNum&lt;Max_CB;ucCmdNum++)<br>   {<br>   ……;<br>   }<br>答案：死循环</p><p>10、以下3个有什么区别<br>char * const p; //常量指针，p的值不可以修改<br>char const * p；//指向常量的指针，指向的常量值不可以改<br>const char *p； //和char const *p</p><p>11、写出下面的结果<br>char str1[] = “abc”;<br>char str2[] = “abc”;</p><p>const char str3[] = “abc”;<br>const char str4[] = “abc”;</p><p>const char *str5 = “abc”;<br>const char *str6 = “abc”;</p><p>char *str7 = “abc”;<br>char *str8 = “abc”;</p><p>cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;</p><p>结果是：0 0 1 1<br>解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；<br>而str5,str6,str7,str8是指针，它们指向相同的常量区域。</p><p>12、以下代码中的两个sizeof用法有问题吗？<br>void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母<br>{<br>  for( size_t i=0; i&lt;sizeof(str)/sizeof(str[0]); ++i )<br>    if( ‘a’&lt;=str[i] &amp;&amp; str[i]&lt;=’z’ )<br>      str[i] -= (‘a’-‘A’ );<br>}<br>char str[] = “aBcDe”;<br>cout &lt;&lt; “str字符长度为: “ &lt;&lt; sizeof(str)/sizeof(str[0]) &lt;&lt; endl;<br>UpperCase( str );<br>cout &lt;&lt; str &lt;&lt; endl;<br>答：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。</p><p>13、写出输出结果<br>main()<br>{<br> int a[5]={1,2,3,4,5};<br>  int <em>ptr=(int *)(&amp;a+1);<br>printf(“%d,%d”,</em>(a+1),<em>(ptr-1));<br>}<br>输出：2,5<br>*(a+1）就是a[1]，</em>(ptr-1)就是a[4],执行结果是2，5<br>&amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）<br>int <em>ptr=(int *)(&amp;a+1);<br>则ptr实际是&amp;(a[5]),也就是a+5<br>原因如下：<br>&amp;a是数组指针，其类型为 int (</em>)[5];<br>而指针加1要根据指针类型加上一定的值，<br>不同类型的指针+1之后增加的大小不同<br>a是长度为5的int数组指针，所以要加 5<em>sizeof(int)<br>所以ptr实际是a[5]<br>但是prt与(&amp;a+1)类型是不一样的(这点很重要)<br>所以prt-1只会减去sizeof(int</em>)<br>a,&amp;a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&amp;a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&amp;a+1是下一个对象的地址，即a[5].<br>14、请问以下代码有什么问题：<br>int  main()<br>{<br>char a;<br>char <em>str=&a;<br>strcpy(str,”hello”);<br>printf(str);<br>return 0;<br>}<br>没有为str分配内存空间，将会发生异常<br>问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。<br>char</em> s=”AAA”;<br>printf(“%s”,s);<br>s[0]=’B’;<br>printf(“%s”,s);<br>有什么错？<br>“AAA”是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。<br>cosnt char* s=”AAA”;<br>然后又因为是常量，所以对是s[0]的赋值操作是不合法的。</p><p>15、有以下表达式：<br>int a=248; b=4;int const c=21;const int <em>d=&a;<br>int *const e=&b;int const *f const =&a;<br>请问下列表达式哪些会被编译器禁止？为什么？<br>*c=32;d=&b;</em>d=43;e=34;e=&a;f=0x321f;<br>*c 这是个什么东东，禁止<br>*d 说了是const， 禁止<br>e = &amp;a 说了是const 禁止<br>const *f const =&a; 禁止</p><p>16、交换两个变量的值，不使用第三个变量。<br>即a=3,b=5,交换之后a=5,b=3;<br>有两种解法, 一种用算术算法, 一种用^(异或)<br>a = a + b;<br>b = a - b;<br>a = a - b;<br>or<br>a = a^b;// 只能对int,char..<br>b = a^b;<br>a = a^b;<br>or<br>a ^= b ^= a;<br>17、下面的程序会出现什么结果<br>.#include &lt;stdio.h&gt;<br> #include &lt;stdlib.h&gt;<br> void getmemory(char *p)<br> {<br>  p=(char *) malloc(100);<br>  strcpy(p,”hello world”);<br> }<br> int main( )<br> {<br>  char *str=NULL;<br>  getmemory(str);<br>  printf(“%s/n”,str);<br>  free(str);<br>  return 0;<br>  }<br>程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险</p><p>18、下面的语句会出现什么结果？<br>char szstr[10];<br>  strcpy(szstr,”0123456789”);<br>答案：长度不一样，会造成非法的OS，应该改为char szstr[11]；</p><p>19、(void <em>)ptr 和 (</em>(void<strong>))ptr的结果是否相同？<br>答：其中ptr为同一个指针<br>.(void <em>)ptr 和 (</em>(void</strong>))ptr值是相同的</p><p>20、问函数既然不会被其它函数调用，为什么要返回1？<br>int main()<br>  {<br>  int x=3;<br>  printf(“%d”,x);<br>  return 1;<br>  }<br>答：mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息</p><p>21、对绝对地址0x100000赋值且想让程序跳转到绝对地址是0x100000去执行<br>(unsigned int<em>)0x100000 = 1234;<br>首先要将0x100000强制转换成函数指针,即:<br>(void (</em>)())0x100000<br>然后再调用它:<br><em>((void (</em>)())0x100000)();<br>用typedef可以看得更直观些:<br>typedef void(*)() voidFuncPtr;<br>*((voidFuncPtr)0x100000)();</p><p>22、输出多少？并分析过程<br>unsigned short A = 10;<br>printf(“~A = %u\n”, ~A);</p><p>char c=128;<br>printf(“c=%d\n”,c);<br>  第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285<br>第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。<br>这两道题都是在考察二进制向int或uint转换时的最高位处理。</p><p>23、分析下面的程序：<br>void GetMemory(char **p,int num)<br>{<br>  *p=(char *)malloc(num);<br>}<br>int main()<br>{<br>  char *str=NULL;<br>  GetMemory(&amp;str,100);<br>  strcpy(str,”hello”);<br>  free(str);<br>  if(str!=NULL)<br>  {<br>    strcpy(str,”world”);<br>  }<br>  printf(“\n str is %s”,str);<br>  getchar();<br>}<br>问输出结果是什么？希望大家能说说原因，先谢谢了<br>输出str is world。<br>free 只是释放的str指向的内存空间,它本身的值还是存在的.<br>所以free之后，有一个好的习惯就是将str=NULL.<br>此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,<br>尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。<br>这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。<br>当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。<br>24、char a[10],strlen(a)为什么等于15？运行的结果<br>#include “stdio.h”<br>#include “string.h”</p><p>void main()<br>{<br>char aa[10];<br>printf(“%d”,strlen(aa));<br>}</p><p>sizeof()和初不初始化，没有关系；<br>strlen()和初始化有关。</p><p>char (<em>str)[20];/*str是一个数组指针，即指向数组的指针．</em>/<br>char <em>str[20];/*str是一个指针数组，其元素为指针型数据．</em>/</p><p>25、long a=0x801010;a+5=?<br>答：0x801010用二进制表示为：“1000 0000 0001 0000 0001 0000”，十进制的值为8392720，再加上5就是8392725</p><p>26、给定结构struct A<br>{<br>    char t:：4;<br>    char k:4;<br>    unsigned short i:8;<br>    unsigned long m;<br>};问sizeof(A) = ?<br>给定结构struct A<br>{<br>    char t:4; 4位<br>    char k:4; 4位<br>    unsigned short i:8; 8位<br>    unsigned long m; // 偏移2字节保证4字节对齐<br>}; // 共8字节</p><p>27、下面的函数实现在一个数上加一个数，有什么错误？请改正。<br>int add_n ( int n )<br>{<br>  static int i = 100;<br>  i += n;<br>  return i;<br>}<br>当你第二次调用时得不到正确的结果，难道你写个函数就是为了调用一次？问题就出在 static上<br>28、给出下面程序的答案<br>#include&lt;iostream.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;malloc.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;memory.h&gt;<br>typedef struct  AA<br>{<br>    int b1:5;<br>    int b2:2;<br>}AA;<br>void main()<br>{<br>    AA aa;<br>    char cc[100];<br>     strcpy(cc,”0123456789abcdefghijklmnopqrstuvwxyz”);<br>    memcpy(&amp;aa,cc,sizeof(AA));<br>    cout &lt;&lt; aa.b1 &lt;&lt;endl;<br>    cout &lt;&lt; aa.b2 &lt;&lt;endl;<br>}<br>答案是 -16和１<br>首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit.<br>经过strcpy和memcpy后,aa的4个字节所存放的值是:<br>0,1,2,3的ASC码，即00110000,00110001,00110010,00110011<br>所以，最后一步：显示的是这４个字节的前５位，和之后的２位<br>分别为：10000,和01<br>因为int是有正负之分　　所以：答案是-16和１</p><p>29、求函数返回值，输入x=9999;<br>int func （ x ）<br>{<br>  int countx = 0;<br>  while ( x )<br>  {<br>    countx ++;<br>    x = x&amp;(x-1);<br>  }<br>  return countx;<br>}<br>结果呢？<br>知道了这是统计9999的二进制数值中有多少个1的函数，且有<br>9999＝9×1024＋512＋256＋15</p><p>9×1024中含有1的个数为2；<br>512中含有1的个数为1；<br>256中含有1的个数为1；<br>15中含有1的个数为4；<br>故共有1的个数为8，结果为8。<br>1000 - 1 = 0111，正好是原数取反。这就是原理。<br>用这种方法来求1的个数是很效率很高的。<br>不必去一个一个地移位。循环次数最少。</p><p>30、分析：<br>struct bit<br>{  int a:3;<br>  int  b:2;<br>  int c:3;<br>};<br>int main()<br>{<br> bit s;<br> char <em>c=(char</em>)&s;<br>  cout&lt;&lt;sizeof(bit)&lt;&lt;endl;<br> *c=0x99;<br>  cout &lt;&lt; s.a &lt;&lt;endl &lt;&lt;s.b&lt;&lt;endl&lt;&lt;s.c&lt;&lt;endl;<br>   int a=-1;<br>  printf(“%x”,a);<br> return 0;<br>}<br>输出为什么是<br>4<br>1<br>-1<br>-4<br>ffffffff<br>因为0x99在内存中表示为 100 11 001 , a = 001, b = 11, c = 100<br>当c为有符合数时, c = 100, 最高1为表示c为负数，负数在计算机用补码表示，所以c = -4;同理<br>b = -1;<br>当c为有符合数时, c = 100,即 c = 4,同理 b = 3</p><p>31、下面这个程序执行后会有什么错误或者效果:<br> #define MAX 255<br> int main()<br>{<br>  unsigned char A[MAX],i;//i被定义为unsigned char<br>  for (i=0;i&lt;=MAX;i++)<br>   A[i]=i;<br>}<br>解答：死循环加数组越界访问（C/C++不进行数组越界检查）<br>MAX=255<br>数组A的下标范围为:0..MAX-1,这是其一..<br>其二.当i循环到255时,循环内执行:<br> A[255]=255;<br>这句本身没有问题..但是返回for (i=0;i&lt;=MAX;i++)语句时,<br>由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.</p><p>32、写出sizeof(struct name1)=,sizeof(struct name2)=的结果<br>struct name1{<br>  char  str;<br>  short x;<br>  int  num;<br>}</p><p>struct name2{<br>  char str;<br>  int num;<br>  short x;<br>}</p><p>sizeof(struct name1)=8,sizeof(struct name2)=12<br>在第二个结构中，为保证num按四个字节对齐，char后必须留出3字节的空间；同时为保证整个结构的自然对齐（这里是4字节对齐），在x后还要补齐2个字节，这样就是12字节。</p><p>33、struct s1<br>{<br> int i: 8;<br> int j: 4;<br> int a: 3;<br> double b;<br>};</p><p>struct s2<br>{<br> int i: 8;<br> int j: 4;<br> double b;<br> int a:3;<br>};</p><p>printf(“sizeof(s1)= %d\n”, sizeof(s1));<br>printf(“sizeof(s2)= %d\n”, sizeof(s2));<br>result: 16, 24<br>第一个struct s1<br>{<br> int i: 8;<br> int j: 4;<br> int a: 3;<br> double b;<br>};<br>理论上是这样的，首先是i在相对0的位置，占8位一个字节，然后，j就在相对一个字节的位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放在那里了，然后是a，要在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算过来是2字节2位的样子，由于double是8字节的，因此要在相对0要是8个字节的位置上放下，因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16字节。<br>第二个最后会对照是不是结构体内最大数据的倍数，不是的话，会补成是最大数据的倍数</p><p>34、在对齐为4的情况下<br>struct BBB<br>{<br>  long num；<br>  char <em>name;<br>  short int data;<br>  char ha;<br>  short ba[5];<br>}*p;<br>p=0x1000000;<br>p+0x200=<strong><strong>;<br>(Ulong)p+0x200=</strong></strong>;<br>(char</em>)p+0x200=____;<br>希望各位达人给出答案和原因，谢谢拉<br>解答：假设在32位CPU上，<br>sizeof(long) = 4 bytes<br>sizeof(char *) = 4 bytes<br>sizeof(short int) = sizeof(short) = 2 bytes<br>sizeof(char) = 1 bytes</p><p>由于是4字节对齐，<br>sizeof(struct BBB) = sizeof(<em>p)<br>= 4 + 4 + 2 + 1 + 1/*补齐</em>/ + 2<em>5 + 2/*补齐</em>/ = 24 bytes  (经Dev-C++验证)</p><p>p=0x1000000;<br>p+0x200=____;<br>  = 0x1000000 + 0x200*24</p><p>(Ulong)p+0x200=____;<br>  = 0x1000000 + 0x200</p><p>(char<em>)p+0x200=____;<br>  = 0x1000000 + 0x200</em>4</p><p>35、找错<br>Void test1()<br>{<br>char string[10];<br>char* str1=”0123456789”;<br>strcpy(string, str1);// 溢出，应该包括一个存放’\0’的字符string[11]<br>}</p><p>Void test2()<br>{<br>char string[10], str1[10];<br>for(I=0; I&lt;10;I++)<br>{<br>str1[i] =’a’;<br>}<br>strcpy(string, str1);// I，i没有声明。<br>}</p><p>Void test3(char* str1)<br>{<br>char string[10];<br>if(strlen(str1)&lt;=10)// 改成&lt;10,字符溢出，将strlen改为sizeof也可以<br>{<br>strcpy(string, str1);<br>}<br>}</p><p>36、写出输出结果<br>void g(int**);<br>int main()<br>{<br>int line[10],i;<br>int *p=line; //p是地址的地址<br>for (i=0;i&lt;10;i++)<br>{<br>*p=i;<br>g(&amp;p);//数组对应的值加1<br>}<br>for(i=0;i&lt;10;i++)<br>printf(“%d\n”,line[i]);<br>return 0;<br>}</p><p>void g(int<strong>p)<br>{<br>(</strong>p)++;<br>(*p)++;// 无效<br>}<br>输出：<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p><p>37、写出程序运行结果<br>int sum(int a)<br>{<br>auto int c=0;<br>static int b=3;<br>c+=1;<br>b+=2;<br>return(a+b+c);<br>}</p><p>void main()<br>{<br>int I;<br>int a=2;<br>for(I=0;I&lt;5;I++)<br>{<br>printf(“%d,”, sum(a));<br>}<br>}<br>// static会保存上次结果，记住这一点，剩下的自己写<br>输出：8,10,12,14,16,</p><p>38、评价代码<br>int func(int a)<br>{<br>int b;<br>switch(a)<br>{<br>case 1: 30;<br>case 2: 20;<br>case 3: 16;<br>default: 0<br>}<br>return b;<br>}<br>则func(1)=?<br>// b定义后就没有赋值</p><p>int a[3];<br>a[0]=0; a[1]=1; a[2]=2;<br>int *p, *q;<br>p=a;<br>q=&amp;a[2];<br>则a[q-p]=a[2]<br>解释：指针一次移动一个int但计数为1</p><p>39、请问一下程序将输出什么结果？<br>char *RetMenory(void)<br>{<br>    char p[] = “hellow world”;<br>    return p;<br>}<br>void Test(void)<br>{<br>    char *str = NULL;<br>    str = RetMemory();<br>    printf(str);<br>}<br>RetMenory执行完毕，p资源被回收，指向未知地址。返回地址，str的内容应是不可预测的, 打印的应该是str的地址</p><p>40、写出输出结果<br>typedef struct<br> {<br>   int a:2;<br>   int b:2;<br>   int c:1;<br> }test;</p><p> test t;<br> t.a = 1;<br> t.b = 3;<br> t.c = 1;</p><p> printf(“%d”,t.a);<br> printf(“%d”,t.b);<br> printf(“%d”,t.c);</p><p>t.a为01,输出就是1<br>t.b为11，输出就是－1<br>t.c为1，输出也是-1<br>3个都是有符号数int嘛。<br>这是位扩展问题<br>01<br>11<br>1<br>编译器进行符号扩展</p><p>41、对下面程序进行分析<br>void test2()<br>{<br>  char string[10], str1[10];<br>  int i;<br>  for(i=0; i&lt;10; i++)<br>  {<br>   str1[i] = ‘a’;<br>  }<br>  strcpy( string, str1 );<br>}<br>解答：如果面试者指出字符数组str1不能在数组内结束可以给3分；如果面试者指出strcpy(string, str1)调用使得从str1内存起复制到string内存起所复制的字节数具有不确定性可以给7分，在此基础上指出库函数strcpy工作方式的给10分；<br>str1不能在数组内结束:因为str1的存储为：{a,a,a,a,a,a,a,a,a,a},没有’\0’(字符串结束符)，所以不能结束<br>strcpy( char *s1,char *s2)他的工作原理是，扫描s2指向的内存，逐个字符付到s1所指向的内存，直到碰到’\0’,因为str1结尾没有’\0’，所以具有不确定性，不知道他后面还会付什么东东。<br>正确应如下<br>void test2()<br>{<br>  char string[10], str1[10];<br>  int i;<br>  for(i=0; i&lt;9; i++)<br>  {<br>   str1[i] = ‘a’+i; //把abcdefghi赋值给字符数组<br>  }<br>  str[i]=’\0’;//加上结束符<br>  strcpy( string, str1 );<br>}</p><p>42、分析：<br>int arr[] = {6,7,8,9,10};<br>int <em>ptr = arr;<br>*(ptr++)+=123;<br>printf(“ %d %d ”, *ptr, *(++ptr));<br>输出：8 8<br>过程：对于</em>(ptr++)+=123;先做加法6+123，然后++，指针指向7；对于printf(“ %d %d ”, *ptr, *(++ptr));从后往前执行，指针先++，指向8，然后输出8，紧接着再输出8</p><p>43、分析下面的代码：<br>char *a = “hello”;<br>char *b = “hello”;<br>if(a= =b)<br>printf(“YES”);<br>else<br>printf(“NO”);<br>这个简单的面试题目,我选输出 no(对比的应该是指针地址吧),可在VC是YES 在C是NO<br>lz的呢，是一个常量字符串。位于静态存储区，它在程序生命期内恒定不变。如果编译器优化的话，会有可能a和b同时指向同一个hello的。则地址相同。如果编译器没有优化，那么就是两个不同的地址，则不同</p><p>44、写出输出结果<br>#include &lt;stdio.h&gt;<br>void foo(int m, int n)<br>{<br>  printf(“m=%d, n=%d\n”, m, n);<br>}</p><p>int main()<br>{<br>  int b = 3;<br>  foo(b+=3, ++b);<br>  printf(“b=%d\n”, b);<br>return 0;<br>}<br>输出：m=7,n=4,b=7(VC6.0)<br>这种方式和编译器中得函数调用关系相关即先后入栈顺序。不过不同<br>编译器得处理不同。也是因为C标准中对这种方式说明为未定义，所以<br>各个编译器厂商都有自己得理解，所以最后产生得结果完全不同。<br>因为这样，所以遇见这种函数，我们首先要考虑我们得编译器会如何处理<br>这样得函数，其次看函数得调用方式，不同得调用方式，可能产生不同得<br>结果。最后是看编译器优化。</p><p>45、找出错误<br>#include  string.h<br>main(void)<br>{  char  <em>src=”hello,world”;<br>  char  *dest=NULL;<br>  dest=(char  *)malloc(strlen(src));<br>  int  len=strlen(str);<br>  char  *d=dest;<br>  char  *s=src[len];<br>  while(len–!=0)<br>   d++=s–;<br>  printf(“%s”,dest);<br>}<br>找出错误！！<br>#include  “string.h”<br>#include “stdio.h”<br>#include “malloc.h”<br>main(void)<br>{<br>char  *src=”hello,world”;<br>  char  *dest=NULL;<br>  dest=(char  *)malloc(sizeof(char)</em>(strlen(src)+1));<br>  int  len=strlen(src);<br>  char  <em>d=dest;<br>  char  *s=src+len-1;<br>  while(len–!=0)<br>   *d++=</em>s–;<br>*d=’\0’;<br>  printf(“%s”,dest);<br>}</p><p>第三部分：编程题<br>1、读文件file1.txt的内容（例如）：<br>12<br>34<br>56<br>输出到file2.txt：<br>56<br>34<br>12<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</p><p>int main(void)<br>{<br>     int MAX = 10;<br>int *a = (int *)malloc(MAX * sizeof(int));<br>int *b;</p><p>FILE *fp1;<br>FILE *fp2;</p><p>fp1 = fopen(“a.txt”,”r”);<br>if(fp1 == NULL)<br>{printf(“error1”);<br>  exit(-1);<br>}</p><p>  fp2 = fopen(“b.txt”,”w”);<br>if(fp2 == NULL)<br>{printf(“error2”);<br>  exit(-1);<br>}</p><p>int i = 0;<br>  int j = 0;</p><p>while(fscanf(fp1,”%d”,&amp;a[i]) != EOF)<br>{<br>i++;<br>j++;<br>if(i &gt;= MAX)<br>{<br>MAX = 2 * MAX;<br>b = (int*)realloc(a,MAX * sizeof(int));<br>if(b == NULL)<br>{<br>printf(“error3”);<br>exit(-1);<br>}<br>a = b;<br>}<br>}</p><p>for(;–j &gt;= 0;)<br>  fprintf(fp2,”%d\n”,a[j]);</p><p>fclose(fp1);<br>fclose(fp2);</p><p>return 0;</p><p>}</p><p>2、输出和为一个给定整数的所有组合<br>例如n=5<br>5=1+4；5=2+3（相加的数不能重复）<br>则输出<br>1，4；2，3。<br>#include &lt;stdio.h&gt;</p><p>int main(void)<br>{<br>unsigned long int i,j,k;</p><p>printf(“please input the number\n”);<br>scanf(“%d”,&amp;i);<br>  if( i % 2 == 0)<br>    j = i / 2;<br>else<br>j = i / 2 + 1;</p><p>printf(“The result is \n”);<br>  for(k = 0; k &lt; j; k++)<br>   printf(“%d = %d + %d\n”,i,k,i - k);<br>return 0;<br>}</p><p>#include &lt;stdio.h&gt;<br>void main()<br>{<br>unsigned long int a,i=1;<br>scanf(“%d”,&amp;a);<br>if(a%2==0)<br>{<br>   for(i=1;i&lt;a/2;i++)<br>   printf(“%d”,a,a-i);<br>}<br>else<br>for(i=1;i&lt;=a/2;i++)<br>    printf(“ %d, %d”,i,a-i);<br>}</p><p>3、递规反向输出字符串的例子,可谓是反序的经典例程.<br>void inverse(char *p)<br>{<br>  if( *p = = ‘\0’ )<br>return;<br>  inverse( p+1 );<br>  printf( “%c”, *p );<br>}</p><p>int main(int argc, char *argv[])<br>{<br>  inverse(“abc\0”);</p><p>  return 0;<br>}<br>对1的另一种做法：<br>#include &lt;stdio.h&gt;<br>void test(FILE *fread, FILE *fwrite)<br>{<br>    char buf[1024] = {0};<br>    if (!fgets(buf, sizeof(buf), fread))<br>        return;<br>    test( fread, fwrite );<br>    fputs(buf, fwrite);<br>}<br>int main(int argc, char *argv[])<br>{<br>    FILE *fr = NULL;<br>    FILE *fw = NULL;<br>    fr = fopen(“data”, “rb”);<br>    fw = fopen(“dataout”, “wb”);<br>    test(fr, fw);<br>    fclose(fr);<br>    fclose(fw);<br>    return 0;<br>}</p><p>4、写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。函数接口为：int find_orderk(const int* narry,const int n,const int k)<br>要求算法复杂度不能是O(n^2）<br>谢谢！<br>可以先用快速排序进行排序，其中用另外一个进行地址查找<br>代码如下，在VC++6.0运行通过。给分吧^-^</p><p>//快速排序</p><p>#include<iostream></iostream></p><p>usingnamespacestd;</p><p>intPartition (int*L,intlow,int high)<br>{<br>inttemp = L[low];<br>intpt = L[low];</p><p>while (low &lt; high)<br>{<br>while (low &lt; high &amp;&amp; L[high] &gt;= pt)<br>–high;<br>L[low] = L[high];<br>while (low &lt; high &amp;&amp; L[low] &lt;= pt)<br>++low;<br>L[low] = temp;<br>}<br>L[low] = temp;</p><p>returnlow;<br>}</p><p>voidQSort (int*L,intlow,int high)<br>{<br>if (low &lt; high)<br>{<br>intpl = Partition (L,low,high);</p><p>QSort (L,low,pl - 1);<br>QSort (L,pl + 1,high);<br>}<br>}</p><p>intmain ()<br>{<br>intnarry[100],addr[100];<br>intsum = 1,t;</p><p>cout &lt;&lt; “Input number:” &lt;&lt; endl;<br>cin &gt;&gt; t;</p><p>while (t != -1)<br>{<br>narry[sum] = t;<br>addr[sum - 1] = t;<br>sum++;</p><p>cin &gt;&gt; t;<br>}</p><p>sum -= 1;<br>QSort (narry,1,sum);</p><p>for (int i = 1; i &lt;= sum;i++)<br>cout &lt;&lt; narry[i] &lt;&lt; ‘\t’;<br>cout &lt;&lt; endl;</p><p>intk;<br>cout &lt;&lt; “Please input place you want:” &lt;&lt; endl;<br>cin &gt;&gt; k;</p><p>intaa = 1;<br>intkk = 0;<br>for (;;)<br>{<br>if (aa == k)<br>break;<br>if (narry[kk] != narry[kk + 1])<br>{<br>aa += 1;<br>kk++;<br>}</p><p>}</p><p>cout &lt;&lt; “The NO.” &lt;&lt; k &lt;&lt; “number is:” &lt;&lt; narry[sum - kk] &lt;&lt; endl;<br>cout &lt;&lt; “And it’s place is:” ;<br>for (i = 0;i &lt; sum;i++)<br>{<br>if (addr[i] == narry[sum - kk])<br>cout &lt;&lt; i &lt;&lt; ‘\t’;<br>}</p><p>return0;<br>}</p><p>5、两路归并排序<br>Linklist <em>unio(Linklist *p,Linklist *q){<br>linklist *R,</em>pa,<em>qa,</em>ra;<br>pa=p;<br>qa=q;<br>R=ra=p;<br>while(pa-&gt;next!=NULL&amp;&amp;qa-&gt;next!=NULL){<br>if(pa-&gt;data&gt;qa-&gt;data){<br>ra-&gt;next=qa;<br>qa=qa-&gt;next;<br>}<br>else{<br>ra-&gt;next=pa;<br>pa=pa-&gt;next;<br>}<br>}<br>if(pa-&gt;next!=NULL)<br>ra-&gt;next=pa;<br>if(qa-&gt;next!=NULL)<br>ra-&gt;next==qa;<br>return R;<br>}</p><p>6、用递归算法判断数组a[N]是否为一个递增数组。<br>递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回false结束：<br>bool fun( int a[], int n )<br>{<br>if( n= =1 )<br>return true;<br>if( n= =2 )<br>return a[n-1] &gt;= a[n-2];<br>return fun( a,n-1) &amp;&amp; ( a[n-1] &gt;= a[n-2] );<br>}</p><p>7、单连表的建立，把’a’–’z’26个字母插入到连表中，并且倒叙，还要打印！<br>方法1：<br>typedef struct val<br>{  int date_1;<br>  struct val <em>next;<br>}</em>p;</p><p>void main(void)<br>{  char c;</p><p>  for(c=122;c&gt;=97;c–)<br>    { p.date=c;<br>     p=p-&gt;next;<br>    }</p><p>  p.next=NULL;<br>}<br>}<br>方法2：<br>node *p = NULL;<br>node *q = NULL;</p><p>node <em>head = (node</em>)malloc(sizeof(node));<br>head-&gt;data = ‘ ‘;head-&gt;next=NULL;</p><p>node <em>first = (node</em>)malloc(sizeof(node));<br>first-&gt;data = ‘a’;first-&gt;next=NULL;head-&gt;next = first;<br>p = first;</p><p>int longth = ‘z’ - ‘b’;<br>int i=0;<br>while ( i&lt;=longth )<br>{<br>node <em>temp = (node</em>)malloc(sizeof(node));<br>temp-&gt;data = ‘b’+i;temp-&gt;next=NULL;q=temp;</p><p>head-&gt;next = temp; temp-&gt;next=p;p=q;<br>i++;<br>}</p><p>print(head);</p><p>8、请列举一个软件中时间换空间或者空间换时间的例子。<br>void swap(int a,int b)<br>{<br>int c; c=a;a=b;b=a;<br>}<br>—&gt;空优<br>void swap(int a,int b)<br>{<br>a=a+b;b=a-b;a=a-b;<br>}</p><p>9、outputstr所指的值为123456789<br>int continumax(char *outputstr, char *inputstr)<br>{<br>char *in = inputstr, *out = outputstr, *temp, *final;<br>int count = 0, maxlen = 0;</p><p>while( *in != ‘\0’ )<br>{<br>if( *in &gt; 47 &amp;&amp; *in &lt; 58 )<br>{<br>for(temp = in; *in &gt; 47 &amp;&amp; *in &lt; 58 ; in++ )<br>count++;<br>}<br>else<br>in++;</p><p>if( maxlen &lt; count )<br>{<br>maxlen = count;<br>count = 0;<br>final = temp;<br>}<br>}<br>for(int i = 0; i &lt; maxlen; i++)<br>{<br>*out = *final;<br>out++;<br>final++;<br>}<br>*out = ‘\0’;<br>return maxlen;<br>}</p><p>10、不用库函数,用C语言实现将一整型数字转化为字符串<br>方法1：<br>int getlen(char <em>s){<br>  int n;<br>  for(n = 0; <em>s != ‘\0’; s++)<br>      n++;<br>  return n;<br>}<br>void reverse(char s[])<br>{<br>  int c,i,j;<br>  for(i = 0,j = getlen(s) - 1; i &lt; j; i++,j–){<br>    c = s[i];<br>    s[i] = s[j];<br>    s[j] = c;<br>  }<br>}<br>void itoa(int n,char s[])<br>{<br>  int i,sign;<br>  if((sign = n) &lt; 0)<br>    n = -n;<br>  i = 0;<br>  do{/</em>以反序生成数字</em>/<br>   s[i++] = n%10 + ‘0’;/<em>get next number</em>/<br>  }while((n /= 10) &gt; 0);/<em>delete the number</em>/</p><p>  if(sign &lt; 0)<br>   s[i++] = ‘-‘;</p><p>  s[i] = ‘\0’;<br>  reverse(s);<br>}<br>方法2:<br>#include <iostream><br>using namespace std;</iostream></p><p>void itochar(int num);</p><p>void itochar(int num)<br>{<br>int i = 0;<br>int j ;<br>char stra[10];<br>char strb[10];<br>while ( num )<br>{<br>stra[i++]=num%10+48;<br>num=num/10;<br>}<br>stra[i] = ‘\0’;<br>for( j=0; j &lt; i; j++)<br>{<br>strb[j] = stra[i-j-1];<br>}<br>strb[j] = ‘\0’;<br>cout&lt;&lt;strb&lt;&lt;endl;</p><p>}<br>int main()<br>{<br>int num;<br>cin&gt;&gt;num;<br>itochar(num);<br>return 0;<br>}</p><p>11、求组合数： 求n个数（1….n）中k个数的组合….<br>      如：combination(5,3)<br> 要求输出：543，542，541，532，531，521，432，431，421，321，<br>#include&lt;stdio.h&gt;</p><p>int pop(int *);<br>int push(int );<br>void combination(int ,int );</p><p>int stack[3]={0};<br>top=-1;</p><p>int main()<br>{<br>int n,m;<br>printf(“Input two numbers:\n”);<br>while( (2!=scanf(“%d%*c%d”,&amp;n,&amp;m)) )<br>{<br>fflush(stdin);<br>printf(“Input error! Again:\n”);<br>}<br>combination(n,m);<br>printf(“\n”);<br>}<br>void combination(int m,int n)<br>{<br>int temp=m;<br>push(temp);<br>while(1)<br>{<br>if(1==temp)<br>{<br>if(pop(&amp;temp)&amp;&amp;stack[0]==n) //当栈底元素弹出&amp;&amp;为可能取的最小值，循环退出<br>break;<br>}<br>else if( push(–temp))<br>{<br>printf(“%d%d%d  “,stack[0],stack[1],stack[2]);//§&auml;¨ì¤@?<br>pop(&amp;temp);<br>}<br>}<br>}<br>int push(int i)<br>{<br>stack[++top]=i;<br>if(top&lt;2)<br>return 0;<br>else<br>return 1;<br>}<br>int pop(int *i)<br>{<br>*i=stack[top–];<br>if(top&gt;=0)<br>return 0;<br>else<br>return 1;<br>}</p><p>12、用指针的方法，将字符串“ABCD1234efgh”前后对调显示<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;dos.h&gt;<br>int main()<br>{<br>  char str[] = “ABCD1234efgh”;<br>  int length = strlen(str);<br>  char * p1 = str;<br>  char * p2 = str + length - 1;<br>  while(p1 &lt; p2)<br>  {<br>    char c = *p1;<br>    *p1 = *p2;<br>    *p2 = c;<br>    ++p1;<br>    –p2;<br>  }<br>  printf(“str now is %s\n”,str);<br>  system(“pause”);<br>  return 0;<br>}</p><p>13、有一分数序列：1/2,1/4,1/6,1/8……，用函数调用的方法，求此数列前20项的和<br>#include &lt;stdio.h&gt;<br>double getValue()<br>{<br>  double result = 0;<br>  int i = 2;<br>  while(i &lt; 42)<br>  {<br>    result += 1.0 / i;//一定要使用1.0做除数，不能用1，否则结果将自动转化成整数，即0.000000<br>    i += 2;<br>  }<br>  return result;<br>}<br>int main()<br>{<br>  printf(“result is %f\n”, getValue());<br>  system(“pause”);<br>  return 0;<br>}</p><p>14、有一个数组a[1000]存放0–1000;要求每隔二个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。<br>以7个数为例：<br>  {0,1,2,3,4,5,6,7} 0–&gt;1–&gt;2（删除）–&gt;3–&gt;4–&gt;5(删除)–&gt;6–&gt;7–&gt;0（删除），如此循环直到最后一个数被删除。<br>方法1：数组<br>#include <iostream><br>using namespace std;<br>#define null 1000</iostream></p><p>int main()<br>{<br>int arr[1000];<br>for (int i=0;i&lt;1000;++i)<br>arr[i]=i;<br>int j=0;<br>int count=0;<br>while(count&lt;999)<br>{<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>j=(++j)%1000;<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>j=(++j)%1000;<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>arr[j]=null;<br>++count;<br>}<br>while(arr[j]==null)<br>j=(++j)%1000;</p><p>cout&lt;&lt;j&lt;&lt;endl;<br>return 0;<br>}方法2：链表<br>#include<iostream><br>using namespace std;<br>#define null 0<br>struct node<br>{<br>int data;<br>node* next;<br>};<br>int main()<br>{<br>node* head=new node;<br>head-&gt;data=0;<br>head-&gt;next=null;<br>node* p=head;<br>for(int i=1;i&lt;1000;i++)<br>{<br>node* tmp=new node;<br>tmp-&gt;data=i;<br>tmp-&gt;next=null;<br>head-&gt;next=tmp;<br>head=head-&gt;next;<br>}<br>head-&gt;next=p;<br>while(p!=p-&gt;next)<br>{<br>p-&gt;next-&gt;next=p-&gt;next-&gt;next-&gt;next;<br>p=p-&gt;next-&gt;next;<br>}<br>cout&lt;<p->data;<br>return 0;<br>}<br>方法3：通用算法<br>#include &lt;stdio.h&gt;<br>#define MAXLINE 1000  //元素个数<br>/*<br>MAXLINE  元素个数<br>a[]    元素数组<br>R[]    指针场<br>suffix   下标<br>index   返回最后的下标序号<br>values   返回最后的下标对应的值<br>start   从第几个开始<br>K     间隔<br>*/<br>int find_n(int a[],int R[],int K,int&amp; index,int&amp; values,int s=0) {<br>  int suffix;<br>  int front_node,current_node;<br>  suffix=0;<br>   if(s==0) {<br>   current_node=0;<br>   front_node=MAXLINE-1;<br>   }<br>   else {<br>   current_node=s;<br>   front_node=s-1;<br>   }<br>    while(R[front_node]!=front_node) {<br>      printf(“%d\n”,a[current_node]);<br>      R[front_node]=R[current_node];<br>      if(K==1) {<br>       current_node=R[front_node];<br>       continue;<br>      }<br>      for(int i=0;i&lt;K;i++){<br>        front_node=R[front_node];<br>      }<br>      current_node=R[front_node];<br>    }<br> index=front_node;<br> values=a[front_node];</p-></iostream></p><p> return 0;<br>}<br>int main(void) {<br>int a[MAXLINE],R[MAXLINE],suffix,index,values,start,i,K;<br>suffix=index=values=start=0;<br>K=2;</p><p>for(i=0;i&lt;MAXLINE;i++) {<br>a[i]=i;<br>R[i]=i+1;<br>}<br>R[i-1]=0;<br>find_n(a,R,K,index,values,2);<br>printf(“the value is %d,%d\n”,index,values);<br>return 0;<br>}</p><p>15、实现strcmp<br>int StrCmp(const char <em>str1, const char *str2)<br>做是做对了，没有抄搞，比较乱<br>int StrCmp(const char *str1, const char *str2)<br>{<br>  assert(str1 &amp;&amp; srt2);<br>  while (</em>str1 &amp;&amp; <em>str2 &amp;&amp; *str1 == *str2) {<br>    str1++, str2++;<br>  }<br>  if (</em>str1 &amp;&amp; <em>str2)<br>    return (</em>str1-<em>str2);<br>  elseif (</em>str1 &amp;&amp; <em>str2==0)<br>    return 1;<br>  elseif (</em>str1 = = 0 &amp;&amp; *str2)<br>    return -1;<br>  else<br>    return 0;<br>}</p><p>int StrCmp(const char <em>str1, const char *str2)<br>{<br>     //省略判断空指针(自己保证)<br>while(</em>str1 &amp;&amp; <em>str1++ = = *str2++);<br>return *str1-</em>str2;<br>}</p><p>16、实现子串定位<br>int FindSubStr(const char <em>MainStr, const char *SubStr)<br>做是做对了，没有抄搞，比较乱<br>int MyStrstr(const char</em> MainStr, const char* SubStr)<br>{<br>const char *p;<br>const char *q;<br>const char * u = MainStr;</p><p>//assert((MainStr!=NULL)&amp;&amp;( SubStr!=NULL));//用断言对输入进行判断<br>while(<em>MainStr) //内部进行递增<br>{<br>p = MainStr;<br>q = SubStr;<br>while(</em>q &amp;&amp; <em>p &amp;&amp; *p++ == *q++);<br>if(!</em>q )<br>{<br>return MainStr - u +1 ;//MainStr指向当前起始位，u指向<br>}<br>MainStr ++;<br>}<br>return -1;<br>}</p><p>17、已知一个单向链表的头，请写出删除其某一个结点的算法，要求，先找到此结点，然后删除。<br>slnodetype <em>Delete(slnodetype *Head,int key){}中if(Head-&gt;number==key)<br>{<br>Head=Pointer-&gt;next;<br>free(Pointer);<br>break;<br>}<br>Back = Pointer;<br>    Pointer=Pointer-&gt;next;<br>if(Pointer-&gt;number==key)<br>{<br>      Back-&gt;next=Pointer-&gt;next;<br>free(Pointer);<br>break;<br>}<br>void delete(Node</em> p)<br>{<br>  if(Head = Node)</p><p>  while(p)<br>}</p><p>18、有1,2,….一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数.（华为）<br>#include&lt;iostream.h&gt;</p><p>int main()<br>{<br>  int a[]  = {10,6,9,5,2,8,4,7,1,3};<br>  int len = sizeof(a) / sizeof(int);<br>  int temp;</p><p>  for(int i = 0; i &lt; len; )<br>  {<br>temp = a[a[i] - 1];<br>a[a[i] - 1] = a[i];<br>a[i] = temp;</p><p>if ( a[i] == i + 1)<br> i++;<br>  }<br>  for (int j = 0; j &lt; len; j++)<br>   cout&lt;&lt;a[j]&lt;&lt;”,”;</p><p>  return 0;<br>}</p><p>19、写出程序把一个链表中的接点顺序倒排<br>typedef struct linknode<br>{<br>int data;<br>struct linknode <em>next;<br>}node;<br>//将一个链表逆置<br>node *reverse(node *head)<br>{<br>node *p,</em>q,*r;<br>p=head;<br>q=p-&gt;next;<br>while(q!=NULL)<br>{<br>r=q-&gt;next;<br>q-&gt;next=p;<br>p=q;<br>q=r;<br>}</p><p>head-&gt;next=NULL;<br>head=p;<br>return head;<br>}</p><p>20、写出程序删除链表中的所有接点<br>void del_all(node *head)<br>{<br>node *p;<br>while(head!=NULL)<br>{<br>p=head-&gt;next;<br>free(head);<br>head=p;<br>}<br>cout&lt;&lt;”释放空间成功!”&lt;&lt;endl;<br>}</p><p>21、两个字符串，s,t;把t字符串插入到s字符串中，s字符串有足够的空间存放t字符串<br>void insert(char <em>s, char *t, int i)<br>{<br>char *q = t;<br>char *p =s;<br>if(q == NULL)return;<br>while(</em>p!=’\0’)<br>{<br>p++;<br>}<br>while(<em>q!=0)<br>{<br>*p=</em>q;<br>p++;<br>q++;<br>}<br>*p = ‘\0’;<br>}</p><p>22、写一个函数，功能：完成内存之间的拷贝<br>memcpy source code:<br>  270 void* memcpy( void *dst, const void *src, unsigned int len )<br>  271 {<br>  272   register char *d;<br>  273   register char *s;<br>  27<br>  275   if (len == 0)<br>  276    return dst;<br>  277<br>  278   if (is_overlap(dst, src, len, len))<br>  279    complain3(“memcpy”, dst, src, len);<br>  280<br>  281   if ( dst &gt; src ) {<br>  282    d = (char *)dst + len - 1;<br>  283    s = (char *)src + len - 1;<br>  284    while ( len &gt;= 4 ) {<br>  285      *d– = *s–;<br>  286      *d– = *s–;<br>  287      *d– = *s–;<br>  288      *d– = *s–;<br>  289      len -= 4;<br>  290    }<br>  291    while ( len– ) {<br>  292      *d– = *s–;<br>  293    }<br>  294   } else if ( dst &lt; src ) {<br>  295    d = (char *)dst;<br>  296    s = (char *)src;<br>  297    while ( len &gt;= 4 ) {<br>  298      *d++ = *s++;<br>  299      *d++ = *s++;<br>  300      *d++ = *s++;<br>  301      *d++ = *s++;<br>  302      len -= 4;<br>  303    }<br>  304    while ( len– ) {<br>  305      *d++ = *s++;<br>  306    }<br>  307   }<br>  308   return dst;<br>  309 }</p><p>23、公司考试这种题目主要考你编写的代码是否考虑到各种情况，是否安全（不会溢出）<br>各种情况包括：<br>１、参数是指针，检查指针是否有效<br>２、检查复制的源目标和目的地是否为同一个，若为同一个，则直接跳出<br>３、读写权限检查<br>４、安全检查，是否会溢出<br>memcpy拷贝一块内存，内存的大小你告诉它<br>strcpy是字符串拷贝，遇到’\0’结束</p><p>/* memcpy ─── 拷贝不重叠的内存块 <em>/<br>void memcpy(void</em> pvTo, void* pvFrom, size_t size)<br>{<br>void* pbTo = (byte<em>)pvTo;<br>void</em> pbFrom = (byte*)pvFrom;<br>ASSERT(pvTo != NULL &amp;&amp; pvFrom != NULL); //检查输入指针的有效性<br>ASSERT(pbTo&gt;=pbFrom+size || pbFrom&gt;=pbTo+size);//检查两个指针指向的内存是否重叠<br>while(size–&gt;0)<br>*pbTo++ == *pbFrom++;<br>return(pvTo);<br>}</p><p>24、两个字符串，s,t;把t字符串插入到s字符串中，s字符串有足够的空间存放t字符串<br>void insert(char *s, char *t, int i)<br>{<br>memcpy(&amp;s[strlen(t)+i],&amp;s[i],strlen(s)-i);<br>memcpy(&amp;s[i],t,strlen(t));<br>s[strlen(s)+strlen(t)]=’\0’;<br>}</p><p>25、编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是由同一字符组成的。<br>char * search(char <em>cpSource, char ch)<br>{<br>     char *cpTemp=NULL, *cpDest=NULL;<br>     int iTemp, iCount=0;<br>     while(</em>cpSource)<br>     {<br>         if(<em>cpSource == ch)<br>         {<br>             iTemp = 0;<br>             cpTemp = cpSource;<br>             while(</em>cpSource == ch)<br>++iTemp, ++cpSource;<br>             if(iTemp &gt; iCount)<br>iCount = iTemp, cpDest = cpTemp;<br>    if(!*cpSource)<br>break;<br>         }<br>         ++cpSource;<br> }<br> return cpDest;<br>}   </p><p>26、请编写一个 C 函数，该函数在给定的内存区域搜索给定的字符，并返回该字符所在位置索引值。<br>int search(char *cpSource, int n, char ch)<br>{<br>     int i;<br>     for(i=0; i&lt;n &amp;&amp; *(cpSource+i) != ch; ++i);<br>     return i;<br>}</p><p>27、给定字符串A和B,输出A和B中的最大公共子串。<br>比如A=”aocdfe” B=”pmcdfa” 则输出”cdf”<br>*/<br>//Author: azhen<br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#include&lt;string.h&gt;</p><p>char *commanstring(char shortstring[], char longstring[])<br>{<br>int i, j;</p><p>char *substring=malloc(256);</p><p>if(strstr(longstring, shortstring)!=NULL)        //如果……，那么返回shortstring<br>return shortstring; </p><p>for(i=strlen(shortstring)-1;i&gt;0; i–)         //否则，开始循环计算<br>{<br>for(j=0; j&lt;=strlen(shortstring)-i; j++){<br>memcpy(substring, &amp;shortstring[j], i);<br>substring[i]=’\0’;<br>if(strstr(longstring, substring)!=NULL)<br>return substring;<br>}<br>}<br>return NULL;<br>}</p><p>main()<br>{<br>char *str1=malloc(256);<br>char *str2=malloc(256);<br>char *comman=NULL;</p><p>gets(str1);<br>gets(str2);</p><p>if(strlen(str1)&gt;strlen(str2))             //将短的字符串放前面<br>comman=commanstring(str2, str1);<br>else<br>comman=commanstring(str1, str2);</p><p>printf(“the longest comman string is: %s\n”, comman);<br>}<br>28、写一个函数比较两个字符串str1和str2的大小，若相等返回0，若str1大于<br>str2返回1，若str1小于str2返回－1<br>int strcmp ( const char * src,const char * dst)<br>{<br>    int ret = 0 ;<br>    while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) &amp;&amp; *dst)<br>{<br>        ++src;<br>++dst;<br>}<br>    if ( ret &lt; 0 )<br>        ret = -1 ;<br>    else if ( ret &gt; 0 )<br>        ret = 1 ;<br>    return( ret );<br>}</p><p>29、求1000！的未尾有几个0（用素数相乘的方法来做，如72=2<em>2</em>2<em>3</em>3）;<br>求出1-&gt;1000里,能被5整除的数的个数n1,能被25整除的数的个数n2,能被125整除的数的个数n3,<br>能被625整除的数的个数n4.<br>1000!末尾的零的个数=n1+n2+n3+n4;<br>#include&lt;stdio.h&gt;<br>#define NUM 1000</p><p>int find5(int num){<br>int ret=0;<br>while(num%5==0){<br>num/=5;<br>ret++;<br>}<br>return ret;<br>}<br>int main(){<br>int result=0;<br>int i;<br>for(i=5;i&lt;=NUM;i+=5)<br>{<br>result+=find5(i);<br>}<br>printf(“ the total zero number is %d\n”,result);<br>return 0;<br>}</p><p>30、有双向循环链表结点定义为：<br>struct node<br>{ int data;<br>struct node <em>front,</em>next;<br>};<br>有两个双向循环链表A，B，知道其头指针为：pHeadA,pHeadB，请写一函数将两链表中data值相同的结点删除<br>BOOL DeteleNode(Node *pHeader, DataType Value)<br>{<br>if (pHeader == NULL) return;</p><p>BOOL bRet = FALSE;<br>Node *pNode = pHead;<br>while (pNode != NULL)<br>{<br>if (pNode-&gt;data == Value)<br>{<br>if (pNode-&gt;front == NULL)<br>{<br>pHeader = pNode-&gt;next;<br>pHeader-&gt;front = NULL;<br>}<br>else<br>{<br>if (pNode-&gt;next != NULL)<br>{<br>pNode-&gt;next-&gt;front = pNode-&gt;front;<br>}<br>pNode-&gt;front-&gt;next = pNode-&gt;next;<br>}</p><p>Node *pNextNode = pNode-&gt;next;<br>delete pNode;<br>pNode = pNextNode;</p><p>bRet = TRUE;<br>//不要break或return, 删除所有<br>}<br>else<br>{<br>pNode = pNode-&gt;next;<br>}<br>}</p><p>return bRet;<br>}</p><p>void DE(Node *pHeadA, Node *pHeadB)<br>{<br>if (pHeadA == NULL || pHeadB == NULL)<br>{<br>return;<br>}</p><p>Node *pNode = pHeadA;<br>while (pNode != NULL)<br>{<br>if (DeteleNode(pHeadB, pNode-&gt;data))<br>{<br>if (pNode-&gt;front == NULL)<br>{<br>pHeadA = pNode-&gt;next;<br>pHeadA-&gt;front = NULL;<br>}<br>else<br>{<br>pNode-&gt;front-&gt;next = pNode-&gt;next;<br>if (pNode-&gt;next != NULL)<br>{<br>pNode-&gt;next-&gt;front = pNode-&gt;front;<br>}<br>}<br>Node *pNextNode = pNode-&gt;next;<br>delete pNode;<br>pNode = pNextNode;<br>}<br>else<br>{<br>pNode = pNode-&gt;next;<br>}<br>}<br>}</p><p>31、编程实现：找出两个字符串中最大公共子字符串,如”abccade”,”dgcadde”的最大子串为”cad”<br>int GetCommon(char <em>s1, char *s2, char *</em>r1, char **r2)<br>{<br>int len1 = strlen(s1);<br>int len2 = strlen(s2);<br>int maxlen = 0;</p><p>for(int i = 0; i &lt; len1; i++)<br>{<br>for(int j = 0; j &lt; len2; j++)<br>{<br>if(s1[i] == s2[j])<br>{<br>int as = i, bs = j, count = 1;<br>while(as + 1 &lt; len1 &amp;&amp; bs + 1 &lt; len2 &amp;&amp; s1[++as] == s2[++bs])<br>count++;</p><p>if(count &gt; maxlen)<br>{<br>maxlen = count;<br>*r1 = s1 + i;<br>*r2 = s2 + j;<br>}<br>}<br>}<br>}</p><p>32、编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数<br>char* test3(long num) {<br>char* buffer = (char*)malloc(11);<br>buffer[0] = ‘0’;<br>buffer[1] = ‘x’;<br>buffer[10] = ‘\0’;</p><p>char* temp = buffer + 2;<br>for (int i=0; i &lt; 8; i++) {<br>temp[i] = (char)(num&lt;&lt;4*i&gt;&gt;28);<br>temp[i] = temp[i] &gt;= 0 ? temp[i] : temp[i] + 16;<br>temp[i] = temp[i] &lt; 10 ? temp[i] + 48 : temp[i] + 55;<br>}<br>return buffer;<br>}</p><p>33、输入N, 打印 N*N 矩阵<br>比如 N = 3，打印：</p><p>1  2  3<br>8  9  4<br>7  6  5</p><p>N = 4，打印：</p><p>1  2  3  4<br>12  13  14  5<br>11  16  15  6<br>10  9  8  7<br>解答：<br>1 #define N 15<br>int s[N][N];<br>void main()<br>{<br>int k = 0, i = 0, j = 0;<br>int a = 1;<br>for( ; k &lt; (N+1)/2; k++ )<br>{<br>while( j &lt; N-k ) s[i][j++] = a++; i++; j–;<br>while( i &lt; N-k ) s[i++][j] = a++; i–; j–;<br>while( j &gt; k-1 ) s[i][j–] = a++; i–; j++;<br>while( i &gt; k )  s[i–][j] = a++; i++; j++;<br>}<br>for( i = 0; i &lt; N; i++ )<br>{<br>for( j = 0; j &lt; N; j++ )<br>cout &lt;&lt; s[i][j] &lt;&lt; ‘\t’;<br>cout &lt;&lt; endl;<br>}<br>}<br>2 define MAX_N  100<br>int matrix[MAX_N][MAX_N];</p><p>/*<br> <em>（x,y）：第一个元素的坐标<br> \</em> start：第一个元素的值<br> * n：矩阵的大小<br> */<br>void SetMatrix(int x, int y, int start, int n) {<br>  int i, j;</p><p>  if (n &lt;= 0)   //递归结束条件<br>    return;<br>  if (n == 1) {  //矩阵大小为1时<br>    matrix[x][y] = start;<br>    return;<br>  }<br>  for (i = x; i &lt; x + n-1; i++)  //矩阵上部<br>    matrix[y][i] = start++;</p><p>  for (j = y; j &lt; y + n-1; j++)  //右部<br>    matrix[j][x+n-1] = start++;</p><p>  for (i = x+n-1; i &gt; x; i–)   //底部<br>    matrix[y+n-1][i] = start++;</p><p>  for (j = y+n-1; j &gt; y; j–)   //左部<br>    matrix[j][x] = start++;</p><p>  SetMatrix(x+1, y+1, start, n-2);  //递归<br>}</p><p>void main() {<br>  int i, j;<br>  int n;</p><p>  scanf(“%d”, &amp;n);<br>  SetMatrix(0, 0, 1, n);</p><p>  //打印螺旋矩阵<br>  for(i = 0; i &lt; n; i++) {<br>   for (j = 0; j &lt; n; j++)<br>printf(“%4d”, matrix[i][j]);<br>   printf(“\n”);<br>  }<br>}</p><p>34、斐波拉契数列递归实现的方法如下：<br> int  Funct( int n )<br>{<br>  if(n==0) return 1;<br>  if(n==1) return 1;<br>  retrurn  Funct(n-1) + Funct(n-2);<br>}<br>请问，如何不使用递归，来实现上述函数？<br>请教各位高手！<br>解答：int  Funct( int n )  //  n 为非负整数<br>{<br>  int a=0;<br>  int b=1;<br>  int c;<br>  if(n==0) c=1;<br>  else if(n==1) c=1;<br>  else for(int i=2;i&lt;=n;i++)  //应该n从2开始算起<br>  {<br>   c=a+b;<br>   a=b;<br>   b=c;<br>  }<br>  return c;<br>}<br>解答：<br>现在大多数系统都是将低字位放在前面，而结构体中位域的申明一般是先声明高位。<br>100  的二进制是 001 100 100<br>低位在前  高位在后<br>001—-s3<br>100—-s2<br>100—-s1<br>所以结果应该是 1<br>如果先申明的在低位则：<br>001—-s1<br>100—-s2<br>100—-s3<br>结果是 4<br>1、原题跟little-endian，big-endian没有关系<br>2、原题跟位域的存储空间分配有关，到底是从低字节分配还是从高字节分配，从Dev C++和VC7.1上看，都是从低字节开始分配，并且连续分配，中间不空，不像谭的书那样会留空位<br>3、原题跟编译器有关，编译器在未用堆栈空间的默认值分配上有所不同，Dev C++未用空间分配为<br>01110111b，VC7.1下为11001100b,所以在Dev C++下的结果为5，在VC7.1下为1。</p><p>注：PC一般采用little-endian，即高高低低，但在网络传输上，一般采用big-endian，即高低低高，华为是做网络的，所以可能考虑big-endian模式，这样输出结果可能为4</p><p>35、判断一个字符串是不是回文<br>int IsReverseStr(char <em>aStr)<br>{<br>int i,j;<br>int found=1;<br>if(aStr==NULL)<br>return -1;<br>j=strlen(aStr);<br>for(i=0;i&lt;j/2;i++)<br>if(</em>(aStr+i)!=*(aStr+j-i-1))<br>{<br>found=0;<br>break;<br>}<br>return found;<br>}</p><p>36、Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><p>数组实现：<br>#include &lt;stdio.h&gt;<br>#include &lt;malloc.h&gt;<br>int Josephu(int n, int m)<br>{<br> int flag, i, j = 0;<br> int *arr = (int *)malloc(n * sizeof(int));<br> for (i = 0; i &lt; n; ++i)<br>  arr[i] = 1;<br> for (i = 1; i &lt; n; ++i)<br> {<br>  flag = 0;<br>  while (flag &lt; m)<br>  {<br>   if (j == n)<br>    j = 0;<br>   if (arr[j])<br>    ++flag;<br>   ++j;<br>  }<br>  arr[j - 1] = 0;<br>  printf(“第%4d个出局的人是：%4d号\n”, i, j);<br> }<br> free(arr);<br> return j;<br>}<br>int main()<br>{<br> int n, m;<br> scanf(“%d%d”, &amp;n, &amp;m);<br> printf(“最后胜利的是%d号！\n”, Josephu(n, m));<br> system(“pause”);<br> return 0;<br>}<br>链表实现：<br>#include &lt;stdio.h&gt;<br>#include &lt;malloc.h&gt;<br>typedef struct Node<br>{<br> int index;<br> struct Node *next;<br>}JosephuNode;<br>int Josephu(int n, int m)<br>{<br> int i, j;<br> JosephuNode *head, *tail;<br> head = tail = (JosephuNode *)malloc(sizeof(JosephuNode));<br> for (i = 1; i &lt; n; ++i)<br> {<br>  tail-&gt;index = i;<br>  tail-&gt;next = (JosephuNode *)malloc(sizeof(JosephuNode));<br>  tail = tail-&gt;next;<br> }<br> tail-&gt;index = i;<br> tail-&gt;next = head;</p><p> for (i = 1; tail != head; ++i)<br> {<br>  for (j = 1; j &lt; m; ++j)<br>  {<br>   tail = head;<br>   head = head-&gt;next;<br>  }<br>  tail-&gt;next = head-&gt;next;<br>  printf(“第%4d个出局的人是：%4d号\n”, i, head-&gt;index);<br>  free(head);<br>  head = tail-&gt;next;<br> }<br> i = head-&gt;index;<br> free(head);<br> return i;<br>}<br>int main()<br>{<br> int n, m;<br> scanf(“%d%d”, &amp;n, &amp;m);<br> printf(“最后胜利的是%d号！\n”, Josephu(n, m));<br> system(“pause”);<br> return 0;<br>}</p><p>37、已知strcpy函数的原型是：<br>    char * strcpy(char * strDest,const char * strSrc);<br>  1.不调用库函数，实现strcpy函数。<br>  2.解释为什么要返回char <em>。<br>  解说：<br>  1.strcpy的实现代码<br>    char * strcpy(char * strDest,const char * strSrc)<br>    {<br>        if ((strDest==NULL)||(strSrc==NULL)) file://[/1]<br>            throw “Invalid argument(s)”; //[2]<br>        char * strDestCopy=strDest;  file://[/3]<br>        while ((</em>strDest++=<em>strSrc++)!=’\0’); file://[/4]<br>        return strDestCopy;<br>    }<br>  错误的做法：<br>  [1]<br>  (A)不检查指针的有效性，说明答题者不注重代码的健壮性。<br>  (B)检查指针的有效性时使用((!strDest)||(!strSrc))或(!(strDest&amp;&amp;strSrc))，说明答题者对C语言中类型的隐式转换没有深刻认识。在本例中char *转换为bool即是类型隐式转换，这种功能虽然灵活，但更多的是导致出错概率增大和维护成本升高。所以C++专门增加了bool、true、false三个关键字以提供更安全的条件表达式。<br>  (C)检查指针的有效性时使用((strDest==0)||(strSrc==0))，说明答题者不知道使用常量的好处。直接使用字面常量（如本例中的0）会减少程序的可维护性。0虽然简单，但程序中可能出现很多处对指针的检查，万一出现笔误，编译器不能发现，生成的程序内含逻辑错误，很难排除。而使用NULL代替0，如果出现拼写错误，编译器就会检查出来。<br>  [2]<br>  (A)return new string(“Invalid argument(s)”);，说明答题者根本不知道返回值的用途，并且他对内存泄漏也没有警惕心。从函数中返回函数体内分配的内存是十分危险的做法，他把释放内存的义务抛给不知情的调用者，绝大多数情况下，调用者不会释放内存，这导致内存泄漏。<br>  (B)return 0;，说明答题者没有掌握异常机制。调用者有可能忘记检查返回值，调用者还可能无法检查返回值（见后面的链式表达式）。妄想让返回值肩负返回正确值和异常值的双重功能，其结果往往是两种功能都失效。应该以抛出异常来代替返回值，这样可以减轻调用者的负担、使错误不会被忽略、增强程序的可维护性。<br>  [3]<br>  (A)忘记保存原始的strDest值，说明答题者逻辑思维不严密。<br>  [4]<br>  (A)循环写成while (</em>strDest++=<em>strSrc++);，同<a href="B">1</a>。<br>  (B)循环写成while (</em>strSrc!=’\0’) <em>strDest++=</em>strSrc++;，说明答题者对边界条件的检查不力。循环体结束后，strDest字符串的末尾没有正确地加上’\0’。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="学习" scheme="http://www.kangxh.xyz/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C语言" scheme="http://www.kangxh.xyz/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言面试题1</title>
    <link href="http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
    <id>http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%981/</id>
    <published>2021-03-09T12:39:43.000Z</published>
    <updated>2021-03-09T12:59:25.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="第1题，c语言有哪些核心的特征？"><a href="#第1题，c语言有哪些核心的特征？" class="headerlink" title="第1题，c语言有哪些核心的特征？"></a>第1题，c语言有哪些核心的特征？</h3><p>可移植性很强。</p><p>模块化能力很强。</p><p>灵活性很高。</p><p>加载速度和执行速度都很好。</p><p>可扩展性很强。</p><h3 id="第2题，c语言中有哪些基本的数据类型？"><a href="#第2题，c语言中有哪些基本的数据类型？" class="headerlink" title="第2题，c语言中有哪些基本的数据类型？"></a>第2题，c语言中有哪些基本的数据类型？</h3><p>Int整型。</p><p>Float浮点型。</p><p>Double双浮点型。</p><p>Char单个字符。</p><p>void特殊类型，不包含任何值。</p><h3 id="第3题，-解释一下语义错误。"><a href="#第3题，-解释一下语义错误。" class="headerlink" title="第3题， 解释一下语义错误。"></a>第3题， 解释一下语义错误。</h3><p>在写程序的时候会有很多语义错误，比如说，拼错了命令，一个函数的参数个数错了， 数据类型不匹配，等等。</p><h3 id="第4题，-C语言中如何使用增加和减少语句"><a href="#第4题，-C语言中如何使用增加和减少语句" class="headerlink" title="第4题， C语言中如何使用增加和减少语句?"></a>第4题， C语言中如何使用增加和减少语句?</h3><p>有两种方式:</p><p>++， –</p><p>或者</p><p>传统的加和减。</p><h3 id="第5题，-什么是一个编程语言的保留字"><a href="#第5题，-什么是一个编程语言的保留字" class="headerlink" title="第5题， 什么是一个编程语言的保留字?"></a>第5题， 什么是一个编程语言的保留字?</h3><p>保留字是指语言库中使用的一些关键字。这些关键字不能用来做其他的事情，比如说定义一个变量或者函数等等。</p><h3 id="第6题，-解释一下dangling-pointer。"><a href="#第6题，-解释一下dangling-pointer。" class="headerlink" title="第6题， 解释一下dangling pointer。"></a>第6题， 解释一下dangling pointer。</h3><p>首先我们说有一个指针指向一个变量的内存地址。一段时间以后这个变量被从内存地址的位置删除了。</p><p>这样的指针称之为dangling pointer.</p><h3 id="第7题，描述一下静态函数的用途。"><a href="#第7题，描述一下静态函数的用途。" class="headerlink" title="第7题，描述一下静态函数的用途。"></a>第7题，描述一下静态函数的用途。</h3><p>使用静态static关键字定义的函数称之为静态函数。</p><p>这样的函数需要在相同的代码里调用。</p><h3 id="第8题-abs和fabs的区别是什么"><a href="#第8题-abs和fabs的区别是什么" class="headerlink" title="第8题, abs和fabs的区别是什么?"></a>第8题, abs和fabs的区别是什么?</h3><p>这两个函数都是用来取绝对值的。前者是针对整型的。后者是针对浮点型的。前者位于标准库stdlib.h里面。后者在math.h里面。</p><h3 id="第9题-说一下wild-pointers。"><a href="#第9题-说一下wild-pointers。" class="headerlink" title="第9题, 说一下wild pointers。"></a>第9题, 说一下wild pointers。</h3><p>未初始化的指针称之为wild pointers。这些指针指向一个随意的内存地址。如果访问它们可能会导致很坏的程序行为，甚至导致程序崩溃。</p><h3 id="第10题，-a和a-的区别是什么"><a href="#第10题，-a和a-的区别是什么" class="headerlink" title="第10题， ++a和a++的区别是什么?"></a>第10题， ++a和a++的区别是什么?</h3><p>加加a的意思是先加后取值。</p><p>A加加的意思是先取值后增加。</p><h3 id="第11题，-单等号和双等号的区别是什么"><a href="#第11题，-单等号和双等号的区别是什么" class="headerlink" title="第11题， 单等号和双等号的区别是什么?"></a>第11题， 单等号和双等号的区别是什么?</h3><p>单等号表示赋值运算符。</p><p>双等号是等于条件判断运算符。</p><h3 id="第12题，解释一下c语言的原型函数。"><a href="#第12题，解释一下c语言的原型函数。" class="headerlink" title="第12题，解释一下c语言的原型函数。"></a>第12题，解释一下c语言的原型函数。</h3><p>原型函数是对一个函数的声明。</p><p>它包含函数名，返回值和参数类型列表。</p><p>int sum(int,int)</p><h3 id="第13题，-解释一下数据类型的cyclic-nature。"><a href="#第13题，-解释一下数据类型的cyclic-nature。" class="headerlink" title="第13题， 解释一下数据类型的cyclic nature。"></a>第13题， 解释一下数据类型的cyclic nature。</h3><p>在c语言中，当一个程序员给一个数据类型的变量赋值的时候，有可能会溢出。这种溢出不会产生编译错误。最终的赋值结果会根据数据类型溢出后的剩余而定。这种行为称为cyclic nature. Char, int, long int数据类型有这个特性。Further float, double和long double数据类型没有这个特性。</p><h3 id="第14题-说一下c语言的头文件和用途。"><a href="#第14题-说一下c语言的头文件和用途。" class="headerlink" title="第14题, 说一下c语言的头文件和用途。"></a>第14题, 说一下c语言的头文件和用途。</h3><p>头文件存放了原型函数的定义。这个文件又称为库文件。</p><p>比如说printf和scanf存放在stdio.h里面。</p><h3 id="第15题-解释一下在调试过程中对代码进行注释的做法。"><a href="#第15题-解释一下在调试过程中对代码进行注释的做法。" class="headerlink" title="第15题, 解释一下在调试过程中对代码进行注释的做法。"></a>第15题, 解释一下在调试过程中对代码进行注释的做法。</h3><p>这个做法称为commenting out。通过把一些代码屏蔽掉来判断或排除是否是这些代码造成的错误。</p><h3 id="第16题，-说一下c语言中循环的类型。"><a href="#第16题，-说一下c语言中循环的类型。" class="headerlink" title="第16题， 说一下c语言中循环的类型。"></a>第16题， 说一下c语言中循环的类型。</h3><p>C语言中有4种循环类型。</p><p>while</p><p>for</p><p>do while</p><p>nested loop</p><h3 id="第17题-什么是nested-loop"><a href="#第17题-什么是nested-loop" class="headerlink" title="第17题, 什么是nested loop?"></a>第17题, 什么是nested loop?</h3><p>一个循环包含在另一个循环中称为nested loop。第1个循环成为外循环。里面的循环称为内循环。内循环执行的次数作为总循环的次数。</p><h3 id="第18题，c语言中函数的通常格式是怎样的？"><a href="#第18题，c语言中函数的通常格式是怎样的？" class="headerlink" title="第18题，c语言中函数的通常格式是怎样的？"></a>第18题，c语言中函数的通常格式是怎样的？</h3><p>C语言的函数，包含4个部分。</p><p>返回值， 函数名， 参数， 函数体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(imt y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y+z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第19题-什么是指针的指针"><a href="#第19题-什么是指针的指针" class="headerlink" title="第19题, 什么是指针的指针?"></a>第19题, 什么是指针的指针?</h3><p>指针的指针是指一个指向指针所在地址的指针。</p><p>int a=5, *x=&amp;a, y=&x;</p><h3 id="第20题-Break关键字在哪个地方使用"><a href="#第20题-Break关键字在哪个地方使用" class="headerlink" title="第20题, Break关键字在哪个地方使用?"></a>第20题, Break关键字在哪个地方使用?</h3><p>Break可以用在循环中和switch语句当中。是用来终止当前的循环或跳出switch。</p><h3 id="第21题，-使用头文件时双引号和尖括号的区别是什么"><a href="#第21题，-使用头文件时双引号和尖括号的区别是什么" class="headerlink" title="第21题， 使用头文件时双引号和尖括号的区别是什么?"></a>第21题， 使用头文件时双引号和尖括号的区别是什么?</h3><p>使用双引号时，首先要在当前工作目录中查找这个头文件，如果找不到的话就会在内置的include path里面找。</p><p>使用尖括号时，只会在当前工作目录中查找这个头文件。</p><h3 id="第22题，什么是sequential访问文件"><a href="#第22题，什么是sequential访问文件" class="headerlink" title="第22题，什么是sequential访问文件?"></a>第22题，什么是sequential访问文件?</h3><p>这种文件用来存储数据，在写数据的时候会按照按照一个序列模式。在读取的时候也是按照这个模式往外读取。</p><h3 id="第23题，-如何向栈数据结构里面存储数据"><a href="#第23题，-如何向栈数据结构里面存储数据" class="headerlink" title="第23题， 如何向栈数据结构里面存储数据?"></a>第23题， 如何向栈数据结构里面存储数据?</h3><p>这样的数据是先进后出的。只有顶部的数据才可以被访问到。存储的时候使用push，获取的时候使用pop。</p><h3 id="第24题，C程序算法的意义是什么"><a href="#第24题，C程序算法的意义是什么" class="headerlink" title="第24题，C程序算法的意义是什么?"></a>第24题，C程序算法的意义是什么?</h3><p>算法的意义在于提高程序的执行效率，是注重空间的节省，还是注重时间的节省，是写算法时需要考虑的因素。</p><h3 id="第25题，写一个c程序，输出下面的结果。"><a href="#第25题，写一个c程序，输出下面的结果。" class="headerlink" title="第25题，写一个c程序，输出下面的结果。"></a>第25题，写一个c程序，输出下面的结果。</h3><p>1</p><p>1 2</p><p>1 2 3</p><p>1 2 3 4</p><p>1 2 3 4 5</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">for</span>(a=<span class="number">1</span>;a&lt;<span class="number">6</span>;a++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(b=<span class="number">1</span>;b&lt;=a;b++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第26题-如下条件判断运算符哪个在c语言里不可用"><a href="#第26题-如下条件判断运算符哪个在c语言里不可用" class="headerlink" title="第26题, 如下条件判断运算符哪个在c语言里不可用?"></a>第26题, 如下条件判断运算符哪个在c语言里不可用?</h3><p>==, &lt;&gt;, &lt;=, &gt;=</p><p>答案是&lt;&gt;。</p><h3 id="第27题-在c语言中可不可以用大括号包含一行代码"><a href="#第27题-在c语言中可不可以用大括号包含一行代码" class="headerlink" title="第27题, 在c语言中可不可以用大括号包含一行代码?"></a>第27题, 在c语言中可不可以用大括号包含一行代码?</h3><p>是的, 当然可以。很多程序员使用大括号来规范代码结构，不管是一行还是多行。</p><h3 id="第28题-描述一下modifier。"><a href="#第28题-描述一下modifier。" class="headerlink" title="第28题, 描述一下modifier。"></a>第28题, 描述一下modifier。</h3><p>Modifier是数据类型的前置，用来标识存储空间的大小。</p><p>比如说在32位处理器系统中, 整形的长度为4bits。</p><p>如果我们加了如下的modifier:</p><p>Long Int 就可以存8 bits。</p><p>Short Int 占 2 bits。</p><h3 id="第29题-在c语言中有哪些modifiers"><a href="#第29题-在c语言中有哪些modifiers" class="headerlink" title="第29题, 在c语言中有哪些modifiers?"></a>第29题, 在c语言中有哪些modifiers?</h3><p>Short</p><p>Long</p><p>Signed</p><p>Unsigned</p><p>long long</p><h3 id="第30题，-在c语言中如何产生随机数"><a href="#第30题，-在c语言中如何产生随机数" class="headerlink" title="第30题， 在c语言中如何产生随机数?"></a>第30题， 在c语言中如何产生随机数?</h3><p>rand 函数就是用来产生随机数的，它可以产生任意从0开始的整数。</p><h3 id="第31题-能不能在整型中存放32768这个数"><a href="#第31题-能不能在整型中存放32768这个数" class="headerlink" title="第31题, 能不能在整型中存放32768这个数?"></a>第31题, 能不能在整型中存放32768这个数?</h3><p>整数类型可以存放从-32768~32767之间的任何数值。但是32768不在这个范围之内。这个时候modifier是我们需要的东西。Long Int数据类型就可以存放这个数。</p><h3 id="第32题-在c语言中可以自定义头文件吗"><a href="#第32题-在c语言中可以自定义头文件吗" class="headerlink" title="第32题, 在c语言中可以自定义头文件吗?"></a>第32题, 在c语言中可以自定义头文件吗?</h3><p>是的, 当然可以, 定义完头文件以后可以存放函数的原型。</p><p>使用的时候, 用include来包含这个文件的名字。</p><h3 id="第33题，解释一下c语言中的动态数据结构。"><a href="#第33题，解释一下c语言中的动态数据结构。" class="headerlink" title="第33题，解释一下c语言中的动态数据结构。"></a>第33题，解释一下c语言中的动态数据结构。</h3><p>动态数据结构在访问内存方面非常高效。内存的访问，要因程序的需求而定。</p><h3 id="第34题，什么是indirection"><a href="#第34题，什么是indirection" class="headerlink" title="第34题，什么是indirection?"></a>第34题，什么是indirection?</h3><p>如果你定一个指针变量， 它指向一个值变量或者一个内存对象。在这种情况下，对这个值变量和对象来说没有一个直接的引用。这种情况就是indirection.</p><p>但是如果我们声明一个变量，它对值来说就是一个直接的引用。</p><h3 id="第35题，-在c语言中，什么时候会用到空指针"><a href="#第35题，-在c语言中，什么时候会用到空指针" class="headerlink" title="第35题， 在c语言中，什么时候会用到空指针?"></a>第35题， 在c语言中，什么时候会用到空指针?</h3><p>有三种情况，在c语言中会用到空指针。</p><p>作为一个错误值。</p><p>作为一个监测值。</p><p>在一个递归数据结构中终止indirection。</p><h3 id="第36题，-解释一下模块化编程。"><a href="#第36题，-解释一下模块化编程。" class="headerlink" title="第36题， 解释一下模块化编程。"></a>第36题， 解释一下模块化编程。</h3><p>把主程序分成多个小的，可执行的模块称为模块化编程。这个概念是为了增强重用性。同时也提高了程序的可维护性。</p><h3 id="第37题，-Call-by-value和call-by-reference有什么区别"><a href="#第37题，-Call-by-value和call-by-reference有什么区别" class="headerlink" title="第37题， Call by value和call by reference有什么区别?"></a>第37题， Call by value和call by reference有什么区别?</h3><p>call by value传的是值。Call by reference传的是地址。</p><h3 id="第38题，如何在c语言中定义一个字符串变量？"><a href="#第38题，如何在c语言中定义一个字符串变量？" class="headerlink" title="第38题，如何在c语言中定义一个字符串变量？"></a>第38题，如何在c语言中定义一个字符串变量？</h3><p>使用char定义一个字符数组。</p><h3 id="第39题-在函数定义的时候何时用void"><a href="#第39题-在函数定义的时候何时用void" class="headerlink" title="第39题, 在函数定义的时候何时用void?"></a>第39题, 在函数定义的时候何时用void?</h3><p>当函数没有返回值时，可以用void。</p><h3 id="第40题-什么是preprocessor-directives"><a href="#第40题-什么是preprocessor-directives" class="headerlink" title="第40题, 什么是preprocessor directives?"></a>第40题, 什么是preprocessor directives?</h3><p>Preprocessor directives一般放在程序的开头。主要是用来指定调用库文件的。还有一个用途是用来定义一些常值变量，宏定义等等。#开头。</p><h3 id="第41题，-这样赋值对不对？错在哪里"><a href="#第41题，-这样赋值对不对？错在哪里" class="headerlink" title="第41题， 这样赋值对不对？错在哪里?"></a>第41题， 这样赋值对不对？错在哪里?</h3><p>myName=”test”;</p><p>不对。</p><p>我们不能用等号给一个字符串赋值。需要使用strcpy。</p><h3 id="第42题，为什么c语言被认为是中级语言"><a href="#第42题，为什么c语言被认为是中级语言" class="headerlink" title="第42题，为什么c语言被认为是中级语言?"></a>第42题，为什么c语言被认为是中级语言?</h3><p>这是因为c语言既能像高级语言那样编写程序，又可以像低级语言如汇编那样直接操作硬件。</p><h3 id="第43题，-什么是链表"><a href="#第43题，-什么是链表" class="headerlink" title="第43题， 什么是链表?"></a>第43题， 什么是链表?</h3><p>链表是一系列的元素连接在一起形成的数据结构。在c语言中，链表是用指针来构建的。使用链表数据结构是使用内存操作比较的一种方式。</p><h3 id="第44题，什么是fifo？"><a href="#第44题，什么是fifo？" class="headerlink" title="第44题，什么是fifo？"></a>第44题，什么是fifo？</h3><p>First in first out. 队列是典型的first in first out，数据结构。</p><h3 id="第45题-什么是二叉树"><a href="#第45题-什么是二叉树" class="headerlink" title="第45题, 什么是二叉树?"></a>第45题, 什么是二叉树?</h3><p>二叉树是链表的延伸。它的每一个节点都有两个指针，一个指向左，一个指向右。</p><h3 id="第46题，-C语言中有些保留着是大写的对吗"><a href="#第46题，-C语言中有些保留着是大写的对吗" class="headerlink" title="第46题， C语言中有些保留着是大写的对吗?"></a>第46题， C语言中有些保留着是大写的对吗?</h3><p>不对，c语言中的所有保留字必须是小写，否则的话c的编译器会报错。</p><h3 id="第47题，什么是输出重定向？"><a href="#第47题，什么是输出重定向？" class="headerlink" title="第47题，什么是输出重定向？"></a>第47题，什么是输出重定向？</h3><p>输出重定向是指把程序的输出，除了输出在屏幕上以外的另外选择， 比如说，输出到一个文件里。</p><h3 id="第48题，-什么是全局变量，如何定义它们"><a href="#第48题，-什么是全局变量，如何定义它们" class="headerlink" title="第48题， 什么是全局变量，如何定义它们?"></a>第48题， 什么是全局变量，如何定义它们?</h3><p>全局变量是指在程序中任何地方都可以访问到的变量。它一般定义在preprocessor directives的后面。</p><h3 id="第49题-getch和getche-这两个函数的区别是什么？"><a href="#第49题-getch和getche-这两个函数的区别是什么？" class="headerlink" title="第49题, getch和getche, 这两个函数的区别是什么？"></a>第49题, getch和getche, 这两个函数的区别是什么？</h3><p>前者是把用户的输入分配给一个变量。</p><p>后者是把用户的输入打印到屏幕上，同时分配给一个变量。</p><h3 id="第50题，文本文件和二进制文件的区别是什么？"><a href="#第50题，文本文件和二进制文件的区别是什么？" class="headerlink" title="第50题，文本文件和二进制文件的区别是什么？"></a>第50题，文本文件和二进制文件的区别是什么？</h3><p>文本文件存放的是人类可以阅读的内容，它包含字母数字和其他的字符。</p><p>而二进制文件存放的是1和0，只有电脑才能够读懂。</p><h3 id="第51题，如何用随机访问的方法在一个数据文件中搜索数据"><a href="#第51题，如何用随机访问的方法在一个数据文件中搜索数据" class="headerlink" title="第51题，如何用随机访问的方法在一个数据文件中搜索数据?"></a>第51题，如何用随机访问的方法在一个数据文件中搜索数据?</h3><p>fseek</p><p>在文件打开以后提供三个参数给这个函数。一个是文件的指针，一个是要搜索的字节数，再一个是文件中的搜索起点。</p><h3 id="第52题-在c语言中有没有内置的排序函数"><a href="#第52题-在c语言中有没有内置的排序函数" class="headerlink" title="第52题, 在c语言中有没有内置的排序函数?"></a>第52题, 在c语言中有没有内置的排序函数?</h3><p>qsort</p><h3 id="第53题，heap的优点和缺点是什么？"><a href="#第53题，heap的优点和缺点是什么？" class="headerlink" title="第53题，heap的优点和缺点是什么？"></a>第53题，heap的优点和缺点是什么？</h3><p>在heap上存放数据，要比在stack上存放数据要慢。</p><p>但是使用heap的主要优势是灵活性。这是因为内存的访问, 分配以及删除可以按照任意顺序来执行。</p><p>通过好的算法和设计可以规避heap速度慢的问题。</p><h3 id="第54题，如何把字符串变成数字？"><a href="#第54题，如何把字符串变成数字？" class="headerlink" title="第54题，如何把字符串变成数字？"></a>第54题，如何把字符串变成数字？</h3><p>atoi</p><p>atof</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="学习" scheme="http://www.kangxh.xyz/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C语言" scheme="http://www.kangxh.xyz/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>蓝奏云链接打不开的解决办法</title>
    <link href="http://www.kangxh.xyz/2021/03/09/%E8%93%9D%E5%A5%8F%E4%BA%91%E9%93%BE%E6%8E%A5%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://www.kangxh.xyz/2021/03/09/%E8%93%9D%E5%A5%8F%E4%BA%91%E9%93%BE%E6%8E%A5%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2021-03-09T10:24:38.866Z</published>
    <updated>2021-03-09T10:24:40.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>蓝奏云链接打不开的解决办法：</p><ol><li><p>将www改成pan或删掉www</p></li><li><p>将lanzous或lanzoux中的s或x改成i或删掉</p></li><li><p>修改DNS为114.114.114.114 或 114.114.115.115或223.5.5.5或8.8.8.8或4.4.4.4</p></li><li><p>修改hosts文件：记事本打开C:\Windows\System32\drivers\etc\hosts（此为windows，其他系统也有，路径自查）添加（IP、域名之间是Tab）：</p></li><li><p>hosts不能编辑修改用户权限即可</p><p>118.31.212.253     <a href="http://www.lanzous.com/" target="_blank" rel="noopener">www.lanzous.com</a><br>118.31.212.253     lanzous.com<br>118.31.212.253     *.lanzous.com</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python安装详解</title>
    <link href="http://www.kangxh.xyz/2021/02/26/Python%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3%20%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E%E5%8F%8A%E4%BF%AE%E6%94%B9pip%E9%BB%98%E8%AE%A4%E5%8C%85%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE/"/>
    <id>http://www.kangxh.xyz/2021/02/26/Python%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3%20%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E%E5%8F%8A%E4%BF%AE%E6%94%B9pip%E9%BB%98%E8%AE%A4%E5%8C%85%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-02-26T12:39:43.000Z</published>
    <updated>2021-03-09T12:51:22.761Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>  首先需要说明的是，Python 是开源跨平台的，不同系统下的安装区别较大。Python最新源码、安装包，新闻资讯等可以在Python的官网 <a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a> 查看到。你还可以在以上链接中下载 Python 的文档， HTML、PDF 和 PostScript 等格式的文档等等各种资料。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/201812131623025.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br>从上面下载下来的默认为32位的，如果要下载64位的，这需要如下图进行查找<br><img src="https://img-blog.csdnimg.cn/20181213162312639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br>点击对应版本后，会出现对应版本的详细介绍页面，将滚动条拉倒最后，就会发现针对各平台的下载文件<br><img src="https://img-blog.csdnimg.cn/20181213162324123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br>这样就得到了 Python 的安装包了！</p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>下面重点介绍 Windows 下的安装。其他平台后续有用到在完善。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接双击安装包，就会出现以下界面<br><img src="https://img-blog.csdnimg.cn/20181213162336828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br>其中，最好选择上 <code>Add Python xxx to PATH</code>，否则后续还得自己将 Python 添加到 Windows 的环境变量中。还有个默认选择的 <code>Install launcher for all users(recommended)</code>，这个也是有用的，尤其是在安装了不同版本的 Python 时。这个东西后面在详细说明。然后，直接点击<code>Customise installation</code>，出现如下界面<br><img src="https://img-blog.csdnimg.cn/201812131623481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br>上面的界面中，默认所有内容都是被选择的。至于每个是啥意思，后面在详细介绍。这里默认全选即可，然后点击<code>Next</code>，出现如下界面<br><img src="https://img-blog.csdnimg.cn/20181213162355678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br>其中的， <code>install for all user</code> 最好选择，选择后 <code>Precompile standard library</code> 将自动被选择，之后点击 <code>Install</code>，等待安装完成就好了！安装完成后，效果图如下<br><img src="https://img-blog.csdnimg.cn/20181213162408651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt="success"><br>如果在开始安装时，没有选择将 Python 添加到环境变量，则按住后需要自己手动添加上图所示的环境变量！</p><blockquote><p>注意如果是第一次安装，安装完成后会有个提示 <code>Removing the MAX_PATH Limitation</code>。我们选择<code>Enable</code>即可。最新的 3.9.0 如下所示（貌似与之前版本的描述不一致了，之前是 Enable 现在是 Disable）：<br><img src="https://img-blog.csdnimg.cn/20201008070618963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70#pic_center" alt><br>主要原因是 Windows historically has limited path lengths to 260 characters. This meant that paths longer than this would not resolve and errors would result.<br>也可以手动修改注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem@LongPathsEnabled to 1.</code></p></blockquote><h1 id="安装目录介绍"><a href="#安装目录介绍" class="headerlink" title="安装目录介绍"></a>安装目录介绍</h1><p>在执行完以上步骤之后，就会在自己指定的目录下生成各种安装后的文件，目录结构如下：<br><img src="https://img-blog.csdnimg.cn/20181214080209657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt="Dir"><br>下面简单介绍一下个目录/文件的具体用途：</p><ul><li><strong>DLLs：</strong> Python 自己使用的动态库</li><li><strong>Doc：</strong> 自带的 Python 使用说明文档（如果上面安装时不选择，应该会没有，这个没具体试过）</li><li><strong>include：</strong> 包含共享目录</li><li><strong>Lib：</strong> 库文件，放自定义模块和包</li><li><strong>libs：</strong> 编译生成的Python 自己使用的静态库</li><li><strong>Scripts：</strong> 各种包/模块对应的可执行程序。安装时如果选择了pip。那么pip的可执行程序就在此！</li><li><strong>tcl：</strong> 桌面编程包</li></ul><h1 id="修改-PIP-默认安装位置"><a href="#修改-PIP-默认安装位置" class="headerlink" title="修改 PIP 默认安装位置"></a>修改 PIP 默认安装位置</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>上面在安装时，选择了安装pip（<strong><em>注意：从3.4版本之后，pip才开始为默认组件，之前的版本是没有的</em></strong> ）。后面我们就可以使用pip安装各种自己使用的包了。但是，如果不进行配置，默认安装位置如下所示：<br><img src="https://img-blog.csdnimg.cn/20181214083018571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br>默认安装位置是<code>C:\Users\ZCShou\AppData\Roaming\Python\Python37\Scripts</code>。<strong><em>个人更倾向于不把这些东西放到系统盘，而是放到 Python 自己的安装目录的对应的子目录中！</em></strong></p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>首先，使用如下命令<code>python -m site</code> 查看<br><img src="https://img-blog.csdnimg.cn/20181214083722400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br><strong><em>这里的<code>USER_BASE</code>和<code>USER_SITE</code>其实就是默认的启用Python通过pip自动下载的脚本和依赖安装包的基础路径。</em></strong> 接着使用命令<code>python -m site -help</code>，便会看到如下：<br><img src="https://img-blog.csdnimg.cn/20181214084202385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br>以上说明了，路径的配置是在我们安装目录下的<code>lib\site.py</code>这文件中进行配置的！那么接下来修改这个文件就可以了！<br><img src="https://img-blog.csdnimg.cn/20181214084814547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt><br>这里的<code>USER_BASE</code> 需要特殊注意：<strong><em>其会自动在指定的路径后面添加<code>/Python37/Scripts</code>（和自己的安装路径有关），有强迫症的自己注意！</em></strong> 然后再次使用命令查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ZCShou&gt;python -m site</span><br><span class="line">sys.path = [</span><br><span class="line">    'C:\\Users\\ZCShou',</span><br><span class="line">    'D:\\Program Files\\Python37\\python37.zip',</span><br><span class="line">    'D:\\Program Files\\Python37\\DLLs',</span><br><span class="line">    'D:\\Program Files\\Python37\\lib',</span><br><span class="line">    'D:\\Program Files\\Python37',</span><br><span class="line">    'D:\\Program Files\\Python37\\Lib\\site-packages',</span><br><span class="line">]</span><br><span class="line">USER_BASE: 'D:\\Program Files' (exists)</span><br><span class="line">USER_SITE: 'D:\\Program Files\\Python37\\Lib\\site-packages' (exists)</span><br><span class="line">ENABLE_USER_SITE: True</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>此后重新安装自己使用的包就可以了。这样新安装的包的可执行文件就会位于 Python 目录下的 <code>Scripts</code> 目下，包即会被放到 Python 目录下<code>lib\site-packages</code>目录下了！<br><img src="https://img-blog.csdnimg.cn/20181214090650517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt></p><h1 id="pip-升级"><a href="#pip-升级" class="headerlink" title="pip 升级"></a>pip 升级</h1><p>有上面的图片可知，默认安装Python 3.7.1 版本后，其自带的pip版本过低，总是提示升级！升级命令提示中已经给出，直接执行即可！<br><img src="https://img-blog.csdnimg.cn/20181214092020389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4=,size_16,color_FFFFFF,t_70" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h1&gt;&lt;p&gt;  首先需要说明的是，Python 是开源跨平台的，不同系统下的安装区别较大。Python最新源码、安装包，新闻资讯等可以在Python的官网 &lt;a href=&quot;https://www.python.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.python.org/&lt;/a&gt; 查看到。你还可以在以上链接中下载 Python 的文档， HTML、PDF 和 PostScript 等格式的文档等等各种资料。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://www.kangxh.xyz/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="http://www.kangxh.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>安装VMware Tools</title>
    <link href="http://www.kangxh.xyz/2021/02/22/%E8%99%9A%E6%8B%9F%E6%9C%BAWin7%E6%97%A0%E6%B3%95%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85VMware%20Tools/"/>
    <id>http://www.kangxh.xyz/2021/02/22/%E8%99%9A%E6%8B%9F%E6%9C%BAWin7%E6%97%A0%E6%B3%95%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85VMware%20Tools/</id>
    <published>2021-02-22T07:06:55.000Z</published>
    <updated>2021-02-22T09:18:11.677Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Windows7无法成功安装VMware-Tools-且需要更新操作系统到SP1"><a href="#Windows7无法成功安装VMware-Tools-且需要更新操作系统到SP1" class="headerlink" title="Windows7无法成功安装VMware Tools,且需要更新操作系统到SP1."></a>Windows7无法成功安装VMware Tools,且需要更新操作系统到SP1.</h2><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/img/image-20210222140939363.png" alt></p><h2 id="问题不是出在操作系统没有更新上，而是出在Win7镜像上："><a href="#问题不是出在操作系统没有更新上，而是出在Win7镜像上：" class="headerlink" title="问题不是出在操作系统没有更新上，而是出在Win7镜像上："></a>问题不是出在操作系统没有更新上，而是出在Win7镜像上：</h2><p>需要使用sp1的<img src="https://gitee.com/LYmystery/PicGo/raw/master/img/image-20210222141100453.png" alt="image-20210222141100453"></p><h2 id="镜像重新下载地址："><a href="#镜像重新下载地址：" class="headerlink" title="镜像重新下载地址："></a>镜像重新下载地址：</h2><p>ed2k://|file|cn_windows_7_enterprise_with_sp1_x64_dvd_u_677685.iso|3265574912|E9DB2607EA3B3540F3FE2E388F8C53C4|/</p><p>注：以上方法只适用于sp1镜像安装好补丁</p><p>方法二：</p><p>下载 vm tools iso 文件</p><p><a href="https://lanzous.com/ibfd9oh" target="_blank" rel="noopener">https://lanzous.com/ibfd9oh</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="虚拟机" scheme="http://www.kangxh.xyz/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>idea快捷键</title>
    <link href="http://www.kangxh.xyz/2021/02/19/IDEA(2018%E7%89%88)%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <id>http://www.kangxh.xyz/2021/02/19/IDEA(2018%E7%89%88)%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</id>
    <published>2021-02-19T12:39:43.000Z</published>
    <updated>2021-02-22T09:20:25.679Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Ctrl</strong></p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + F</td><td>在当前文件进行文本查找 （必备）</td></tr><tr><td>Ctrl + R</td><td>在当前文件进行文本替换 （必备）</td></tr><tr><td>Ctrl + Z</td><td>撤销 （必备）</td></tr><tr><td>Ctrl + Y</td><td>删除光标所在行 或 删除选中的行 （必备）</td></tr><tr><td>Ctrl + X</td><td>剪切光标所在行 或 剪切选择内容</td></tr><tr><td>Ctrl + C</td><td>复制光标所在行 或 复制选择内容</td></tr><tr><td>Ctrl + D</td><td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</td></tr><tr><td>Ctrl + W</td><td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</td></tr><tr><td>Ctrl + E</td><td>显示最近打开的文件记录列表</td></tr><tr><td>Ctrl + N</td><td>根据输入的 <strong>类名</strong> 查找类文件</td></tr><tr><td>Ctrl + G</td><td>在当前文件跳转到指定行处</td></tr><tr><td>Ctrl + J</td><td>插入自定义动态代码模板</td></tr><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Ctrl + Q</td><td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td>Ctrl + U</td><td>前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td>Ctrl + B</td><td>进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击</td></tr><tr><td>Ctrl + K</td><td>版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + T</td><td>版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + H</td><td>显示当前类的层次结构</td></tr><tr><td>Ctrl + O</td><td>选择可重写的方法</td></tr><tr><td>Ctrl + I</td><td>选择可继承的方法</td></tr><tr><td>Ctrl + +</td><td>展开代码</td></tr><tr><td>Ctrl + -</td><td>折叠代码</td></tr><tr><td>Ctrl + /</td><td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</td></tr><tr><td>Ctrl + [</td><td>移动光标到当前所在代码的花括号开始位置</td></tr><tr><td>Ctrl + ]</td><td>移动光标到当前所在代码的花括号结束位置</td></tr><tr><td>Ctrl + F1</td><td>在光标所在的错误代码出显示错误信息</td></tr><tr><td>Ctrl + F3</td><td>调转到所选中的词的下一个引用位置</td></tr><tr><td>Ctrl + F4</td><td>关闭当前编辑文件</td></tr><tr><td>Ctrl + F8</td><td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td>Ctrl + F9</td><td>执行 Make Project 操作</td></tr><tr><td>Ctrl + F11</td><td>选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td>Ctrl + F12</td><td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td>Ctrl + Tab</td><td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td>Ctrl + Enter</td><td>智能分隔行</td></tr><tr><td>Ctrl + End</td><td>跳到文件尾</td></tr><tr><td>Ctrl + Home</td><td>跳到文件头</td></tr><tr><td>Ctrl + Space</td><td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</td></tr><tr><td>Ctrl + Delete</td><td>删除光标后面的单词或是中文句</td></tr><tr><td>Ctrl + BackSpace</td><td>删除光标前面的单词或是中文句</td></tr><tr><td>Ctrl + 1,2,3…9</td><td>定位到对应数值的书签位置</td></tr><tr><td>Ctrl + 左键单击</td><td>在打开的文件标题上，弹出该文件路径</td></tr><tr><td>Ctrl + 光标定位</td><td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td>Ctrl + 左方向键</td><td>光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td>Ctrl + 右方向键</td><td>光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td>Ctrl + 前方向键</td><td>等效于鼠标滚轮向前效果</td></tr><tr><td>Ctrl + 后方向键</td><td>等效于鼠标滚轮向后效果</td></tr></tbody></table><p><strong>Alt</strong></p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Alt + `</td><td>显示版本控制常用操作菜单弹出层</td></tr><tr><td>Alt + Q</td><td>弹出一个提示，显示当前类的声明 / 上下文信息</td></tr><tr><td>Alt + F1</td><td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td>Alt + F2</td><td>对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td>Alt + F3</td><td>选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td>Alt + F7</td><td>查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td>Alt + F8</td><td>在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td>Alt + Home</td><td>定位 / 显示到当前文件的 Navigation Bar</td></tr><tr><td>Alt + Enter</td><td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</td></tr><tr><td>Alt + Insert</td><td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td>Alt + 左方向键</td><td>按左方向切换当前已打开的文件视图</td></tr><tr><td>Alt + 右方向键</td><td>按右方向切换当前已打开的文件视图</td></tr><tr><td>Alt + 前方向键</td><td>当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td>Alt + 后方向键</td><td>当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td>Alt + 1,2,3…9</td><td>显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr></tbody></table><p><strong>Shift</strong></p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Shift + F1</td><td>如果有外部文档可以连接外部文档</td></tr><tr><td>Shift + F2</td><td>跳转到上一个高亮错误 或 警告位置</td></tr><tr><td>Shift + F3</td><td>在查找模式下，查找匹配上一个</td></tr><tr><td>Shift + F4</td><td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td>Shift + F6</td><td>对文件 / 文件夹 重命名</td></tr><tr><td>Shift + F7</td><td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td>Shift + F8</td><td>在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td></tr><tr><td>Shift + F9</td><td>等效于点击工具栏的 Debug 按钮</td></tr><tr><td>Shift + F10</td><td>等效于点击工具栏的 Run 按钮</td></tr><tr><td>Shift + F11</td><td>弹出书签显示层</td></tr><tr><td>Shift + Tab</td><td>取消缩进</td></tr><tr><td>Shift + ESC</td><td>隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td>Shift + End</td><td>选中光标到当前行尾位置</td></tr><tr><td>Shift + Home</td><td>选中光标到当前行头位置</td></tr><tr><td>Shift + Enter</td><td>开始新一行。光标所在行下空出一行，光标定位到新行位置</td></tr><tr><td>Shift + 左键单击</td><td>在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr><tr><td>Shift + 滚轮前后滚动</td><td>当前文件的横向滚动轴滚动</td></tr></tbody></table><p><strong>Ctrl + Alt</strong></p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + Alt + L</td><td>格式化代码，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td>Ctrl + Alt + O</td><td>优化导入的类，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td>Ctrl + Alt + I</td><td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td>Ctrl + Alt + T</td><td>对选中的代码弹出环绕选项弹出层</td></tr><tr><td>Ctrl + Alt + J</td><td>弹出模板选择窗口，讲选定的代码加入动态模板中</td></tr><tr><td>Ctrl + Alt + H</td><td>调用层次</td></tr><tr><td>Ctrl + Alt + B</td><td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td>Ctrl + Alt + V</td><td>快速引进变量</td></tr><tr><td>Ctrl + Alt + Y</td><td>同步、刷新</td></tr><tr><td>Ctrl + Alt + S</td><td>打开 IntelliJ IDEA 系统设置</td></tr><tr><td>Ctrl + Alt + F7</td><td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td>Ctrl + Alt + F11</td><td>切换全屏模式</td></tr><tr><td>Ctrl + Alt + Enter</td><td>光标所在行上空出一行，光标定位到新行</td></tr><tr><td>Ctrl + Alt + Home</td><td>弹出跟当前文件有关联的文件弹出层</td></tr><tr><td>Ctrl + Alt + Space</td><td>类名自动完成</td></tr><tr><td>Ctrl + Alt + 左方向键</td><td>退回到上一个操作的地方 （必备）</td></tr><tr><td>Ctrl + Alt + 右方向键</td><td>前进到上一个操作的地方 （必备）</td></tr><tr><td>Ctrl + Alt + 前方向键</td><td>在查找模式下，跳到上个查找的文件</td></tr><tr><td>Ctrl + Alt + 后方向键</td><td>在查找模式下，跳到下个查找的文件</td></tr></tbody></table><p><strong>Ctrl + Shift</strong></p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + Shift + F</td><td>根据输入内容查找整个项目 或 指定目录内文件 （必备）</td></tr><tr><td>Ctrl + Shift + R</td><td>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</td></tr><tr><td>Ctrl + Shift + J</td><td>自动将下一行合并到当前行末尾 （必备）</td></tr><tr><td>Ctrl + Shift + Z</td><td>取消撤销 （必备）</td></tr><tr><td>Ctrl + Shift + W</td><td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</td></tr><tr><td>Ctrl + Shift + N</td><td>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</td></tr><tr><td>Ctrl + Shift + U</td><td>对选中的代码进行大 / 小写轮流转换 （必备）</td></tr><tr><td>Ctrl + Shift + T</td><td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td>Ctrl + Shift + C</td><td>复制当前文件磁盘路径到剪贴板</td></tr><tr><td>Ctrl + Shift + V</td><td>弹出缓存的最近拷贝的内容管理器弹出层</td></tr><tr><td>Ctrl + Shift + E</td><td>显示最近修改的文件列表的弹出层</td></tr><tr><td>Ctrl + Shift + H</td><td>显示方法层次结构</td></tr><tr><td>Ctrl + Shift + B</td><td>跳转到类型声明处</td></tr><tr><td>Ctrl + Shift + I</td><td>快速查看光标所在的方法 或 类的定义</td></tr><tr><td>Ctrl + Shift + A</td><td>查找动作 / 设置</td></tr><tr><td>Ctrl + Shift + /</td><td>代码块注释 （必备）</td></tr><tr><td>Ctrl + Shift + [</td><td>选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td>Ctrl + Shift + ]</td><td>选中从光标所在位置到它的底部中括号位置</td></tr><tr><td>Ctrl + Shift + +</td><td>展开所有代码</td></tr><tr><td>Ctrl + Shift + -</td><td>折叠所有代码</td></tr><tr><td>Ctrl + Shift + F7</td><td>高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td>Ctrl + Shift + F8</td><td>在 Debug 模式下，指定断点进入条件</td></tr><tr><td>Ctrl + Shift + F9</td><td>编译选中的文件 / 包 / Module</td></tr><tr><td>Ctrl + Shift + F12</td><td>编辑器最大化</td></tr><tr><td>Ctrl + Shift + Space</td><td>智能代码提示</td></tr><tr><td>Ctrl + Shift + Enter</td><td>自动结束代码，行末自动添加分号 （必备）</td></tr><tr><td>Ctrl + Shift + Backspace</td><td>退回到上次修改的地方</td></tr><tr><td>Ctrl + Shift + 1,2,3…9</td><td>快速添加指定数值的书签</td></tr><tr><td>Ctrl + Shift + 左方向键</td><td>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td>Ctrl + Shift + 右方向键</td><td>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td>Ctrl + Shift + 左方向键</td><td>在光标焦点是在工具选项卡上，缩小选项卡区域</td></tr><tr><td>Ctrl + Shift + 右方向键</td><td>在光标焦点是在工具选项卡上，扩大选项卡区域</td></tr><tr><td>Ctrl + Shift + 前方向键</td><td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td>Ctrl + Shift + 后方向键</td><td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><p><strong>Alt + Shift</strong></p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Alt + Shift + N</td><td>选择 / 添加 task</td></tr><tr><td>Alt + Shift + F</td><td>显示添加到收藏夹弹出层</td></tr><tr><td>Alt + Shift + C</td><td>查看最近操作项目的变化情况列表</td></tr><tr><td>Alt + Shift + F</td><td>添加到收藏夹</td></tr><tr><td>Alt + Shift + I</td><td>查看项目当前文件</td></tr><tr><td>Alt + Shift + F7</td><td>在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td>Alt + Shift + F9</td><td>弹出 Debug 的可选择菜单</td></tr><tr><td>Alt + Shift + F10</td><td>弹出 Run 的可选择菜单</td></tr><tr><td>Alt + Shift + 左键双击</td><td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td></tr><tr><td>Alt + Shift + 前方向键</td><td>移动光标所在行向上移动</td></tr><tr><td>Alt + Shift + 后方向键</td><td>移动光标所在行向下移动</td></tr></tbody></table><p><strong>Ctrl + Shift + Alt</strong></p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + Shift + Alt + V</td><td>无格式黏贴</td></tr><tr><td>Ctrl + Shift + Alt + N</td><td>前往指定的变量 / 方法</td></tr><tr><td>Ctrl + Shift + Alt + S</td><td>打开当前项目设置</td></tr><tr><td>Ctrl + Shift + Alt + C</td><td>复制参考信息</td></tr></tbody></table><p><strong>其他</strong></p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置 （必备）</td></tr><tr><td>F3</td><td>在查找模式下，定位到下一个匹配处</td></tr><tr><td>F4</td><td>编辑源</td></tr><tr><td>F7</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td>F8</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td>F9</td><td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td>F11</td><td>添加书签</td></tr><tr><td>F12</td><td>回到前一个工具窗口</td></tr><tr><td>Tab</td><td>缩进</td></tr><tr><td>ESC</td><td>从工具窗口进入代码文件窗口</td></tr><tr><td>连按两次Shift</td><td>弹出 Search Everywhere 弹出层</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="idea" scheme="http://www.kangxh.xyz/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>安装jdk7.x和8.x</title>
    <link href="http://www.kangxh.xyz/2021/02/16/Win10%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85jdk1.7%E5%92%8Cjdk1.8/"/>
    <id>http://www.kangxh.xyz/2021/02/16/Win10%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85jdk1.7%E5%92%8Cjdk1.8/</id>
    <published>2021-02-16T12:39:43.000Z</published>
    <updated>2021-02-19T04:45:46.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>安装：</p><p>安装过程是傻瓜式安装，安装的路径根据自己的习惯进行选择。</p><a id="more"></a><p>配置环境变量：</p><p>这里我们使用三个变量<img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210216115352.png" alt="image-20210216115344811"></p><p> 添加CLASSPATH，内容是：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</p><p>切换：</p><p>现在是%JAVA8_HOME%：<img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210216115415.png" alt="image-20210216115414101"></p><p>如果需要切换只需要更改JAVA_HOME中的变量8改为7就行了。<img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210216115438.png" alt="image-20210216115436652"></p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210216115504.png" alt="image-20210216115503059"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装：&lt;/p&gt;
&lt;p&gt;安装过程是傻瓜式安装，安装的路径根据自己的习惯进行选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="win10" scheme="http://www.kangxh.xyz/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>win10配置tomcat8.x和7.x</title>
    <link href="http://www.kangxh.xyz/2021/02/15/win10%E4%B8%8B%E9%85%8D%E7%BD%AEtomcat8.x%E5%92%8C7.x/"/>
    <id>http://www.kangxh.xyz/2021/02/15/win10%E4%B8%8B%E9%85%8D%E7%BD%AEtomcat8.x%E5%92%8C7.x/</id>
    <published>2021-02-15T13:30:37.000Z</published>
    <updated>2021-02-19T04:50:11.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="配置tomcat8-x和7-x"><a href="#配置tomcat8-x和7-x" class="headerlink" title="配置tomcat8.x和7.x"></a>配置tomcat8.x和7.x</h3><h4 id="配置tomcat7-x"><a href="#配置tomcat7-x" class="headerlink" title="配置tomcat7.x"></a>配置tomcat7.x</h4><ol><li><p>下载并解压apache-tomcat-7.x和apache-tomcat-8.x到文件目录D:\Program Files\Tomcat</p></li><li><p>配置环境变量<a id="more"></a></p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210215135030.png" alt="image-20210215135022746"></p></li><li><p>进入D:\Program Files\Tomcat\apache-tomcat-7.0.68\conf目录，修改server.xml</p><ol><li><Server port="8006" shutdown="SHUTDOWN">修改这个port=”8006”，原来默认的为：8005，使得它的关闭端口和另一个关闭端口不发生冲突。</Server></li><li>&lt;Connector port=”8081” maxHttpHeaderSize=”8192”<pre><code>maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;connectionTimeout=&quot;20000&quot; disableUploadTimeout=&quot;true&quot; /&gt;修改port=”8081”，原来默认的为“8080”，使得它的连接端口和另一个不冲突。</code></pre></li><li><Connector port="8009" protocol="AJP/1.3" redirectport="8443">修改这个port=”8010”，原来默认的为：8009，AJP 1.3 Connector定义的地方。</Connector></li></ol></li><li><p>进入D:\Program Files\Tomcat\apache-tomcat-7.0.68\bin修改startup.bat和catalina.bat文件内容，把两个文件所有CATALINA_HOME替换为CATALINA_HOME7。（快捷键Ctrl+H）</p></li><li><p>启动Tomcat，双击startup.bat，浏览器输入<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a> </p></li></ol><h4 id="配置tomcat8-x"><a href="#配置tomcat8-x" class="headerlink" title="配置tomcat8.x"></a>配置tomcat8.x</h4><ol><li>由于以tomcat8.x为基准，所以不修改server.xml文件，默认即可</li><li>直接修改startup.bat和catalina.bat文件内容，把两个文件所有CATALINA_HOME替换为CATALINA_HOME8。</li><li>启动Tomcat，双击startup.bat，浏览器输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li></ol><h4 id="后续（tomcat日志乱码问题）"><a href="#后续（tomcat日志乱码问题）" class="headerlink" title="后续（tomcat日志乱码问题）"></a>后续（tomcat日志乱码问题）</h4><p>问题原因：</p><p>在使用bat文件启动Tomcat时，Tomcat目录下的logs文件夹会生成相应的日志文件，发现旧版本生成的日志文件编码是GBK，而Windows控制台的编码也是GBK，所以不会乱码。而新版本生成的日志文件编码是UTF-8，所以就造成了中文乱码问题</p><p>解决：</p><p>进入 /conf/logging.properties，这个文件就是tomcat的日志配置文件，通过使用BCompare对新老版本的配置文件进行对比，发现tomcat在新版的日志配置文件中加了指定编码为UTF-8的配置。这就是乱码的根源了。（1）将配置UTF-8那一行配置删除（这样应该就是采用操作系统默认编码，Windows下即为GBK）（2）将UTF-8改为GBK</p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210215141039.png" alt="image-20210215141038172"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置tomcat8-x和7-x&quot;&gt;&lt;a href=&quot;#配置tomcat8-x和7-x&quot; class=&quot;headerlink&quot; title=&quot;配置tomcat8.x和7.x&quot;&gt;&lt;/a&gt;配置tomcat8.x和7.x&lt;/h3&gt;&lt;h4 id=&quot;配置tomcat7-x&quot;&gt;&lt;a href=&quot;#配置tomcat7-x&quot; class=&quot;headerlink&quot; title=&quot;配置tomcat7.x&quot;&gt;&lt;/a&gt;配置tomcat7.x&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载并解压apache-tomcat-7.x和apache-tomcat-8.x到文件目录D:\Program Files\Tomcat&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置环境变量&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="win10" scheme="http://www.kangxh.xyz/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>VSCode过滤文件配置</title>
    <link href="http://www.kangxh.xyz/2021/02/15/vscode%E8%BF%87%E6%BB%A4exe%E7%AD%89%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E7%AE%80%E4%BE%BF%E6%96%B9%E6%B3%95/"/>
    <id>http://www.kangxh.xyz/2021/02/15/vscode%E8%BF%87%E6%BB%A4exe%E7%AD%89%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E7%AE%80%E4%BE%BF%E6%96%B9%E6%B3%95/</id>
    <published>2021-02-15T12:39:43.000Z</published>
    <updated>2021-02-19T04:45:01.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>打开vscode，添加文件后，文件列表会出现大量与代码无关的文件，看着很不爽，这时只需要在设置一下即可</p><p>打开设置文件夹settings.json</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20190823185213415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI3NTk1,size_16,color_FFFFFF,t_70" alt="img"></p><p>过滤文件夹方法：          <strong>“\</strong>/文件夹名”: true,**<br>如：.git是文件夹名</p><p>过滤以固定后缀结尾的文件： <strong>“\</strong>/*.后缀名”: true,**<br>如：exe是后缀名</p><p><strong>在设置里加入这段代码(可根据个人需要更改)即可</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"files.exclude": &#123;</span><br><span class="line">  "**/.git": true,</span><br><span class="line">  "**/.svn": true,</span><br><span class="line">  "**/.hg": true,</span><br><span class="line">  "**/CVS": true,</span><br><span class="line">  "**/.DS_Store": true,</span><br><span class="line">  "**/.vscode": true,</span><br><span class="line">  "**/*.exe": true, </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>至此vscode文件列表就简洁了很多</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开vscode，添加文件后，文件列表会出现大量与代码无关的文件，看着很不爽，这时只需要在设置一下即可&lt;/p&gt;
&lt;p&gt;打开设置文件夹settings.json&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="vscode" scheme="http://www.kangxh.xyz/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>Python学习准备：Anaconda和Pycharm的安装及环境创建</title>
    <link href="http://www.kangxh.xyz/2021/02/14/Python%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87%EF%BC%9AAnaconda%E5%92%8CPycharm%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA/"/>
    <id>http://www.kangxh.xyz/2021/02/14/Python%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87%EF%BC%9AAnaconda%E5%92%8CPycharm%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA/</id>
    <published>2021-02-14T12:39:43.000Z</published>
    <updated>2021-02-19T04:46:52.162Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python学习准备：Anaconda和Pycharm的安装及环境创建"><a href="#Python学习准备：Anaconda和Pycharm的安装及环境创建" class="headerlink" title="Python学习准备：Anaconda和Pycharm的安装及环境创建"></a>Python学习准备：Anaconda和Pycharm的安装及环境创建</h1><h2 id="一、Anaconda"><a href="#一、Anaconda" class="headerlink" title="一、Anaconda"></a>一、Anaconda</h2><h4 id="1-Anaconda是什么？"><a href="#1-Anaconda是什么？" class="headerlink" title="1. Anaconda是什么？"></a>1. <strong>Anaconda是什么？</strong></h4><p>   <a href="https://www.continuum.io/why-anaconda" target="_blank" rel="noopener">Anaconda</a>是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令<code>conda</code>来进行package和environment的管理，并且已经包含了Python和相关的配套工具。 </p><p><strong>conda</strong> 是开源包（packages）和虚拟环境（environment）的管理系统。</p><a id="more"></a><h4 id="2-Anaconda的安装"><a href="#2-Anaconda的安装" class="headerlink" title="2. Anaconda的安装"></a>2. <strong>Anaconda的安装</strong></h4><p>​    首先，下载安装包。Anaconda的下载方式有两种：</p><p>   通过官网下载，选择适合自己的电脑版本的安装包。<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">https://www.anaconda.com/download/</a></p><p>   在官网中下载比较缓慢，可以通过清华大学开源软件镜像站下载。</p><p>   <a href="https://link.jianshu.com/?t=https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p><p>   双击Anaconda的安装包，按照如下步骤安装：</p><p>   <img src="https://img-blog.csdn.net/2018061417045842?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>  <img src="https://img-blog.csdn.net/20180614170513219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>  因为是自己的笔记本，我选择的是对于全部用户都行，这个看自己的需要。</p><p>  <img src="https://img-blog.csdn.net/20180614170522907?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>我在安装过程中，因为懒得专门配环境变量，就直接勾选了添加环境变量</p><p>  <img src="https://img-blog.csdn.net/20180614170652122?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>  <img src="https://img-blog.csdn.net/20180614170848414?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p> <img src="https://img-blog.csdn.net/20180614170911749?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p> <img src="https://img-blog.csdn.net/20180614170928141?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p> 安装成功。如果是windows用户，可以打开命令窗口，输入’python’，看看是否成功安装</p><p><img src="https://img-blog.csdn.net/20180614171035541?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>打开Anaconda文件</p><p><img src="https://img-blog.csdn.net/20180614171133524?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>Anaconda Cloud</strong> 是管理公共或者私有python notebook、conda、环境和packages的地方，可以方便分享和追踪。</p><p><strong>Anaconda Navigator</strong> 是Anaconda可视化的管理界面。</p><p><strong>Anaconda Prompt</strong> 是一个Anaconda的终端，可以便捷的操作conda环境。</p><p><strong>Jupyter Notebook</strong> 这得从IPython 3.x版本开始说起，这是最后的大一统版本，包括notebook、qtconsole等等，从IPython4.0版本开始IPython只集中精力做交互式shell，变得轻量化，而剩下的notebook格式，qtconsole，和notebookweb应用等都分离出来统一命名为Jupyter。至此IPython和Jupyter分家。</p><p><strong>JupyterQtconsole</strong> 调用交互式命令台。从IPython4.0版本开始，很多IPython子命令现在变成了Jupyter子命令，如ipython notebook现在是jupyter noteboook。</p><p><strong>ipython</strong>是一个python的交互式shell，比默认的pythonshell好用得多，支持变量自动补全，自动缩进，支持bash shell命令，内置了许多很有用的功能和函数。学习ipython将会让我们以一种更高的效率来使用python。同时它也是利用Python进行科学计算和交互可视化的一个最佳的平台。</p><p><strong>Spyder</strong> 是一个使用Python语言的开放源代码跨平台科学运算IDE，是一种简单的集成开发环境。Spyder可以跨平台，也可以使用附加组件扩充，自带交互式工具以处理数据。</p><h2 id="二、Pycharm"><a href="#二、Pycharm" class="headerlink" title="二、Pycharm"></a>二、Pycharm</h2><p> 配置完Anaconda之后，其实已经可以用已经安装好的ipython、spyder写代码了，但是个人感觉Pycharm很好用，基本上的代码都在Pycharm上敲的，所以也就把安装过程记录下来了。</p><p><strong>1.Pycharm的安装</strong></p><p>下载安装包，这个直接在官网上下载就好。<a href="http://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">http://www.jetbrains.com/pycharm/download/#section=windows</a></p><p>按照步骤走</p><p><img src="https://img-blog.csdn.net/20180614173146210?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>自己设置的路径</p><p><img src="https://img-blog.csdn.net/20180614173201435?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180614173238714?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180614173249632?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180614173302699?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>安装完成，使用时会结合第三部分环境搭建来讲</p><h2 id="三、使用conda建立运行环境"><a href="#三、使用conda建立运行环境" class="headerlink" title="三、使用conda建立运行环境"></a>三、使用conda建立运行环境</h2><p> 这里直接写搭建过程需要的代码.</p><h4 id="1-搭建一个名叫scikit-learn的环境"><a href="#1-搭建一个名叫scikit-learn的环境" class="headerlink" title="1.搭建一个名叫scikit-learn的环境"></a>1.搭建一个名叫scikit-learn的环境</h4><p>windows系统进入‘运行’界面，输入’cmd’，确定</p><p>（1）conda env list      #显示已经存在的环境</p><p><img src="https://img-blog.csdn.net/20180615165850987?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img">   </p><p>（2）conda create -n scikit-learn python  #创建环境</p><p>（3）y  回车</p><p>（4）activate scikit-learn          #进入环境</p><p>（5）conda list                 #查看环境中存在的包</p><p>（6）pip install ……              #安装包</p><p>（7）deactivate                 #退出环境</p><h4 id="2-将搭建好的scikit-learn环境配置到Pycharm中，开始编程"><a href="#2-将搭建好的scikit-learn环境配置到Pycharm中，开始编程" class="headerlink" title="2.将搭建好的scikit-learn环境配置到Pycharm中，开始编程"></a>2.将搭建好的scikit-learn环境配置到Pycharm中，开始编程</h4><p>（1）双击Pycharm，点击创建新项目</p><p>（2）选择创建项目的位置及项目名字，选择“Existing interpreter”</p><p><img src="https://img-blog.csdn.net/20180615171609500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>（3）按如下步骤选择路径，找到刚刚已经配置好的环境</p><p><img src="https://img-blog.csdn.net/20180615171634632?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180615171159254?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180615171244526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180615171340101?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180615171700928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>（4）创建成功</p><p><img src="https://img-blog.csdn.net/20180615171804203?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>（5）新建一个py文件，就可以愉快地写代码了。</p><p><img src="https://img-blog.csdn.net/20180615171906565?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180615172058853?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTQ5MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>写在后面的话：</p><p>   自己的第一篇博客算是写完了，很基础，希望能给刚入门的朋友们一点启示，少走一些弯路。想起自己刚接触python的时候，自己甚至都不知道在哪里敲代码，对于什么Ipython,spyder,pycharm更是一头雾水，在慢慢探索中，终于找到自己喜欢的编译器。在使用Pycharm中，一度也不知道怎么配置自己已经创建好的环境。故此，趁着这次机会把细节写出来，希望今后的自己也能不断学习，持续更新~~</p><p>   文中若有不当之处，欢迎大家批评指正~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python学习准备：Anaconda和Pycharm的安装及环境创建&quot;&gt;&lt;a href=&quot;#Python学习准备：Anaconda和Pycharm的安装及环境创建&quot; class=&quot;headerlink&quot; title=&quot;Python学习准备：Anaconda和Pycharm的安装及环境创建&quot;&gt;&lt;/a&gt;Python学习准备：Anaconda和Pycharm的安装及环境创建&lt;/h1&gt;&lt;h2 id=&quot;一、Anaconda&quot;&gt;&lt;a href=&quot;#一、Anaconda&quot; class=&quot;headerlink&quot; title=&quot;一、Anaconda&quot;&gt;&lt;/a&gt;一、Anaconda&lt;/h2&gt;&lt;h4 id=&quot;1-Anaconda是什么？&quot;&gt;&lt;a href=&quot;#1-Anaconda是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Anaconda是什么？&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;Anaconda是什么？&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;   &lt;a href=&quot;https://www.continuum.io/why-anaconda&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Anaconda&lt;/a&gt;是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令&lt;code&gt;conda&lt;/code&gt;来进行package和environment的管理，并且已经包含了Python和相关的配套工具。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conda&lt;/strong&gt; 是开源包（packages）和虚拟环境（environment）的管理系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://www.kangxh.xyz/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="http://www.kangxh.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>springMVC常用注解标签</title>
    <link href="http://www.kangxh.xyz/2021/02/14/springMVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>http://www.kangxh.xyz/2021/02/14/springMVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-02-14T12:39:43.000Z</published>
    <updated>2021-03-09T12:52:47.817Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="springmvc常用注解标签详解-https-www-cnblogs-com-leskang-p-5445698-html"><a href="#springmvc常用注解标签详解-https-www-cnblogs-com-leskang-p-5445698-html" class="headerlink" title="springmvc常用注解标签详解](https://www.cnblogs.com/leskang/p/5445698.html)"></a>springmvc常用注解标签详解](<a href="https://www.cnblogs.com/leskang/p/5445698.html" target="_blank" rel="noopener">https://www.cnblogs.com/leskang/p/5445698.html</a>)</h1><h2 id="1-Controller"><a href="#1-Controller" class="headerlink" title="1.@Controller"></a>1.@Controller</h2><p>在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p><p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p><p>　　（1）在SpringMVC 的配置文件中定义MyController 的bean 对象。</p><p>　　（2）在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.host.app.web.controller.MyController"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"com.host.app.web"</span> /&gt;</span>//路径写到controller的上一层(扫描包详解见下面浅析)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-RequestMapping"><a href="#2-RequestMapping" class="headerlink" title="2.@RequestMapping"></a>2.@RequestMapping</h2><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p><p><strong>1. value， method；</strong></p><p>value：   指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p><p>method： 指定请求的method类型， GET.POST.PUT.DELETE等；</p><p><strong>2.consumes，produces</strong></p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p>produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p><strong>3.params，headers</strong></p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><h2 id="3-Resource和-Autowired"><a href="#3-Resource和-Autowired" class="headerlink" title="3.@Resource和@Autowired"></a>3.@Resource和@Autowired</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><p><strong>1.共同点</strong></p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p><strong>2.不同点</strong></p><p>（1）@Autowired</p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面两种@Autowired只要使用一种即可</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123; <span class="comment">// 用于属性的方法上</span></span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）@Resource</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面两种@Resource只要使用一种即可</span></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123; <span class="comment">// 用于属性的setter方法上</span></span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set.get去操作属性，而不是直接去操作属性。</p><p>@Resource装配顺序：</p><p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p><p>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p><p>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p><p>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p><h2 id="4-ModelAttribute和-SessionAttributes"><a href="#4-ModelAttribute和-SessionAttributes" class="headerlink" title="4.@ModelAttribute和 @SessionAttributes"></a>4.@ModelAttribute和 @SessionAttributes</h2><p>代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。</p><p> @SessionAttributes即将值放到session作用域中，写在class上面。</p><p>具体示例参见下面：使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据</p><h2 id="5-PathVariable"><a href="#5-PathVariable" class="headerlink" title="5.@PathVariable"></a>5.@PathVariable</h2><p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;  </span><br><span class="line">     <span class="meta">@RequestMapping</span>(value=<span class="string">"/user/&#123;userId&#125;/roles/&#123;roleId&#125;"</span>,method = RequestMethod.GET)  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getLogin</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> String userId,  </span></span><br><span class="line"><span class="function">         @<span class="title">PathVariable</span><span class="params">(<span class="string">"roleId"</span>)</span> String roleId)</span>&#123;  </span><br><span class="line">         System.out.println(<span class="string">"User Id : "</span> + userId);  </span><br><span class="line">         System.out.println(<span class="string">"Role Id : "</span> + roleId);  </span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello"</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="meta">@RequestMapping</span>(value=<span class="string">"/product/&#123;productId&#125;"</span>,method = RequestMethod.GET)  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getProduct</span><span class="params">(@PathVariable(<span class="string">"productId"</span>)</span> String productId)</span>&#123;  </span><br><span class="line">           System.out.println(<span class="string">"Product Id : "</span> + productId);  </span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello"</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="meta">@RequestMapping</span>(value=<span class="string">"/javabeat/&#123;regexp1:[a-z-]+&#125;"</span>,  </span><br><span class="line">           method = RequestMethod.GET)  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getRegExp</span><span class="params">(@PathVariable(<span class="string">"regexp1"</span>)</span> String regexp1)</span>&#123;  </span><br><span class="line">           System.out.println(<span class="string">"URI Part 1 : "</span> + regexp1);  </span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello"</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="6-requestParam"><a href="#6-requestParam" class="headerlink" title="6.@requestParam"></a>6.@requestParam</h2><p>@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。</p><h2 id="7-ResponseBody"><a href="#7-ResponseBody" class="headerlink" title="7.@ResponseBody"></a>7.@ResponseBody</h2><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json.xml等）使用；</p><h2 id="8-Component"><a href="#8-Component" class="headerlink" title="8.@Component"></a>8.<strong>@Component</strong></h2><p>相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。</p><h2 id="9-Repository"><a href="#9-Repository" class="headerlink" title="9.@Repository"></a>9.@Repository</h2><p>用于注解dao层，在daoImpl类上面注解。</p><h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><h4 id="1-使用-RequestMapping-来映射-Request-请求与处理器"><a href="#1-使用-RequestMapping-来映射-Request-请求与处理器" class="headerlink" title="1.使用 @RequestMapping 来映射 Request 请求与处理器"></a>1.使用 @RequestMapping 来映射 Request 请求与处理器</h4><p>方式一.通过常见的类路径和方法路径结合访问controller方法</p><p>方式二.使用uri模板</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span> ( <span class="string">"/test/&#123;variable1&#125;"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span> ( <span class="string">"/showView/&#123;variable2&#125;"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showView</span><span class="params">( @PathVariable String variable1, @PathVariable ( <span class="string">"variable2"</span> )</span> <span class="keyword">int</span> variable2) </span>&#123;</span><br><span class="line">       ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       modelAndView.setViewName( <span class="string">"viewName"</span> );</span><br><span class="line">       modelAndView.addObject( <span class="string">" 需要放到 model 中的属性名称 "</span> , <span class="string">" 对应的属性值，它是一个对象 "</span> );</span><br><span class="line">       <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>URI 模板就是在URI 中给定一个变量，然后在映射的时候动态的给该变量赋值。如URI 模板<a href="http://localhost/app/{variable1}/index.html" target="_blank" rel="noopener">http://localhost/app/{variable1}/index.html</a> ，这个模板里面包含一个变量variable1 ，那么当我们请求<a href="http://localhost/app/hello/index.html" target="_blank" rel="noopener">http://localhost/app/hello/index.html</a> 的时候，该URL 就跟模板相匹配，只是把模板中的variable1 用hello 来取代。这个变量在SpringMVC 中是使用@PathVariable 来标记的。在SpringMVC 中，我们可以使用@PathVariable 来标记一个Controller 的处理方法参数，表示该参数的值将使用URI 模板中对应的变量的值来赋值。</p><p>代码中我们定义了两个URI 变量，一个是控制器类上的variable1 ，一个是showView 方法上的variable2 ，然后在showView 方法的参数里面使用<strong>@PathVariable</strong> 标记使用了这两个变量。所以当我们使用/test/hello/showView/2.do 来请求的时候就可以访问到MyController 的showView 方法，这个时候variable1 就被赋予值hello ，variable2 就被赋予值2 ，然后我们在showView 方法参数里面标注了参数variable1 和variable2 是来自访问路径的path 变量，这样方法参数variable1 和variable2 就被分别赋予hello 和2 。方法参数variable1 是定义为String 类型，variable2 是定义为int 类型，像这种简单类型在进行赋值的时候Spring 是会帮我们自动转换的。</p><p>  在上面的代码中我们可以看到在标记variable1 为path 变量的时候我们使用的是@PathVariable ，而在标记variable2 的时候使用的是@PathVariable(“variable2”) 。这两者有什么区别呢？第一种情况就默认去URI 模板中找跟参数名相同的变量，但是这种情况只有在使用debug 模式进行编译的时候才可以，而第二种情况是明确规定使用的就是URI 模板中的variable2 变量。当不是使用debug 模式进行编译，或者是所需要使用的变量名跟参数名不相同的时候，就要使用第二种方式明确指出使用的是URI 模板中的哪个变量。</p><p> 除了在请求路径中使用URI 模板，定义变量之外，<strong>@RequestMapping 中还支持通配符“* ”</strong>。如下面的代码我就可以使用/myTest/whatever/wildcard.do 访问到Controller 的testWildcard 方法。如：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span> ( <span class="string">"/myTest"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span> ( <span class="string">"*/wildcard"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testWildcard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"wildcard------------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"wildcard"</span> ;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>当@RequestParam中没有指定参数名称时，Spring 在代码是debug 编译的情况下会默认取更方法参数同名的参数，如果不是debug 编译的就会报错。</p><h4 id="2-使用-RequestMapping-的一些高级用法"><a href="#2-使用-RequestMapping-的一些高级用法" class="headerlink" title="2.使用 @RequestMapping 的一些高级用法"></a>2.使用 @RequestMapping 的一些高级用法</h4><p>（1）params属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (value= <span class="string">"testParams"</span> , params=&#123; <span class="string">"param1=value1"</span> , <span class="string">"param2"</span> , <span class="string">"!param3"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"test Params..........."</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"testParams"</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的。</p><p>（2）method属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (value= <span class="string">"testMethod"</span> , method=&#123;RequestMethod. GET , RequestMethod. DELETE &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"method"</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法。</p><p>（3）headers属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (value= <span class="string">"testHeaders"</span> , headers=&#123; <span class="string">"host=localhost"</span> , <span class="string">"Accept"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"headers"</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>headers 属性的用法和功能与params 属性相似。在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法。</p><h3 id="3-RequestMapping-标记的处理器方法支持的方法参数和返回类型"><a href="#3-RequestMapping-标记的处理器方法支持的方法参数和返回类型" class="headerlink" title="3. @RequestMapping 标记的处理器方法支持的方法参数和返回类型"></a>3. @RequestMapping 标记的处理器方法支持的方法参数和返回类型</h3><h4 id="1-支持的方法参数类型"><a href="#1-支持的方法参数类型" class="headerlink" title="1. 支持的方法参数类型"></a>1. 支持的方法参数类型</h4><p>​     <strong>（1 ）HttpServlet 对象，主要包括HttpServletRequest .HttpServletResponse 和HttpSession 对象。</strong> 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。</p><p>  <strong>（2 ）Spring 自己的WebRequest 对象。</strong> 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。</p><p>  <strong>（3 ）InputStream .OutputStream .Reader 和Writer 。</strong> InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。</p><p>  <strong>（4 ）使用@PathVariable .@RequestParam .@CookieValue 和@RequestHeader 标记的参数。</strong></p><p>  <strong>（5 ）使用@ModelAttribute 标记的参数。</strong></p><p>  <strong>（6 ）java.util.Map .Spring 封装的Model 和ModelMap 。</strong> 这些都可以用来封装模型数据，用来给视图做展示。</p><p>  <strong>（7 ）实体类。</strong> 可以用来接收上传的参数。</p><p>  <strong>（8 ）Spring 封装的MultipartFile 。</strong> 用来接收上传文件的。</p><p>  <strong>（9 ）Spring 封装的Errors 和BindingResult 对象。</strong> 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。</p><h4 id="2-支持的返回类型"><a href="#2-支持的返回类型" class="headerlink" title="2. 支持的返回类型"></a>2. 支持的返回类型</h4><p>  （1 ）一个包含模型和视图的ModelAndView 对象。</p><p>  （2 ）一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。</p><p>  （3 ）一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</p><p>  （4 ）一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</p><p>  （5 ）返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。</p><p>  （6 ）如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。</p><p>  （7 ）除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</p><h3 id="4-使用-ModelAttribute-和-SessionAttributes-传递和保存数据"><a href="#4-使用-ModelAttribute-和-SessionAttributes-传递和保存数据" class="headerlink" title="4.使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据"></a>4.使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据</h3><p>SpringMVC 支持使用 @<strong>ModelAttribute</strong> 和 @<strong>SessionAttributes</strong> 在不同的模型（model）和控制器之间共享数据。 <strong>@ModelAttribute</strong> 主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上。</p><p>当 @<strong>ModelAttribute</strong> 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 @<strong>ModelAttribute</strong>(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。关于 @ModelAttribute 标记在方法上时对应的属性是存放在 session 中还是存放在模型中，我们来做一个实验，看下面一段代码。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span> ( <span class="string">"/myTest"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span> ( <span class="string">"hello"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"-------------Hello---------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"world"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span> ( <span class="string">"intValue"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"-------------intValue---------------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span> ( <span class="string">"sayHello"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">( @ModelAttribute ( <span class="string">"hello"</span> )</span> String hello, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"intValue"</span> )</span> <span class="keyword">int</span> num, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"user2"</span> )</span> User user, Writer writer, HttpSession session) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       writer.write( <span class="string">"Hello "</span> + hello + <span class="string">" , Hello "</span> + user.getUsername() + num);</span><br><span class="line">       writer.write( <span class="string">"\r"</span> );</span><br><span class="line">       Enumeration enume = session.getAttributeNames();</span><br><span class="line">       <span class="keyword">while</span> (enume.hasMoreElements())</span><br><span class="line">           writer.write(enume.nextElement() + <span class="string">"\r"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span> ( <span class="string">"user2"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"---------getUser-------------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"user2"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>当我们请求 /myTest/sayHello.do 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值。执行结果如下所示：</p><p> <em>Hello world,Hello user210</em></p><p>​    由执行结果我们可以看出来，此时 session 中没有包含任何属性，也就是说上面的那些对象都是存放在模型属性中，而不是存放在 session 属性中。那要如何才能存放在 session 属性中呢？这个时候我们先引入一个新的概念 @SessionAttributes ，它的用法会在讲完 @ModelAttribute 之后介绍，这里我们就先拿来用一下。我们在 MyController 类上加上 @SessionAttributes 属性标记哪些是需要存放到 session 中的。看下面的代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span> ( <span class="string">"/myTest"</span> )</span><br><span class="line"><span class="meta">@SessionAttributes</span> (value=&#123; <span class="string">"intValue"</span> , <span class="string">"stringValue"</span> &#125;, types=&#123;User. <span class="class"><span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span> ( <span class="string">"hello"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"-------------Hello---------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"world"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span> ( <span class="string">"intValue"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"-------------intValue---------------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@RequestMapping</span> ( <span class="string">"sayHello"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Map&lt;String, Object&gt; map, @ModelAttribute ( <span class="string">"hello"</span> )</span> String hello, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"intValue"</span> )</span> <span class="keyword">int</span> num, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"user2"</span> )</span> User user, Writer writer, HttpServletRequest request) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       map.put( <span class="string">"stringValue"</span> , <span class="string">"String"</span> );</span><br><span class="line">       writer.write( <span class="string">"Hello "</span> + hello + <span class="string">" , Hello "</span> + user.getUsername() + num);</span><br><span class="line">       writer.write( <span class="string">"\r"</span> );</span><br><span class="line">       HttpSession session = request.getSession();</span><br><span class="line">       Enumeration enume = session.getAttributeNames();</span><br><span class="line">       <span class="keyword">while</span> (enume.hasMoreElements())</span><br><span class="line">           writer.write(enume.nextElement() + <span class="string">"\r"</span> );</span><br><span class="line">       System. out .println(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span> ( <span class="string">"user2"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"---------getUser-------------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"user2"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session中，利用上面的代码当我们访问 /myTest/sayHello.do 的时候，结果如下：</p><p> <em>Hello world,Hello user210</em></p><p>仍然没有打印出任何 session 属性，这是怎么回事呢？怎么定义了把模型中属性名为 intValue 的对象和类型为 User 的对象存到 session 中，而实际上没有加进去呢？难道我们错啦？我们当然没有错，只是在第一次访问 /myTest/sayHello.do 的时候 @SessionAttributes 定义了需要存放到 session 中的属性，而且这个模型中也有对应的属性，但是这个时候还没有加到 session 中，所以 session 中不会有任何属性，等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中。所以当请求第二次的时候就会出现如下结果：</p><p> <em>Hello world,Hello user210</em></p><p><em>user2</em></p><p><em>intValue</em></p><p><em>stringValue</em></p><p>当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称。</p><h3 id="5-PathVariable和-RequestParam的区别"><a href="#5-PathVariable和-RequestParam的区别" class="headerlink" title="5.@PathVariable和@RequestParam的区别"></a>5.@PathVariable和@RequestParam的区别</h3><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value = “/page/{id}”, method = RequestMethod.GET)<br>@RequestParam用来获得静态的URL请求入参   spring注解时action里用到。</p><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>handler method 参数绑定常用的注解,我们根据他们处理的Request的不同内容部分分为四类：（主要讲解常用类型）</p><p>A.处理<strong>requet uri</strong> 部分（这里指uri template中variable，不含queryString部分）的注解：  @PathVariable;</p><p>B.处理<strong>request header</strong>部分的注解：  @RequestHeader, @CookieValue;</p><p>C.处理<strong>request body</strong>部分的注解：@RequestParam, @RequestBody;</p><p>D.处理<strong>attribute</strong>类型是注解： @SessionAttributes, @ModelAttribute;</p><h4 id="（1）-PathVariable"><a href="#（1）-PathVariable" class="headerlink" title="（1）.@PathVariable"></a>（1）.@PathVariable</h4><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p><p>示例代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RelativePathUriTemplateController</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/pets/&#123;petId&#125;"</span>)  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String ownerId, @PathVariable String petId, Model model)</span> </span>&#123;      </span><br><span class="line">    <span class="comment">// implementation omitted   </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h4 id="（2）-RequestHeader-CookieValue"><a href="#（2）-RequestHeader-CookieValue" class="headerlink" title="（2）. @RequestHeader.@CookieValue"></a>（2）. @RequestHeader.@CookieValue</h4><p>@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上。</p><p>示例代码：</p><p>这是一个Request 的header部分：</p><ol><li><p>Host          localhost:8080 </p></li><li><p>Accept         text/html,application/xhtml+xml,application/xml;q=0.9 </p></li><li><p>Accept-Language     fr,en-gb;q=0.7,en;q=0.3 </p></li><li><p>Accept-Encoding     gzip,deflate </p></li><li><p>Accept-Charset     ISO-8859-1,utf-8;q=0.7,*;q=0.7 </p></li><li><p>Keep-Alive       300 </p></li><li><p>@RequestMapping(“/displayHeaderInfo.do”) </p></li><li><p><strong>public</strong> <strong>void</strong> displayHeaderInfo(@RequestHeader(“Accept-Encoding”) String encoding, </p></li><li><p>​               @RequestHeader(“Keep-Alive”) <strong>long</strong> keepAlive) { </p></li><li><p>} </p></li></ol><p>上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。</p><p>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。</p><p>例如有如下Cookie值：</p><p>　　JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/displayHeaderInfo.do"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayHeaderInfo</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span> String cookie)  </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即把JSESSIONID的值绑定到参数cookie上。</p><h4 id="（3）-RequestParam-RequestBody"><a href="#（3）-RequestParam-RequestBody" class="headerlink" title="（3）.@RequestParam, @RequestBody"></a>（3）.@RequestParam, @RequestBody</h4><p>@RequestParam </p><p>A） 常用来处理简单类型的绑定，<strong>通过Request.getParameter() 获取的String可直接转换为简单类型的情况</strong>（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理<strong>get 方式中queryString的值</strong>，也可以处理<strong>post方式中 body data的值</strong>；</p><p>B）用来处理Content-Type: 为 <code>application/x-www-form-urlencoded</code>编码的内容，提交方式GET.POST；</p><p>C) 该注解有两个属性： value.required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；</p><p>示例代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/pets"</span>)  </span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"pet"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditPetForm</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.GET)  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">setupForm</span><span class="params">(@RequestParam(<span class="string">"petId"</span>)</span> <span class="keyword">int</span> petId, ModelMap model) </span>&#123;  </span><br><span class="line">       Pet pet = <span class="keyword">this</span>.clinic.loadPet(petId);  </span><br><span class="line">   model.addAttribute(<span class="string">"pet"</span>, pet);  </span><br><span class="line">   <span class="keyword">return</span> <span class="string">"petForm"</span>;  </span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>@RequestBody</p><p>该注解常用来处理Content-Type: 不是<code>application/x-www-form-urlencoded</code>编码的内容，例如application/json, application/xml等；</p><p>它是通过使用HandlerAdapter 配置的<code>HttpMessageConverters</code>来解析post data body，然后绑定到相应的bean上的。</p><p>因为配置有FormHttpMessageConverter，所以也可以用来处理 <code>application/x-www-form-urlencoded</code>的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/something"</span>, method = RequestMethod.PUT)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@RequestBody String body, Writer writer)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">  writer.write(body);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）-SessionAttributes-ModelAttribute"><a href="#（4）-SessionAttributes-ModelAttribute" class="headerlink" title="（4）.@SessionAttributes, @ModelAttribute"></a>（4）.@SessionAttributes, @ModelAttribute</h4><p>@SessionAttributes:</p><p>该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。</p><p>该注解有value.types两个属性，可以通过名字和类型指定要使用的attribute 对象；</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/editPet.do"</span>)  </span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"pet"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditPetForm</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ModelAttribute</p><p>该注解有两个用法，一个是用于方法上，一个是用于参数上；</p><p>用于方法上时： 通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</p><p>用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于：</p><p>A） @SessionAttributes 启用的attribute 对象上；</p><p>B） @ModelAttribute 用于方法上时指定的model对象；</p><p>C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。</p><p>用到方法上@ModelAttribute的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">addAccount</span><span class="params">(@RequestParam String number)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> accountManager.findAccount(number);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）。</p><p>用在参数上的@ModelAttribute示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit"</span>, method = RequestMethod.POST)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(@ModelAttribute Pet pet)</span> </span>&#123;  </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.<span class="tag">&lt; <span class="attr">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">""</span> /&gt;</span>浅析</span><br></pre></td></tr></table></figure><p>component-scan 默认扫描的注解类型是 @Component，不过，在 @Component 语义基础上细化后的 @Repository, @Service 和 @Controller 也同样可以获得 component-scan 的青睐</p><p>有了<a href="context:component-scan">context:component-scan</a>，另一个<a href="context:annotation-config/">context:annotation-config/</a>标签根本可以移除掉，因为已经被包含进去了</p><p>另外<a href="context:annotation-config/">context:annotation-config/</a>还提供了两个子标签</p><p>\1.    <a href="context:include-filter">context:include-filter</a> //指定扫描的路径</p><p>\2.    <a href="context:exclude-filter">context:exclude-filter</a> //排除扫描的路径</p><p><a href="context:component-scan">context:component-scan</a>有一个use-default-filters属性，属性默认为true,表示会扫描指定包下的全部的标有@Component的类，并注册成bean.也就是@Component的子注解@Service,@Reposity等。</p><p>这种扫描的粒度有点太大，如果你只想扫描指定包下面的Controller或其他内容则设置use-default-filters属性为false，表示不再按照scan指定的包扫描，而是按照<a href="context:include-filter">context:include-filter</a>指定的包扫描，示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tan"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"regex"</span> <span class="attr">expression</span>=<span class="string">"com.tan.*"</span>/&gt;</span>//注意后面要写.*</span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">当没有设置use-default-filters属性或者属性为true时，表示基于base-packge包下指定扫描的具体路径</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tan"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"regex"</span> <span class="attr">expression</span>=<span class="string">".controller.*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"regex"</span> <span class="attr">expression</span>=<span class="string">".service.*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"regex"</span> <span class="attr">expression</span>=<span class="string">".dao.*"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">效果相当于：</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tan"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"regex"</span> <span class="attr">expression</span>=<span class="string">".model.*"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：本人尝试时无论哪种情况&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;都不能同时存在</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;springmvc常用注解标签详解-https-www-cnblogs-com-leskang-p-5445698-html&quot;&gt;&lt;a href=&quot;#springmvc常用注解标签详解-https-www-cnblogs-com-leskang-p-5445698-html&quot; class=&quot;headerlink&quot; title=&quot;springmvc常用注解标签详解](https://www.cnblogs.com/leskang/p/5445698.html)&quot;&gt;&lt;/a&gt;springmvc常用注解标签详解](&lt;a href=&quot;https://www.cnblogs.com/leskang/p/5445698.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/leskang/p/5445698.html&lt;/a&gt;)&lt;/h1&gt;&lt;h2 id=&quot;1-Controller&quot;&gt;&lt;a href=&quot;#1-Controller&quot; class=&quot;headerlink&quot; title=&quot;1.@Controller&quot;&gt;&lt;/a&gt;1.@Controller&lt;/h2&gt;&lt;p&gt;在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。&lt;/p&gt;
&lt;p&gt;@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：&lt;/p&gt;
&lt;p&gt;　　（1）在SpringMVC 的配置文件中定义MyController 的bean 对象。&lt;/p&gt;
&lt;p&gt;　　（2）在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--方式一--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;com.host.app.web.controller.MyController&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--方式二--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt; &lt;span class=&quot;attr&quot;&gt;context:component-scan&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;base-package&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;com.host.app.web&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;//路径写到controller的上一层(扫描包详解见下面浅析)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://www.kangxh.xyz/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="spring" scheme="http://www.kangxh.xyz/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>VSCode的快捷键</title>
    <link href="http://www.kangxh.xyz/2021/02/14/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://www.kangxh.xyz/2021/02/14/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2021-02-14T12:39:43.000Z</published>
    <updated>2021-02-19T04:44:28.774Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>VSCode的快捷键继承了一些IDE风格，有VS Studio的身影，也有Emacs的身影,</p><p>简言之，内置快捷键玩熟了，效率提高不是一点两点。</p><h2 id="快捷键有五种组合方式-科普"><a href="#快捷键有五种组合方式-科普" class="headerlink" title="快捷键有五种组合方式(科普)"></a>快捷键有五种组合方式(科普)</h2><ol><li><code>Ctrl + Shift + ?</code> : 这种常规组合按钮</li><li><code>Ctrl + C Ctrl +V</code> : 同时依赖一个按键的组合</li><li><code>Shift + V C</code> : 先组合后单键的输入</li><li><code>Ctrl + Click</code>: 键盘 + 鼠标点击</li><li><code>Ctrl + DragMouse</code> : 键盘 + 鼠标拖动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macos&#96;下大多键位等同，&#96;Ctrl&#96;换成&#96;Command</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="快捷键大全"><a href="#快捷键大全" class="headerlink" title="快捷键大全"></a>快捷键大全</h2><h3 id="通用快捷键"><a href="#通用快捷键" class="headerlink" title="通用快捷键"></a>通用快捷键</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+Shift+P,F1</td><td>展示全局命令面板</td></tr><tr><td>Ctrl+P</td><td>快速打开最近打开的文件</td></tr><tr><td>Ctrl+Shift+N</td><td>打开新的编辑器窗口</td></tr><tr><td>Ctrl+Shift+W</td><td>关闭编辑器</td></tr></tbody></table><h3 id="基础编辑"><a href="#基础编辑" class="headerlink" title="基础编辑"></a>基础编辑</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + X</td><td>剪切</td></tr><tr><td>Ctrl + C</td><td>复制</td></tr><tr><td>Alt + up/down</td><td>移动行上下</td></tr><tr><td>Shift + Alt up/down</td><td>在当前行上下复制当前行</td></tr><tr><td>Ctrl + Shift + K</td><td>删除行</td></tr><tr><td>Ctrl + Enter</td><td>在当前行下插入新的一行</td></tr><tr><td>Ctrl + Shift + Enter</td><td>在当前行上插入新的一行</td></tr><tr><td>Ctrl + Shift + | 匹配花括号的闭合处，跳转</td><td></td></tr><tr><td>Ctrl + ] / [</td><td>行缩进</td></tr><tr><td>Home</td><td>光标跳转到行头</td></tr><tr><td>End</td><td>光标跳转到行尾</td></tr><tr><td>Ctrl + Home</td><td>跳转到页头</td></tr><tr><td>Ctrl + End</td><td>跳转到页尾</td></tr><tr><td>Ctrl + up/down</td><td>行视图上下偏移</td></tr><tr><td>Alt + PgUp/PgDown</td><td>屏视图上下偏移</td></tr><tr><td>Ctrl + Shift + [</td><td>折叠区域代码</td></tr><tr><td>Ctrl + Shift + ]</td><td>展开区域代码</td></tr><tr><td>Ctrl + K Ctrl + [</td><td>折叠所有子区域代码</td></tr><tr><td>Ctrl + k Ctrl + ]</td><td>展开所有折叠的子区域代码</td></tr><tr><td>Ctrl + K Ctrl + 0</td><td>折叠所有区域代码</td></tr><tr><td>Ctrl + K Ctrl + J</td><td>展开所有折叠区域代码</td></tr><tr><td>Ctrl + K Ctrl + C</td><td>添加行注释</td></tr><tr><td>Ctrl + K Ctrl + U</td><td>删除行注释</td></tr><tr><td>Ctrl + /</td><td>添加关闭行注释</td></tr><tr><td>Shift + Alt +A</td><td>块区域注释</td></tr><tr><td>Alt + Z</td><td>添加关闭词汇包含</td></tr></tbody></table><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + T</td><td>列出所有符号</td></tr><tr><td>Ctrl + G</td><td>跳转行</td></tr><tr><td>Ctrl + P</td><td>跳转文件</td></tr><tr><td>Ctrl + Shift + O</td><td>跳转到符号处</td></tr><tr><td>Ctrl + Shift + M</td><td>打开问题展示面板</td></tr><tr><td>F8</td><td>跳转到下一个错误或者警告</td></tr><tr><td>Shift + F8</td><td>跳转到上一个错误或者警告</td></tr><tr><td>Ctrl + Shift + Tab</td><td>切换到最近打开的文件</td></tr><tr><td>Alt + left / right</td><td>向后、向前</td></tr><tr><td>Ctrl + M</td><td>进入用Tab来移动焦点</td></tr></tbody></table><h3 id="查询与替换"><a href="#查询与替换" class="headerlink" title="查询与替换"></a>查询与替换</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + F</td><td>查询</td></tr><tr><td>Ctrl + H</td><td>替换</td></tr><tr><td>F3 / Shift + F3</td><td>查询下一个/上一个</td></tr><tr><td>Alt + Enter</td><td>选中所有出现在查询中的</td></tr><tr><td>Ctrl + D</td><td>匹配当前选中的词汇或者行，再次选中-可操作</td></tr><tr><td>Ctrl + K Ctrl + D</td><td>移动当前选择到下个匹配选择的位置(光标选定)</td></tr><tr><td>Alt + C / R / W</td><td></td></tr></tbody></table><h3 id="多行光标操作于选择"><a href="#多行光标操作于选择" class="headerlink" title="多行光标操作于选择"></a>多行光标操作于选择</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Alt + Click</td><td>插入光标-支持多个</td></tr><tr><td>Ctrl + Alt + up/down</td><td>上下插入光标-支持多个</td></tr><tr><td>Ctrl + U</td><td>撤销最后一次光标操作</td></tr><tr><td>Shift + Alt + I</td><td>插入光标到选中范围内所有行结束符</td></tr><tr><td>Ctrl + I</td><td>选中当前行</td></tr><tr><td>Ctrl + Shift + L</td><td>选择所有出现在当前选中的行-操作</td></tr><tr><td>Ctrl + F2</td><td>选择所有出现在当前选中的词汇-操作</td></tr><tr><td>Shift + Alt + right</td><td>从光标处扩展选中全行</td></tr><tr><td>Shift + Alt + left</td><td>收缩选择区域</td></tr><tr><td>Shift + Alt + (drag mouse)</td><td>鼠标拖动区域，同时在多个行结束符插入光标</td></tr><tr><td>Ctrl + Shift + Alt + (Arrow Key)</td><td>也是插入多行光标的[方向键控制]</td></tr><tr><td>Ctrl + Shift + Alt + PgUp/PgDown</td><td>也是插入多行光标的[整屏生效]</td></tr></tbody></table><h3 id="丰富的语言操作"><a href="#丰富的语言操作" class="headerlink" title="丰富的语言操作"></a>丰富的语言操作</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + Space</td><td>输入建议[智能提示]</td></tr><tr><td>Ctrl + Shift + Space</td><td>参数提示</td></tr><tr><td>Tab</td><td>Emmet指令触发/缩进</td></tr><tr><td>Shift + Alt + F</td><td>格式化代码</td></tr><tr><td>Ctrl + K Ctrl + F</td><td>格式化选中部分的代码</td></tr><tr><td>F12</td><td>跳转到定义处</td></tr><tr><td>Alt + F12</td><td>代码片段显示定义</td></tr><tr><td>Ctrl + K F12</td><td>在其他窗口打开定义处</td></tr><tr><td>Ctrl + .</td><td>快速修复部分可以修复的语法错误</td></tr><tr><td>Shift + F12</td><td>显示所有引用</td></tr><tr><td>F2</td><td>重命名符号</td></tr><tr><td>Ctrl + Shift + . / ,</td><td>替换下个值</td></tr><tr><td>Ctrl + K Ctrl + X</td><td>移除空白字符</td></tr><tr><td>Ctrl + K M</td><td>更改页面文档格式</td></tr></tbody></table><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + F4, Ctrl + W</td><td>关闭编辑器</td></tr><tr><td>Ctrl + k F</td><td>关闭当前打开的文件夹</td></tr><tr><td>Ctrl + |切割编辑窗口</td><td></td></tr><tr><td>Ctrl + 1/2/3</td><td>切换焦点在不同的切割窗口</td></tr><tr><td>Ctrl + K Ctrl &lt;-/-&gt;</td><td>切换焦点在不同的切割窗口</td></tr><tr><td>Ctrl + Shift + PgUp/PgDown</td><td>切换标签页的位置</td></tr><tr><td>Ctrl + K &lt;-/-&gt;</td><td>切割窗口位置调换</td></tr></tbody></table><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + N</td><td>新建文件</td></tr><tr><td>Ctrl + O</td><td>打开文件</td></tr><tr><td>Ctrl + S</td><td>保存文件</td></tr><tr><td>Ctrl + Shift + S</td><td>另存为</td></tr><tr><td>Ctrl + K S</td><td>保存所有当前已经打开的文件</td></tr><tr><td>Ctrl + F4</td><td>关闭当前编辑窗口</td></tr><tr><td>Ctrl + K Ctrl + W</td><td>关闭所有编辑窗口</td></tr><tr><td>Ctrl + Shift + T</td><td>撤销最近关闭的一个文件编辑窗口</td></tr><tr><td>Ctrl + K Enter</td><td>保持开启</td></tr><tr><td>Ctrl + Shift + Tab</td><td>调出最近打开的文件列表，重复按会切换</td></tr><tr><td>Ctrl + Tab</td><td>与上面一致，顺序不一致</td></tr><tr><td>Ctrl + K P</td><td>复制当前打开文件的存放路径</td></tr><tr><td>Ctrl + K R</td><td>打开当前编辑文件存放位置【文件管理器】</td></tr><tr><td>Ctrl + K O</td><td>在新的编辑器中打开当前编辑的文件</td></tr></tbody></table><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>F11</td><td>切换全屏模式</td></tr><tr><td>Shift + Alt + 1</td><td>切换编辑布局【目前无效】</td></tr><tr><td>Ctrl + =/-</td><td>放大 / 缩小</td></tr><tr><td>Ctrl + B</td><td>侧边栏显示隐藏</td></tr><tr><td>Ctrl + Shift + E</td><td>资源视图和编辑视图的焦点切换</td></tr><tr><td>Ctrl + Shift + F</td><td>打开全局搜索</td></tr><tr><td>Ctrl + Shift + G</td><td>打开Git可视管理</td></tr><tr><td>Ctrl + Shift + D</td><td>打开DeBug面板</td></tr><tr><td>Ctrl + Shift + X</td><td>打开插件市场面板</td></tr><tr><td>Ctrl + Shift + H</td><td>在当前文件替换查询替换</td></tr><tr><td>Ctrl + Shift + J</td><td>开启详细查询</td></tr><tr><td>Ctrl + Shift + V</td><td>预览Markdown文件【编译后】</td></tr><tr><td>Ctrl + K v</td><td>在边栏打开渲染后的视图【新建】</td></tr></tbody></table><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>F9</td><td>添加解除断点</td></tr><tr><td>F5</td><td>启动调试、继续</td></tr><tr><td>F11 / Shift + F11</td><td>单步进入 / 单步跳出</td></tr><tr><td>F10</td><td>单步跳过</td></tr><tr><td>Ctrl + K Ctrl + I</td><td>显示悬浮</td></tr></tbody></table><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + `</td><td>打开集成终端</td></tr><tr><td>Ctrl + Shift + `</td><td>创建一个新的终端</td></tr><tr><td>Ctrl + Shift + C</td><td>复制所选</td></tr><tr><td>Ctrl + Shift + V</td><td>复制到当前激活的终端</td></tr><tr><td>Shift + PgUp / PgDown</td><td>页面上下翻屏</td></tr><tr><td>Ctrl + Home / End</td><td>滚动到页面头部或尾部</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所有翻译肯定都不是标译的啦，我的翻译都是比较接近口语化和使用的</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;VSCode的快捷键继承了一些IDE风格，有VS Studio的身影，也有Emacs的身影,&lt;/p&gt;
&lt;p&gt;简言之，内置快捷键玩熟了，效率提高不是一点两点。&lt;/p&gt;
&lt;h2 id=&quot;快捷键有五种组合方式-科普&quot;&gt;&lt;a href=&quot;#快捷键有五种组合方式-科普&quot; class=&quot;headerlink&quot; title=&quot;快捷键有五种组合方式(科普)&quot;&gt;&lt;/a&gt;快捷键有五种组合方式(科普)&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Ctrl + Shift + ?&lt;/code&gt; : 这种常规组合按钮&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + C Ctrl +V&lt;/code&gt; : 同时依赖一个按键的组合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shift + V C&lt;/code&gt; : 先组合后单键的输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + Click&lt;/code&gt;: 键盘 + 鼠标点击&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + DragMouse&lt;/code&gt; : 键盘 + 鼠标拖动&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;macos&amp;#96;下大多键位等同，&amp;#96;Ctrl&amp;#96;换成&amp;#96;Command&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="vscode" scheme="http://www.kangxh.xyz/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>鼠标滚轮上下失灵处理方法</title>
    <link href="http://www.kangxh.xyz/2021/02/09/%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE%E4%B8%8A%E4%B8%8B%E5%A4%B1%E7%81%B5%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>http://www.kangxh.xyz/2021/02/09/%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE%E4%B8%8A%E4%B8%8B%E5%A4%B1%E7%81%B5%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</id>
    <published>2021-02-09T14:44:29.000Z</published>
    <updated>2021-02-19T04:49:07.796Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>鼠标滚轮是一个小轮子，用手指拨动时，带动内部编码器转动，发出脉冲信号，鼠标解码后获得指令向上或向下滚动。最常见的是机械式编码器，内部就是三部分滑片，使用久了内部磨损，脱落的杂质集聚导致接触不良。</p><a id="more"></a><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="第一种（重装驱动）"><a href="#第一种（重装驱动）" class="headerlink" title="第一种（重装驱动）"></a>第一种（重装驱动）</h4><ol><li><p>首先，右击桌面上的“计算机”图标，选择【管理】;</p></li><li><p>在弹出窗口中，点左侧的【设备管理器】，展开【鼠标和其他指针设备】，右击卸载【HID-compliant mouse】;</p></li><li><p>最后重启电脑。</p></li></ol><h4 id="第二种（修改注册表）"><a href="#第二种（修改注册表）" class="headerlink" title="第二种（修改注册表）"></a>第二种（修改注册表）</h4><ol><li>按Win+R键，打开运行窗口，输入regedit回车打开;</li><li>进入目录 HKEY_CURRENT_USER \ Control Panel \ Dosktop，在右侧双击打开【WheelScrollLines】，将数值改为3，点“确定”即可。</li><li><strong>注：</strong>在第一种方法不行的时候使用这种，一般默认不用修改，直接使用第二种方法可能无效</li></ol><h3 id="第三种（物理操作）"><a href="#第三种（物理操作）" class="headerlink" title="第三种（物理操作）"></a>第三种（物理操作）</h3><ol><li>拆开鼠标；</li><li>取出滚轮；</li><li>更换滚轮两边的零件；</li><li>换好以后把滚轮和盖子安装好就行了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h3&gt;&lt;p&gt;鼠标滚轮是一个小轮子，用手指拨动时，带动内部编码器转动，发出脉冲信号，鼠标解码后获得指令向上或向下滚动。最常见的是机械式编码器，内部就是三部分滑片，使用久了内部磨损，脱落的杂质集聚导致接触不良。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="win10" scheme="http://www.kangxh.xyz/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>优雅地识别理科公式——mathpix/mathpix api/MathpixCsharp/MathF的使用</title>
    <link href="http://www.kangxh.xyz/2021/01/31/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AF%86%E5%88%AB%E7%90%86%E7%A7%91%E5%85%AC%E5%BC%8F%E2%80%94%E2%80%94mathpix-mathpix-api-MathpixCsharp-MathF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.kangxh.xyz/2021/01/31/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AF%86%E5%88%AB%E7%90%86%E7%A7%91%E5%85%AC%E5%BC%8F%E2%80%94%E2%80%94mathpix-mathpix-api-MathpixCsharp-MathF%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-01-31T13:53:58.000Z</published>
    <updated>2021-02-19T04:47:42.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>最近有识别图片公式OCR识别地需求，发现Mathpix Snip甚合我意，只需要截个图，Mathpix Snip就可以将截图中的公式自动转化为 LaTex 代码表达式或者MS word格式（直接粘贴进word），我们只需要简单地修改就可以直接插入到LaTex或Word中，公式较为清晰规范的话是不需要修改的，电子公式的识别率几乎100%，而且可以识别手写的公式。</p><a id="more"></a><p>这是识别数学公式</p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210131215538.gif" alt="img"></p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210131215600.png" alt="img"></p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210131215626.png" alt="img"></p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210131215635.png" alt="img"></p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210131215644.jpg" alt="img"></p><h1 id="Mathpix-Snip介绍"><a href="#Mathpix-Snip介绍" class="headerlink" title="Mathpix Snip介绍"></a>Mathpix Snip介绍</h1><p>说明：需注册，个人邮箱50条/月，Edu邮箱100条/月，可以保存历史记录，站里之前也有人推荐过。<br>官方网站：<a href="https://mathpix.com/" target="_blank" rel="noopener">https://mathpix.com/</a><br>更多讨论：<a href="http://kuing.orzweb.net/viewthread.php?tid=6122" target="_blank" rel="noopener">http://kuing.orzweb.net/viewthread.php?tid=6122</a></p><h1 id="MathpixCsharp项目介绍（推荐）"><a href="#MathpixCsharp项目介绍（推荐）" class="headerlink" title="MathpixCsharp项目介绍（推荐）"></a>MathpixCsharp项目介绍（推荐）</h1><p>说明：需自己申请Mathpix api（需要Visa/MasterCard的信用卡验证），api请求限制1000条/月，无法保存历史记录，这是爱好者自己开发的工具，站里也没人推荐<br>项目网站：<a href="https://github.com/itewqq/MathpixCsharp" target="_blank" rel="noopener">https://github.com/itewqq/MathpixCsharp</a><br>下载地址：<a href="https://github.com/itewqq/MathpixCsharp/releases" target="_blank" rel="noopener">https://github.com/itewqq/MathpixCsharp/releases</a></p><h1 id="MathF项目介绍（着重推荐，适合临时使用的小白）"><a href="#MathF项目介绍（着重推荐，适合临时使用的小白）" class="headerlink" title="MathF项目介绍（着重推荐，适合临时使用的小白）"></a>MathF项目介绍（着重推荐，适合临时使用的小白）</h1><p>说明：个人开发，也是利用了<strong>mathpix</strong>的接口，但是不需要注册账号申请api，也去掉了每月请求数的限制，无法保存历史记录，这是爱好者自己开发的工具，站里也没人推荐<br>在线网站：<a href="https://mathcode.herokuapp.com/" target="_blank" rel="noopener">https://mathcode.herokuapp.com/</a><br>项目网站：<a href="https://github.com/itewqq/MathF" target="_blank" rel="noopener">https://github.com/itewqq/MathF</a></p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210131215744.jpg" alt="img"></p><h1 id="Snipaste截图工具推荐"><a href="#Snipaste截图工具推荐" class="headerlink" title="Snipaste截图工具推荐"></a>Snipaste截图工具推荐</h1><p>说明：由于Mathpix是基于截图的程序，故推荐Snipaste用以截图，当然你也可以选择其他熟悉的工具<br>官方网站：<a href="https://zh.snipaste.com/" target="_blank" rel="noopener">https://zh.snipaste.com/</a></p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210131215807.gif" alt="img"></p><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>为了鼓励支持原作者，这里都是贴出原作者发布地址，如果Github界面打不开，一般是个别电信运营商的域名DNS污染问题，可以尝试以下操作<br>1.修改本地DNS服务器为8.8.8.8;<br>2.打开 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 输入访问不了的域名，查询之后可以获得正确的 IP 地址;<br>3.在本机的 host 文件中添加，建议使用 SwitchHosts 方便 host 管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">199.232.68.133 raw.githubusercontent.com</span><br><span class="line">199.232.68.133 user-images.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure><p>通过添加以上几条 host 配置，一般就正常了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h1&gt;&lt;p&gt;最近有识别图片公式OCR识别地需求，发现Mathpix Snip甚合我意，只需要截个图，Mathpix Snip就可以将截图中的公式自动转化为 LaTex 代码表达式或者MS word格式（直接粘贴进word），我们只需要简单地修改就可以直接插入到LaTex或Word中，公式较为清晰规范的话是不需要修改的，电子公式的识别率几乎100%，而且可以识别手写的公式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="http://www.kangxh.xyz/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>浏览器广告过滤</title>
    <link href="http://www.kangxh.xyz/2021/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%BF%E5%91%8A%E8%BF%87%E6%BB%A4/"/>
    <id>http://www.kangxh.xyz/2021/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%BF%E5%91%8A%E8%BF%87%E6%BB%A4/</id>
    <published>2021-01-31T13:30:37.000Z</published>
    <updated>2021-02-19T04:48:59.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="uBlock-Origin"><a href="#uBlock-Origin" class="headerlink" title="uBlock Origin"></a>uBlock Origin</h1><p>插件下载:<a href="https://liuhouer.lanzous.com/ibjtxna" target="_blank" rel="noopener">https://liuhouer.lanzous.com/ibjtxna</a> 密码:cdsc</p><p><strong>规则链接：</strong><br>HalfLife规则：<br><a href="https://gitee.com/halflife/list/raw/master/ad.txt" target="_blank" rel="noopener">https://gitee.com/halflife/list/raw/master/ad.txt</a></p><p>乘风广告过滤规则“<br><a href="https://gitee.com/xinggsf/Adblock-Rule/raw/master/rule.txt" target="_blank" rel="noopener">https://gitee.com/xinggsf/Adblock-Rule/raw/master/rule.txt</a></p><p>乘风视频规则，可过滤国内视频站片头广告和黑屏：<br><a href="https://gitee.com/xinggsf/Adblock-Rule/raw/master/mv.txt" target="_blank" rel="noopener">https://gitee.com/xinggsf/Adblock-Rule/raw/master/mv.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="chrome" scheme="http://www.kangxh.xyz/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>微信备份聊天记录提示当前网络状况</title>
    <link href="http://www.kangxh.xyz/2021/01/27/%E5%BE%AE%E4%BF%A1%E5%A4%87%E4%BB%BD%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E6%8F%90%E7%A4%BA%E5%BD%93%E5%89%8D%E7%BD%91%E7%BB%9C%E7%8A%B6%E5%86%B5%E5%A4%8D%E6%9D%82/"/>
    <id>http://www.kangxh.xyz/2021/01/27/%E5%BE%AE%E4%BF%A1%E5%A4%87%E4%BB%BD%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E6%8F%90%E7%A4%BA%E5%BD%93%E5%89%8D%E7%BD%91%E7%BB%9C%E7%8A%B6%E5%86%B5%E5%A4%8D%E6%9D%82/</id>
    <published>2021-01-27T12:27:37.000Z</published>
    <updated>2021-02-19T04:47:48.074Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="聊天记录备份"><a href="#聊天记录备份" class="headerlink" title="聊天记录备份"></a>聊天记录备份</h2><p>在通过电脑版微信备份数据的时候，提示 “当前网络状况复杂，请尝试使用其它网络”，说明微信电脑版备份失败，这是什么原因呢？</p><a id="more"></a><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210127202840.png" alt="image-20210127202832735"></p><p>在网上的教程上看到说，自己的电脑发布热点，手机连上就可以备份。但我的手机访问不了互联网，和电脑的微信没法连通。</p><p>后来在 “控制面板” 的 “网络和共享中心” 模块，禁用了暂时用不到的网卡。</p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210127202917.png" alt="image-20210127202916596"></p><p>确实，装了虚拟机，有很多复杂的网络…… 禁用了之后，微信就没再提示问题了，微信电脑版备份数据成功。这里做一个记录。</p><h2 id="备份速度加速"><a href="#备份速度加速" class="headerlink" title="备份速度加速"></a>备份速度加速</h2><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210127204657.png" alt="image-20210127204650515"></p><ol><li>把手机跟电脑，用数据线连接起来。</li><li>让电脑通过手机来上网！苹果手机直接用数据线连接即可，电脑拔掉网线或退出 wifi。<br>安卓手机在手机设置里选择无线和网络设置，里面应该有‘绑定与便携式热点’，进入之后选择 USB 绑定，在其后打钩即可。（或自行百度一下）</li><li>这样电脑和手机之间就是不仅在同一个网络，数据传输不是通过 wifi 无线，而是通过数据线有线传输！</li></ol><p>讲到这里就坐等备份完成啦。</p><p>数据恢复也是差不多操作哦！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;聊天记录备份&quot;&gt;&lt;a href=&quot;#聊天记录备份&quot; class=&quot;headerlink&quot; title=&quot;聊天记录备份&quot;&gt;&lt;/a&gt;聊天记录备份&lt;/h2&gt;&lt;p&gt;在通过电脑版微信备份数据的时候，提示 “当前网络状况复杂，请尝试使用其它网络”，说明微信电脑版备份失败，这是什么原因呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="微信" scheme="http://www.kangxh.xyz/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Chrome的Software Reporter Tool长时间占用CPU解决办法</title>
    <link href="http://www.kangxh.xyz/2020/07/07/Chrome%E7%9A%84Software-Reporter-Tool%E9%95%BF%E6%97%B6%E9%97%B4%E5%8D%A0%E7%94%A8CPU%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://www.kangxh.xyz/2020/07/07/Chrome%E7%9A%84Software-Reporter-Tool%E9%95%BF%E6%97%B6%E9%97%B4%E5%8D%A0%E7%94%A8CPU%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2020-07-07T12:39:43.000Z</published>
    <updated>2021-02-19T04:49:59.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是Software-Reporter-Tool"><a href="#什么是Software-Reporter-Tool" class="headerlink" title="什么是Software Reporter Tool"></a>什么是Software Reporter Tool</h2><p>Software Reporter Tool是一个Chrome清理工具,用于清理谷歌浏览器中不必要或恶意的扩展，应用程序，劫持开始页面等等。当你安装Chrome时，Software_reporter_tool.exe也j就会被下载在SwReporter文件夹下的Chrome应用数据文件夹中。</p><a id="more"></a><h2 id="如何关闭SRT"><a href="#如何关闭SRT" class="headerlink" title="如何关闭SRT"></a>如何关闭SRT</h2><p>这个软件在运行的过程中可能会长时间地占用CPU，导致高CPU使用率。我们虽然可以通过任务管理器手动结束进程或者选择删除SRT，但这都不是长久的解决办法。因为前者过一段时间它又会再次运行，后者在浏览器更新的时候就又会重新被下载下来。要完美地解决这一个问题我们可以进入SRT目录，默认它位于以下目录</p><p>C:\Users[YourName]\AppData\Local\Google\Chrome\User Data\SwReporter[版本]\software_reporter_tool.exe</p><p>我们还可以通过<code>win+r</code>键打开运行命令窗口并输入以下命令快速找到它</p><p>%localappdata%\Google\Chrome\User Data\SwReporter</p><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20200707204417.png" alt></p><ul><li>右键单击software_reporter_tool.exe选择属性</li><li>转到“安全”选项卡</li><li>点击“高级”</li><li>点击“禁用继承”</li><li>选择”从此对象中删除所有继承的权限”,之后一路点击“确定”“确定”。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Software-Reporter-Tool&quot;&gt;&lt;a href=&quot;#什么是Software-Reporter-Tool&quot; class=&quot;headerlink&quot; title=&quot;什么是Software Reporter Tool&quot;&gt;&lt;/a&gt;什么是Software Reporter Tool&lt;/h2&gt;&lt;p&gt;Software Reporter Tool是一个Chrome清理工具,用于清理谷歌浏览器中不必要或恶意的扩展，应用程序，劫持开始页面等等。当你安装Chrome时，Software_reporter_tool.exe也j就会被下载在SwReporter文件夹下的Chrome应用数据文件夹中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="chrome" scheme="http://www.kangxh.xyz/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>网页转化为markdown</title>
    <link href="http://www.kangxh.xyz/2020/02/28/%E7%BD%91%E9%A1%B5%E8%BD%AC%E5%8C%96%E4%B8%BAmarkdown/"/>
    <id>http://www.kangxh.xyz/2020/02/28/%E7%BD%91%E9%A1%B5%E8%BD%AC%E5%8C%96%E4%B8%BAmarkdown/</id>
    <published>2020-02-28T07:06:55.000Z</published>
    <updated>2021-02-19T04:49:41.505Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网页只需要选中内容，右键复制 然后粘贴到 markdown工具Typora中即可保留原格式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网页" scheme="http://www.kangxh.xyz/tags/%E7%BD%91%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>加速访问Github</title>
    <link href="http://www.kangxh.xyz/2020/02/26/speed-github/"/>
    <id>http://www.kangxh.xyz/2020/02/26/speed-github/</id>
    <published>2020-02-26T07:06:55.000Z</published>
    <updated>2021-02-19T04:46:26.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="说一下访问慢的原因"><a href="#说一下访问慢的原因" class="headerlink" title="说一下访问慢的原因"></a>说一下访问慢的原因</h1><ol><li>由于 github.com 网站位于美国旧金山,所以初始访问 github.com 时网络寻址会比较耗费时间,这是网站打开速度慢的其中一个原因.</li><li>最初用户从浏览器中输入 github.com 网址时,浏览器并不知道这个域名对应的真实 ip 地址,先问问自己电脑认识不认识这个域名的门牌号,如果本机不认识会接着往上问,当地运行商也不认识这个域名的话,继续问上级,直到问出来 github.com 的门牌号是 192.30.253.113 为止!如此繁琐的问路过程被称之为 DNS 寻址,如果问路的时间都占用很久,那么访问网站的速度自然会很慢.</li></ol><h2 id="主域名和多个子域名"><a href="#主域名和多个子域名" class="headerlink" title="主域名和多个子域名"></a>主域名和多个子域名</h2><p>正常来说,网站的主域名下会存在多个子域名,由这些域名组合在一起提供完整的服务.</p><p>而 github.com 也不例外,其中 github.com是一级域名,也是主域名,其他的域名基本上都是二级域名或者说次域名. 所以我们不仅要告诉本机 github.com 的主域名,还要把相关的子域名也告诉本机,帮人帮到底,送福送到西! 那到哪里去查询域名和 ip 的对应关系呢?</p><a id="more"></a><h2 id="推荐几个查询域名解析的网站"><a href="#推荐几个查询域名解析的网站" class="headerlink" title="推荐几个查询域名解析的网站"></a>推荐几个查询域名解析的网站</h2><ol><li><a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a></li><li><a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">http://tool.chinaz.com/dns/</a></li></ol><h2 id="体验域名查询"><a href="#体验域名查询" class="headerlink" title="体验域名查询"></a>体验域名查询</h2><p>根据查到的相关域名信息,再次查询出这些域名对应的 ip 地址,于是整理出以下内容.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#github related website</span><br><span class="line">192.30.253.113 github.com</span><br><span class="line">199.232.5.194 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">192.30.253.120 nodeload.github.com</span><br><span class="line">199.232.28.133 raw.github.com</span><br><span class="line">140.82.113.17 training.github.com</span><br><span class="line">192.30.253.113 www.github.com</span><br><span class="line">99.232.68.133 avatars0.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133 assets-cdn.github.com</span><br><span class="line">185.199.108.153 documentcloud.github.com</span><br><span class="line">185.199.108.153 help.github.com</span><br><span class="line">18.204.240.114 status.github.com</span><br></pre></td></tr></table></figure><h2 id="加快访问github的方法"><a href="#加快访问github的方法" class="headerlink" title="加快访问github的方法"></a>加快访问github的方法</h2><ol><li>VPN<ol><li>购买vpn，作为学生党就算了吧</li><li>使用一些免费的插件，这种就得自个搜（提醒：谷歌商店一大批免费的，哈哈哈）</li></ol></li><li>hosts<ol><li>记事本打开C:\Windows\System32\drivers\etc 路径下的hosts文件（映射文件）</li><li>找到上面推荐的解析网站  查询出自个机子适用的dns解析地址（也可以使用我整理好的）</li><li>保存退出（不能保存的请自行百度）</li><li>win+r 输入ipconfig /flushdns 刷新dns缓存</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说一下访问慢的原因&quot;&gt;&lt;a href=&quot;#说一下访问慢的原因&quot; class=&quot;headerlink&quot; title=&quot;说一下访问慢的原因&quot;&gt;&lt;/a&gt;说一下访问慢的原因&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;由于 github.com 网站位于美国旧金山,所以初始访问 github.com 时网络寻址会比较耗费时间,这是网站打开速度慢的其中一个原因.&lt;/li&gt;
&lt;li&gt;最初用户从浏览器中输入 github.com 网址时,浏览器并不知道这个域名对应的真实 ip 地址,先问问自己电脑认识不认识这个域名的门牌号,如果本机不认识会接着往上问,当地运行商也不认识这个域名的话,继续问上级,直到问出来 github.com 的门牌号是 192.30.253.113 为止!如此繁琐的问路过程被称之为 DNS 寻址,如果问路的时间都占用很久,那么访问网站的速度自然会很慢.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;主域名和多个子域名&quot;&gt;&lt;a href=&quot;#主域名和多个子域名&quot; class=&quot;headerlink&quot; title=&quot;主域名和多个子域名&quot;&gt;&lt;/a&gt;主域名和多个子域名&lt;/h2&gt;&lt;p&gt;正常来说,网站的主域名下会存在多个子域名,由这些域名组合在一起提供完整的服务.&lt;/p&gt;
&lt;p&gt;而 github.com 也不例外,其中 github.com是一级域名,也是主域名,其他的域名基本上都是二级域名或者说次域名. 所以我们不仅要告诉本机 github.com 的主域名,还要把相关的子域名也告诉本机,帮人帮到底,送福送到西! 那到哪里去查询域名和 ip 的对应关系呢?&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="github" scheme="http://www.kangxh.xyz/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>蓝奏云上传大于100m文件</title>
    <link href="http://www.kangxh.xyz/2020/02/26/%E8%93%9D%E5%A5%8F%E4%BA%91%E4%B8%8A%E4%BC%A0%E5%A4%A7%E4%BA%8E100M%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://www.kangxh.xyz/2020/02/26/%E8%93%9D%E5%A5%8F%E4%BA%91%E4%B8%8A%E4%BC%A0%E5%A4%A7%E4%BA%8E100M%E7%9A%84%E6%96%87%E4%BB%B6/</id>
    <published>2020-02-26T07:06:55.000Z</published>
    <updated>2021-02-19T04:48:45.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><strong>用压缩软件分卷压缩</strong></li><li><strong>把每一卷的后缀名改为.doc</strong></li><li><strong>每一卷进行上传</strong></li></ul><p><img src="https://gitee.com/LYmystery/PicGo/raw/master/image/20210216134836.png" alt="image-20210216134829509"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="技术" scheme="http://www.kangxh.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="http://www.kangxh.xyz/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
</feed>
