<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8" />
  <meta name="description" content="记录学习生活的点点滴滴" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    C语言面试题4 |  Mysterious Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  <link rel="shortcut icon" href="/favicon.ico" />
<link rel="stylesheet" href="/dist/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
<link rel="stylesheet" href="/css/custom.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
<link rel="alternate" href="/atom.xml" title="Mysterious Blog" type="application/atom+xml">
</head>
</html>
<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article
  id="post-C语言面试题4"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    <header class="article-header">
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  C语言面试题4
</h1>
    </header>
    <div class="article-meta">
      <a href="/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%984/" class="article-date">
  <time datetime="2021-03-09T13:14:02.305Z" itemprop="datePublished">2021-03-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">25k</span>
        </span>
    </span>
    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">105 min</span>
        </span>
    </span>
</div>
    </div>
    <div class="article-entry" itemprop="articleBody">
  <p>1 预处理<br>问题1：什么是预编译？何时需要预编译？<br>答：<br>预编译又称预处理，是整个编译过程最先做的工作，即程序执行前的一些预处理工作。主要处理#开头的指令。如拷贝#include包含的文件代码、替换#define定义的宏、条件编译#if等。.<br>何时需要预编译：<br>1、总是使用不经常改动的大型代码体。<br>2、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。<br>问题2：写一个“标准”宏，这个宏输入两个参数并返回较小的一个<br>答:#define MIN(x, y) ((x)&lt;(y)?(x):(y)) //结尾没有;<br>问题3：#与##的作用？<br>答：#是把宏参数转化为字符串的运算符，##是把两个宏参数连接的运算符。<br>例如：<br>#define STR(arg) #arg      则宏STR(hello)展开时为”hello”<br>#define NAME(y) name_y    则宏NAME(1)展开时仍为name_y<br>#define NAME(y) name_##y   则宏NAME(1)展开为name_1<br>#define DECLARE(name, type) typename##_##type##_type，<br>则宏DECLARE(val, int)展开为int val_int_type<br>问题4：如何避免头文件被重复包含？<br>答：<br>例如，为避免头文件my_head.h被重复包含，可在其中使用条件编译：<br>#ifndef _MY_HEAD_H<br>#define _MY_HEAD_H   /<em>空宏</em>/<br>/<em>其他语句</em>/<br>#endif<br>2 关键字<br>问题1：static关键字的作用？<br>答：<br>Static的用途主要有两个，一是用于修饰存储类型使之成为静态存储类型，二是用于修饰链接属性使之成为内部链接属性。<br>1静态存储类型：<br>在函数内定义的静态局部变量，该变量存在内存的静态区，所以即使该函数运行结束，静态变量的值不会被销毁，函数下次运行时能仍用到这个值。<br>在函数外定义的静态变量——静态全局变量，该变量的作用域只能在定义该变量的文件中，不能被其他文件通过extern引用。<br>2 内部链接属性<br>    静态函数只能在声明它的源文件中使用。<br>问题2：const关键字的作用？<br>答：<br>1声明常变量，使得指定的变量不能被修改。<br>const int a = 5;/<em>a的值一直为5，不能被改变</em>/<br>const int b; b = 10;/<em>b的值被赋值为10后，不能被改变</em>/<br>const int <em>ptr; /*ptr为指向整型常量的指针，ptr的值可以修改，但不能修改其所指向的值</em>/<br>int <em>const ptr;/*ptr为指向整型的常量指针，ptr的值不能修改，但可以修改其所指向的值</em>/<br>const int <em>const ptr;/*ptr为指向整型常量的常量指针，ptr及其指向的值都不能修改</em>/<br>2修饰函数形参，使得形参在函数内不能被修改，表示输入参数。<br>如int fun(const int a);或int fun(const char <em>str);<br>3修饰函数返回值，使得函数的返回值不能被修改。<br>const char <em>getstr(void);使用：const *str= getstr();<br>const int getint(void);  使用：const int a =getint();<br>问题3：volatile关键字的作用？<br>答：<br>volatile指定的关键字可能被系统、硬件、进程/线程改变，强制编译器每次从内存中取得该变量的值，而不是从被优化后的寄存器中读取。例子:硬件时钟;多线程中被多个任务共享的变量等。<br>问题4：extern关键字的作用？<br>答：<br>1用于修饰变量或函数，表明该变量或函数都是在别的文件中定义的，提示编译器在其他文件中寻找定义。<br>extern int a;<br>extern int *p;<br>extern int array[];<br>extern void fun(void);<br>其中，在函数的声明带有关键字extern，仅仅是暗示这个函数可能在别的源文件中定义，没有其他作用。如：<br>头文件A：A_MODULE.h中包含<br>extern int func(int a, int b);<br>源文件A: A_MODULE.c中<br>#include “A_MODULE.h”<br>int func(int a, int b)<br>{<br>     returna+b;<br>}<br>此时，展开头文件A_MODULE.h后，为<br>extern int func(int a, int b);/</em>虽然暗示可能在别的源文件中定义，但又在本文件中定义，所以extern并没有起到什么作用，但也不会产生错误</em>/<br>int func(int a, int b)<br>{<br>     returna+b;<br>}<br>而源文件B：B_MODULE.c中，<br>#include “A_MODULE.h”<br>int ret = func(10,5);/<br>展开头文件A_MODULE.h后，为<br>extern int func(int a, int b);/<em>暗示在别的源文件中定义，所以在下面使用func(5,10)时，在链接的时候到别的目标文件中寻找定义</em>/<br>int ret = func(10,5);<br>2 用于extern “c<br>extern “c”的作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的编译方式进行编译，而不是C++的。<br>C++作为一种与C兼容的语言，保留了一部分面向过程语言的特点，如可以定义不属于任何类的全局变量和函数，但C++毕竟是一种面向对象的语言，为了支持函数的重载，对函数的编译方式与C的不同。例如，在C++中，对函数void fun(int,int)编译后的名称可能是_fun_int_int，而C中没有重载机制，一般直接利用函数名来指定编译后函数的名称，如上面的函数编译后的名称可能是_fun。<br>这样问题就来了，如果在C++中调用的函数如上例中的fun(1,2)是用C语言在源文件a_module.c中实现和编译的，那么函数fun在目标文件a_module.obj中的函数名为_fun，而C++在源文件b_module.cpp通过调用其对外提供的头文件a_module.h引用后，调用fun，则直接以C++的编译方式来编译，使得fun编译后在目标文件b_module.obj的名称为_fun_int_int，这样在链接的时候，因为_fun_int_int的函数在目标文件a_module.obj中不存在，导致了链接错误。<br>解决方法是让b_module.cpp知道函数fun是用C语言实现和编译了，在调用的时候，采用与C语言一样的方式来编译。该方法可以通过extern “C”来实现（具体用法见下面）。一般，在用C语言实现函数的时候，要考虑到这个函数可能会被C++程序调用，所以在设计头文件时，应该这样声明头文件：<br>/<em>头文件a_module.h</em>/<br>/<em>头文件被CPP文件include时，CPP文件中都含有该自定义的宏__cplusplus</em>/<br>/<em>这样通过extern “C”告诉C++编译器，extern “C”{}里包含的函数都用C的方式来编译</em>/<br>#ifdef <strong>cplusplus<br>extern “C”<br>{<br>#endif<br>extern void fun(int a, int b);<br>#ifdef __cplusplus<br>}<br>#endif<br>extern “C”的使用方式<br>\1. 可以是单一语句<br>  extern “C” doublesqrt(double);<br>\2. 可以是复合语句, 相当于复合语句中的声明都加了extern “C”<br>  extern “C”<br>  {<br>    double sqrt(double);<br>    int min(int, int);<br>  }<br>3.可以包含头文件，相当于头文件中的声明都加了extern”C”<br>  extern “C”<br>  {<br>    #include <cmath><br> }<br>\4. 不可以将extern”C” 添加在函数内部<br>\5. 如果函数有多个声明，可以都加extern”C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。<br>\6. 除extern”C”, 还有extern “FORTRAN” 等。<br>问题5：sizeof关键字的作用？<br>答：<br>sizeof是在编译阶段处理，且不能被编译为机器码。sizeof的结果等于对象或类型所占的内存字节数。sizeof的返回值类型为size_t。<br>变量：int a;  sizeof(a)为4；<br>指针：int <em>p;  sizeof(p)为4；<br>数组：int b[10]; sizeof(b)为数组的大小，4<em>10；int c[0]; sizeof(c)等于0<br>结构体：struct (int a; char ch;)s1; sizeof(s1)为8 与结构体字节对齐有关。<br>注意：不能对结构体中的位域成员使用sizeof<br>sizeof(void)等于1<br>sizeof(void *)等于4<br>3 结构体<br>问题1：结构体的赋值？<br>答：<br>C语言中对结构体变量的赋值或者在初始化或者在定义后按字段赋值。<br>方式1：初始化<br>struct tag<br>{<br>   chara;<br>  int b;<br>}x = {‘A’, 1};/</em>初始化</em>/<br>或<br>struct tag<br>{<br>char a;<br>int b;<br>};<br>struct tag x = {‘A’,1};/<em>在定义变量时初始化</em>/<br>GNU C中可使用另外一种方式：<br>struct tag<br>{<br>char a;<br>int b;<br>}x =<br>{<br>.a = ‘A’,<br>.b =1;<br>};<br>或<br>struct tag<br>{<br>char a;<br>int b;<br>};<br>struct tag x =<br>{<br>   .a= ‘A’,<br>  .b=1,<br>};<br>方式2：定义变量后按字段赋值<br>struct tag<br>{<br>char a;<br>int b;<br>};<br>struct tag x;/<em>定义变量</em>/<br>x.a = ‘A’;/<em>按字段赋值</em>/<br>x.b = 1; /<em>按字段赋值</em>/<br>而当你使用初始化的方式来赋值时，如x = {‘A’,1};则出错。<br>方式3：结构变量间的赋值<br>struct tag<br>{<br>   chara;<br>  int b;<br>};<br>struct tag x,y;<br>x.a=’A’;<br>x.b=1;<br>y = x;/<em>结构变量间直接赋值</em>/<br>问题2：结构体变量如何比较？<br>答：虽然结构体变量之间可以通过=直接赋值，但不同通过比较符如==来比较，因为比较符只作用于基本数据类型。这个时候，只能通过int memcmp(const void <em>s1, const void <em>s2, size_t n);来进行内存上的比较。<br>问题3：结构体位域<br>答：<br>位域是一个或多个位的字段，不同长度的字段（如声明为unsigned int类型）存储于一个或多个其所声明类型的变量中（如整型变量中）。<br>位域的类型：可以是char、short、int，多数使用int，使用时最好带上signed或unsigned<br>位域的特点：字段可以不命名，如unsignedint :1;可用来填充；unsigned int :0; 0宽度用来强制在下一个整型（因此处是unsigned int类型）边界上对齐。<br>位域的定义：<br>struct st1<br>{<br>unsigned chara:7;/</em>字段a占用了一个字节的7个bit</em>/<br>unsigned charb:2;/<em>字段b占用了2个bit</em>/<br>unsigned charc:7;/<em>字段c占用了7个bit</em>/<br>}s1;<br>sizeof(s1)等于3。因为一个位域字段必须存储在其位域类型的一个单元所占空间中,不能横跨两个该位域类型的单元。也就是说，当某个位域字段正处于两个该位域类型的单元中间时，只使用第二个单元，第一个单元剩余的bit位置补（pad）0。<br>于是可知Sizeof(s2)等于3<em>sizeof(int)即12<br>struct st2<br>{<br>unsigned inta:31;<br>unsigned intb:2;/*前一个整型变量只剩下1个bit，容不下2个bit，所以只能存放在下一个整型变量</em>/<br>unsigned int c:31;<br>}s2;<br>位域的好处：<br>    1.有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态，用一位二进位即可。这样节省存储空间，而且处理简便。这样就可以把几个不同的对象用一个字节的二进制位域来表示。<br>    2.可以很方便的利用位域把一个变量给按位分解。比如只需要4个大小在0到3的随即数，就可以只rand()一次，然后每个位域取2个二进制位即可，省时省空间。<br>位域的缺点：<br>不同系统对位域的处理可能有不同的结果，如位段成员在内存中是从左向右分配的还是从右向左分配的，所以位域的使用不利于程序的可移植性。<br>问题4：结构体成员数组大小为0<br>结构体数组成员的大小为0是GNU C的一个特性。好处是可以在结构体中分配不定长的大小。如<br>typedef struct st<br>{<br>    inta;<br>int b;<br>char c[0];<br>}st_t;<br>sizeof(st_t)等于8，即char c[0]的大小为0.<br>#define SIZE 100<br>st_t *s = (st_t *)malloc(sizeof(st_t) + SIZE);<br>4 函数<br>问题1：函数参数入栈顺序<br>答：<br>C语言函数参数入栈顺序是从右向左的，这是由编译器决定的，更具体的说是函数调用约定决定了参数的入栈顺序。C语言采用是函数调用约定是</cmath></strong>cdecl的，所以对于函数的声明，完整的形式是：int __cdecl func(int a, int b);<br>问题2：inline内联函数<br>答：<br>inline关键字仅仅是建议编译器做内联展开处理，即是将函数直接嵌入调用程序的主体，省去了调用/返回指令。<br>5 内存分配回收<br>问题1： malloc/free与new/delete的区别<br>答：</p>
<p>1) malloc与free是C/C++语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>2) 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。<br>我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。<br>3) 既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。<br>如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。<br>问题2：malloc(0)返回值<br>答：如果请求的长度为0，则标准C语言函数malloc返回一个null指针或不能用于访问对象的非null指针，该指针能被free安全使用。<br>6 可变参数列表<br>可变参数列表是通过宏来实现的，这些宏定义在stdarg.h头文件，它是标准库的一部分。这个头文件声明了一个类型va_list和三个宏：va_start、va_arg和va_end。<br>typedef char <em>va_list;<br>#define va_start(ap, A)  (void)((ap) = (char *)&amp;(A) + _Bnd(A, _AUPBND))<br>#define va_arg(ap, T)  (</em>(T )((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND)))<br>#define va_end(ap) (void)0<br>int print(char <em>format, …)<br>宏va_start的第一个参数是va_list类型的变量，第二个参数是省略号前最后一个有名字的参数，功能是初始化va_list类型的变量，将其值设置为可变参数的第一个变量。<br>宏va_arg的第一个参数是va_list类型的变量，第二个参数是参数列表的下一个参数的类型。va_arg返回va_list变量的值，并使该变量指向下一个可变参数。<br>宏va_end是在va_arg访问完最后一个可变参数之后调用的。<br>问题1：实现printf函数<br>/*（转载）<br> \</em> A simple printf function. Only support the following format:<br> * Code Format<br> * %c character<br> * %d signed integers<br> * %i signed integers<br> * %s a string of characters<br> * %o octal<br> * %x unsigned hexadecimal<br> <em>/<br>int my_printf( const char</em> format, …)<br>{<br>  va_list arg;<br>  int done = 0;<br>  va_start (arg, format);<br>  while( <em>format != ‘\0’)<br>  {<br>    if( *format == ‘%’)<br>    {<br>      if( *(format+1) == ‘c’ )<br>      {<br>        char c = (char)va_arg(arg, int);<br>        putc(c, stdout);<br>      } else if( *(format+1) == ‘d’ || *(format+1) == ‘i’)<br>      {<br>        char store[20];<br>        int i = va_arg(arg, int);<br>        char</em> str = store;<br>        itoa(i, store, 10);<br>        while( <em>str != ‘\0’) putc(*str++, stdout);<br>      } else if( *(format+1) == ‘o’)<br>      {<br>        char store[20];<br>        int i = va_arg(arg, int);<br>        char</em> str = store;<br>        itoa(i, store, 8);<br>        while( <em>str != ‘\0’) putc(*str++, stdout);<br>      } else if( *(format+1) == ‘x’)<br>      {<br>        char store[20];<br>        int i = va_arg(arg, int);<br>        char</em> str = store;<br>        itoa(i, store, 16);<br>        while( <em>str != ‘\0’) putc(*str++, stdout);<br>      } else if( *(format+1) == ‘s’ )<br>      {<br>        char</em> str = va_arg(arg, char<em>);<br>        while( <em>str != ‘\0’) putc(</em>str++, stdout);<br>      }<br>      // Skip this two characters.<br>      format += 2;<br>    } else {<br>      putc(*format++, stdout);<br>    }<br>  }<br>  va_end (arg);<br>  return done;<br>}<br>7 其他<br>问题1：ASSERT()的作用<br>答:ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。例如，变量n在程序中不应该为0，如果为0可能导致错误，你可以这样写程序：<br>……<br>ASSERT( n != 0);<br>k = 10/ n;<br>…..<br>ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。<br>assert()的功能类似，它是ANSI C标准中规定的函数，它与ASSERT的一个重要区别是可以用在Release版本中。<br>问题2：system(“pause”);的作用<br>答:系统的暂停程序，按任意键继续，屏幕会打印，”按任意键继续。。。。。”省去了使用getchar（）；<br>问题3：请问C++的类和C里面的struct有什么区别？<br>答:c++中的类具有成员保护功能，并且具有继承，多态这类oo特点，而c里的struct没有。c里面的struct没有成员函数,不能继承,派生等等.<br>8 找错题<br>试题1：<br>void test1()<br>{<br>　　char string[10];<br>　　char</em> str1 = “0123456789”;<br>　　strcpy(string, str1);<br>}<br>解答：字符串str1有11个字节（包括末尾的结束符’\0’），而string只有10个字节，故而strcpy会导致数组string越界。<br>试题2：<br>void test2()<br>{<br>　　char string[10], str1[10];<br>　　int i;<br>　　for(i=0; i&lt;10; i++)<br>　　{<br>　　  str1= ‘a’;<br>　　}<br>　　strcpy(string, str1);<br>}<br>解答：因为str1没有结束符’\0’，故而strcpy复制的字符数不确定。strcpy源码如下：<br>[cpp] view plain copy<br>#include &lt;string.h&gt;<br>char <em>strcpy(char <em>s1, cosnt char *s2)<br>{<br>  char *s = s1;<br>  for (s = s1; (</em>s++ = <em>s2++) != ‘\0’;)/</em>最后的结束符’\0’也会被复制</em>/<br>    ;<br>  return s1;<br>}<br>试题3：<br>void test3(char* str1)<br>{<br>　　char string[10];<br>　　if(strlen(str1) &lt;= 10 )<br>　　{<br>　　  strcpy(string, str1);<br>　　}<br>}<br>解答：应修改为if (strlen(str1) &lt; 10)，因为strlen的结果未统计最后的结束符’\0’。strlen的源码如下：<br>[cpp] view plain copy<br>#include &lt;string.h&gt;<br>size_t strlen(const char <em>s)<br>{<br>  const char <em>sc;<br>  for (sc = s; *sc != ‘\0’; ++sc)/</em>不包含最后的结束符’\0’</em>/<br>    ;<br>  return (sc - s);<br>}<br>试题4：<br>void GetMemory(char <em>p)<br>{<br>　　p = (char <em>)malloc( 100 );<br>}<br>void Test( void )<br>{<br>　 char *str = NULL;<br>　 GetMemory(str);<br>　 strcpy(str,”hello world”);<br>　 printf(str);<br>}<br>解答：C语言中的函数参数为传值参数，在函数内对形参的修改并不能改变对应实参的值。故而调用GetMemory后，str仍为NULL。<br>试题5：<br>char *GetMemory( void )<br>{<br>　　char p[] = “hello world”;<br>　　return p;<br>}<br>void Test( void )<br>{<br>　　char *str = NULL;<br>　　str = GetMemory();<br>　　printf(str);<br>}<br>解答：GetMemory中，p为局部变量，在函数返回后，该局部变量被回收。故而str仍为NULL<br>试题6：<br>void GetMemory( char *</em>p, int num )<br>{<br>　　<em>p = (char *)malloc(num);<br>}<br>void Test( void )<br>{<br>　　char *str = NULL;<br>　　GetMemory(&amp;str, 100);<br>　　strcpy(str, “hello”);<br>　　printf(str);<br>}<br>解答：试题6避免了试题4的问题，但在GetMemory内，未对</em>p为NULL情况的判断。当*p不为NULL时，在printf后，也未对malloc的空间进行free<br>试题7：<br>void Test( void )<br>{<br>　　char *str = (char *)malloc( 100 );<br>　　strcpy(str, “hello” );<br>　　free(str);<br>　　… //省略的其它语句<br>}<br>解答：未对str为NULL的情况的判断，在free(str)后，str未设置为NULL，可能变成一个野指针（后面对str的操作可能会导致踩内存）。<br>试题8：<br>swap(int</em> p1,int* p2)<br>{<br>　　int <em>p;<br>　　*p = *p1;<br>　　*p1 = *p2;<br>　　*p2 = *p;<br>}<br>解答：在swap函数中，p是个野指针，可能指向系统区，导致程序运行的崩溃。故而，程序应改为：<br>swap(int</em> p1,int* p2)<br>{<br>　　int p;<br>　　p = *p1;<br>　　*p1 = *p2;<br>　　*p2 = p;<br>}<br>9 编程题<br>题1：判断字符串str2是否在字符串str1里。<br>[cpp] view plain copy<br>#include &lt;stdio.h&gt;  </p>
<p>#define OK   1<br>#define ERROR 0  </p>
<p>int str_str(const char *str1, const char *str2)<br>{<br>  const char *s1 = NULL;<br>  const char *s2 = NULL;  </p>
<p>  if (str1 == NULL)<br>  {<br>    return (str2 == NULL) ? OK : ERROR;<br>  }  </p>
<p>  if (str2 == NULL)<br>  {<br>    return OK;<br>  }  </p>
<p>  for (; <em>str1 != ‘\0’; str1++)<br>  {<br>    if (*str1 == *str2)<br>    {<br>      for (s1 = str1, s2 = str2; ; )<br>      {<br>        if (</em>++s2 == ‘\0’)<br>        {<br>          return OK;<br>        }<br>        else if (*++s1 != *s2)<br>        {<br>          break;<br>        }<br>      }<br>    }<br>  }  </p>
<p>  return ERROR;<br>}<br>转自：<a href="http://blog.csdn.net/lincoln_2012/article/details/49179503" target="_blank" rel="noopener">http://blog.csdn.net/lincoln_2012/article/details/49179503</a><br>﻿﻿<br>C语言面试宝典<br>第一部分：基本概念及其它问答题<br>1、关键字static的作用是什么？<br>这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：<br>1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。<br>大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数<br>据和代码范围的好处和重要性。</p>
<p>2、“引用”与指针的区别是什么？<br>答 、1) 引用必须被初始化，指针不必。<br>2) 引用初始化以后不能被改变，指针可以改变所指的对象。<br>3) 不存在指向空值的引用，但是存在指向空值的指针。<br>指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。<br>流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用</p>
<p>3、.h头文件中的ifndef/define/endif 的作用？<br>答：防止该头文件被重复引用。</p>
<p>4、#include&lt;file.h&gt; 与 #include “file.h”的区别？<br>答：前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。</p>
<p>5、描述实时系统的基本特性<br>答 ：在特定时间内完成特定的任务，实时性与可靠性。</p>
<p>6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？<br>答 ：全局变量储存在静态数据区，局部变量在堆栈中。</p>
<p>7、什么是平衡二叉树？<br>答 ：左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。</p>
<p>8、堆栈溢出一般是由什么原因导致的？<br>答 ：1.没有回收垃圾资源<br>    2.层次太深的递归调用</p>
<p>9、冒泡排序算法的时间复杂度是什么？<br>答 ：O(n^2)<br>10、什么函数不能声明为虚函数？<br>答：constructor</p>
<p>11、队列和栈有什么区别？<br>答：队列先进先出，栈后进先出</p>
<p>12、不能做switch()的参数类型<br>答 ：switch的参数不能为实型。</p>
<p>13、局部变量能否和全局变量重名？<br>答：能，局部会屏蔽全局。要用全局变量，需要使用”::”<br>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</p>
<p>14、如何引用一个已经定义过的全局变量？<br>答 、可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</p>
<p>15、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？<br>答 、可以，在不同的C文件中以static形式来声明同名全局变量。<br>可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。</p>
<p>16、语句for( ；1 ；)有什么问题？它是什么意思？<br>答 、和while(1)相同，无限循环。</p>
<p>17、do……while和while……do有什么区别？<br>答 、前一个循环一遍再判断，后一个判断以后再循环。</p>
<p>18、statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数<br>static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？<br>答 、全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。<br>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。<br>static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件<br>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;<br>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；<br>static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p>
<p>19、程序的内存分配<br>答：一个由c/C++编译的程序占用的内存分为以下几个部分<br>1、栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。<br>3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区—存放函数体的二进制代码</p>
<p>例子程序<br>这是一个前辈写的，非常详细<br>//main.cpp<br> int a=0;   //全局初始化区<br> char <em>p1;  //全局未初始化区<br> main()<br> {<br>  intb;栈<br>  char s[]=”abc”;  //栈<br>  char *p2;     //栈<br>  char *p3=”123456”;  //123456\0在常量区，p3在栈上。<br>  static int c=0；  //全局（静态）初始化区<br>  p1 = (char</em>)malloc(10);<br>  p2 = (char*)malloc(20);  //分配得来得10和20字节的区域就在堆区。<br>  strcpy(p1,”123456”);  //123456\0放在常量区，编译器可能会将它与p3所向”123456”优化成一个地方。<br>}</p>
<p>20、解释堆和栈的区别<br>答：堆（heap）和栈(stack)的区别<br>（1）申请方式<br>stack:由系统自动分配。例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间<br>heap:需要程序员自己申请，并指明大小，在c中malloc函数<br>如p1=(char<em>)malloc(10);<br>在C++中用new运算符<br>如p2=(char</em>)malloc(10);<br>但是注意p1、p2本身是在栈中的。<br>（2）申请后系统的响应<br>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，<br>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。<br>（3）申请大小的限制<br>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br>（4）申请效率的比较：<br>栈:由系统自动分配，速度较快。但程序员是无法控制的。<br>堆:是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br>另外，在WINDOWS下，最好的方式是用Virtual Alloc分配内存，他不是在堆，也不是在栈,而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。<br>（5）堆和栈中的存储内容<br>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。<br>（6）存取效率的比较<br>char s1[]=”aaaaaaaaaaaaaaa”;<br>char *s2=”bbbbbbbbbbbbbbbbb”;<br>aaaaaaaaaaa是在运行时刻赋值的；<br>而bbbbbbbbbbb是在编译时就确定的；<br>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。<br>比如：<br>#include<br>voidmain()<br>{<br>char a=1;<br>char c[]=”1234567890”;<br>char *p=”1234567890”;<br>a = c[1];<br>a = p[1];<br>return;<br>}<br>对应的汇编代码<br>10:a=c[1];<br>004010678A4DF1movcl,byteptr[ebp-0Fh]<br>0040106A884DFCmovbyteptr[ebp-4],cl<br>11:a=p[1];<br>0040106D8B55ECmovedx,dwordptr[ebp-14h]<br>004010708A4201moval,byteptr[edx+1]<br>004010738845FCmovbyteptr[ebp-4],al<br>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。<br>21、什么是预编译,何时需要预编译?<br>答：预编译又称为预处理,是做些代码文本的替换工作。处理#开头的指令,比如拷贝#include包含的文件代码，#define宏定义的替换,条件编译等，就是为编译做的预备工作的阶段，主要处理#开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。<br>c编译系统在对程序进行通常的编译之前，先进行预处理。c提供的预处理功能主要有以下三种：1）宏定义　2）文件包含　3）条件编译</p>
<p>1、 总是使用不经常改动的大型代码体。<br>２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。</p>
<p>22、关键字const是什么含意？<br>答：我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？<br>const int a;<br>int const a;<br>const int *a;<br>int * const a;<br>int const * a const;<br>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：<br>1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）<br>2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。<br>3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现</p>
<p>23、关键字volatile有什么含意 并给出三个不同的例子。<br>答：一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：<br>1). 并行设备的硬件寄存器（如：状态寄存器）<br>2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)<br>3). 多线程应用中被几个任务共享的变量<br>回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。<br>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。<br>1). 一个参数既可以是const还可以是volatile吗？解释为什么。<br>2). 一个指针可以是volatile 吗？解释为什么。<br>3). 下面的函数有什么错误：<br>int square(volatile int <em>ptr)<br>{<br>return *ptr * *ptr;<br>}<br>下面是答案：<br>1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。<br>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。<br>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针</em>ptr指向值的平方，但是，由于<em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：<br>int square(volatile int *ptr)<br>{<br>int a,b;<br>a = *ptr;<br>b = *ptr;<br>return a * b;<br>}<br>由于</em>ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：<br>long square(volatile int *ptr)<br>{<br>int a;<br>a = *ptr;<br>return a * a;<br>}</p>
<p>24、三种基本的数据模型<br>答：按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。</p>
<p>25、结构与联合有和区别？<br>答：(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。<br> (2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的</p>
<p>26、描述内存分配方式以及它们的区别?<br>答：1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。<br>2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。<br>3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多</p>
<p>27、请说出const与#define 相比，有何优点？<br>答：Const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。<br>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。<br>   2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p>
<p>28、简述数组与指针的区别？<br>答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。<br>  (1)修改内容上的差别<br>   char a[] = “hello”;<br>   a[0] = ‘X’;<br>   char *p = “world”; // 注意p 指向常量字符串<br>   p[0] = ‘X’; // 编译器不能发现该错误，运行时错误<br>  (2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个 指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br>   char a[] = “hello world”;<br>   char *p = a;<br>   cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节<br>   cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节<br>   计算数组和指针的内存容量<br>   void Func(char a[100])<br>   {<br>   cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节<br>   }</p>
<p>29、分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。<br>答：BOOL :   if ( !a ) or if(a)<br>int :   if ( a == 0)<br>float :  const EXPRESSION EXP = 0.000001<br>     if ( a &lt; EXP &amp;&amp; a &gt;-EXP)<br>pointer : if ( a != NULL) or if(a == NULL)</p>
<p>30、如何判断一段程序是由C 编译程序还是由C++编译程序编译的？<br>答：#ifdef __cplusplus<br>cout&lt;&lt;”c++”;<br>#else<br>cout&lt;&lt;”c”;<br>#endif<br>31、论述含参数的宏与函数的优缺点<br>答：     带参宏          函数<br>处理时间   编译时        程序运行时<br>参数类型  没有参数类型问题    定义实参、形参类型<br>处理过程  不分配内存       分配内存<br>程序长度  变长          不变<br>运行速度  不占运行时间      调用和返回占用时间<br>32、用两个栈实现一个队列的功能？要求给出算法和思路！<br>答 、设2个栈为A,B, 一开始均为空.<br>入队:<br>将新元素push入栈A;<br>出队:<br>(1)判断栈B是否为空；<br>(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；<br>(3)将栈B的栈顶元素pop出；<br>这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好</p>
<p>33、嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？<br>答：这个问题用几个解决方案。我首选的方案是：<br>while(1)<br>{<br>}<br>一些程序员更喜欢如下方案：<br>for(;;)<br>{<br>}<br>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的<br>基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。<br>第三个方案是用 goto<br>Loop:<br>…<br>goto Loop;<br>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。</p>
<p>34、位操作（Bit manipulation）<br>答： 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。<br>对这个问题有三种基本的反应<br>1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。<br>2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。<br>3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：<br>#define BIT3 (0x1 &lt;&lt; 3)<br>static int a;<br>void set_bit3(void)<br>{<br>  a |= BIT3;<br>}<br>void clear_bit3(void)<br>{<br>  a &amp;= <del>BIT3;<br>}<br>  一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&amp;=</del>操作。</p>
<p>35、访问固定的内存位置（Accessing fixed memory locations）<br>答：嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。<br>这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：<br>  int *ptr;<br>  ptr = (int *)0x67a9;<br>  *ptr = 0xaa66;<br> A more obscure approach is:<br>一个较晦涩的方法是：<br> *(int * const)(0x67a9) = 0xaa55;<br>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p>
<p>36、中断（Interrupts）<br>答： 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 <strong>interrupt。下面的代码就使用了</strong>interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。<br>__interrupt double compute_area (double radius)<br>{<br>  double area = PI * radius * radius;<br>  printf(“\nArea = %f”, area);<br>  return area;<br>}<br>这个函数有太多的错误了，以至让人不知从何说起了：<br>1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。<br>2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。<br>3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。<br>4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。<br>37、动态内存分配（Dynamic memory allocation）<br>答：尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？<br>这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：<br>下面的代码片段的输出是什么，为什么？<br>char *ptr;<br>if ((ptr = (char *)malloc(0)) == NULL)<br>  puts(“Got a null pointer”);<br>else<br>  puts(“Got a valid pointer”);<br>  这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。<br>38、Typedef<br>答：Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：<br>#define dPS struct s *<br>typedef struct s * tPS;<br>  以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？<br>  这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：<br>dPS p1,p2;<br>tPS p3,p4;<br>第一个扩展为<br>struct s * p1, p2;<br>  上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。<br>39、用变量a给出下面的定义<br>答：a) 一个整型数（An integer）<br>b) 一个指向整型数的指针（A pointer to an integer）<br>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）<br>d) 一个有10个整型数的数组（An array of 10 integers）<br>e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）<br>f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）<br>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer<br>argument and return an integer ）</p>
<p>答案是：<br>a) int a; // An integer<br>b) int <em>a; // A pointer to an integer<br>c) int *</em>a; // A pointer to a pointer to an integer<br>d) int a[10]; // An array of 10 integers<br>e) int <em>a[10]; // An array of 10 pointers to integers<br>f) int (</em>a)[10]; // A pointer to an array of 10 integers<br>g) int (<em>a)(int); // A pointer to a function a that takes an integer argument and returns an integer<br>h) int (</em>a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p>
<p>40、解释局部变量、全局变量和静态变量的含义。<br>答：<br>41、写一个“标准”宏<br>答：交换两个参数值的宏定义为：. #define SWAP(a,b)<br> (a)=(a)+(b);<br>(b)=(a)-(b);<br>(a)=(a)-(b);<br>输入两个参数，输出较小的一个：#define MIN(A,B) ((A) &lt; (B))? (A) : (B))<br>表明1年中有多少秒（忽略闰年问题）：#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL<br>#define DOUBLE(x) x+x  与      #define DOUBLE(x) （（x）+（x））<br>i = 5<em>DOUBLE(5)； i为30      i = 5</em>DOUBLE(5)； i为50<br>已知一个数组table，用一个宏定义，求出数据的元素个数<br>#define NTBL<br>#define NTBL (sizeof(table)/sizeof(table[0]))</p>
<p>42、A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?<br>答：static的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。<br>他们都放在数据区，但是编译器对他们的命名是不同的。<br>如果要使变量在其他模块也有意义的话，需要使用extern关键字。</p>
<p>43、一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指向的节点？<br>答：将这个指针指向的next节点值copy到本节点，将next指向next-&gt;next,并随后删除原next指向的节点。<br>第二部分：程序代码评价或者找错<br>1、下面的代码输出是什么，为什么？<br>void foo(void)<br>{<br>  unsigned int a = 6;<br>  int b = -20;<br>  (a+b &gt; 6) ? puts(“&gt; 6”) : puts(“&lt;= 6”);<br>}<br>这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 “&gt;6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。<br>2、评价下面的代码片断：<br>unsigned int zero = 0;<br>unsigned int compzero = 0xFFFF;<br>/*1’s complement of zero */<br>对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：<br>unsigned int compzero = ~0;<br>  这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。<br>3、 C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？<br>int a = 5, b = 7, c;<br>c = a+++b;<br>这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：<br>c = a++ + b;<br>因此, 这段代码持行后a = 6, b = 7, c = 12。<br>如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。<br>4、设有以下说明和定义：<br>typedef union {long i; int k[5]; char c;} DATE;<br>struct data { int cat; DATE cow; double dog;} too;<br>DATE max;<br>则语句 printf(“%d”,sizeof(struct date)+sizeof(max));的执行结果是？<br>答 、结果是：52。DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20<br>data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32.<br>所以结果是 20 + 32 = 52.<br>当然…在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20</p>
<p>5、请写出下列代码的输出内容<br>#include&lt;stdio.h&gt;<br>main()<br>{<br>int a,b,c,d;<br>a=10;<br>b=a++;<br>c=++a;<br>d=10*a++;<br>printf(“b，c，d：%d，%d，%d”，b，c，d）;<br>return 0;<br>}<br>答：10，12，120</p>
<p>6、写出下列代码的输出内容<br>#include&lt;stdio.h&gt;<br>int inc(int a)<br>{<br>return(++a);<br>}<br>int multi(int<em>a,int<em>b,int</em>c)<br>{<br>return(<em>c=</em>a**b);<br>}<br>typedef int(FUNC1)(int in);<br>typedef int(FUNC2) (int</em>,int<em>,int</em>);</p>
<p>void show(FUNC2 fun,int arg1, int<em>arg2)<br>{<br>INCp=&inc;<br>int temp =p(arg1);<br>fun(&amp;temp,&amp;arg1, arg2);<br>printf(“%d\n”,</em>arg2);<br>}</p>
<p>main()<br>{<br>int a;<br>show(multi,10,&amp;a);<br>return 0;<br>}<br>答：110<br>7、请找出下面代码中的所以错误<br>说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”</p>
<p>1、#include”string.h”<br>2、main()<br>3、{<br>4、 char<em>src=”hello,world”;<br>5、 char</em> dest=NULL;<br>6、 int len=strlen(src);<br>7、 dest=(char<em>)malloc(len);<br>8、 char</em> d=dest;<br>9、 char* s=src[len];<br>10、 while(len–!=0)<br>11、 d++=s–;<br>12、 printf(“%s”,dest);<br>13、 return 0;<br>14、}<br>答：<br>方法1：<br>int main(){<br>char* src = “hello,world”;<br>int len = strlen(src);<br>char* dest = (char<em>)malloc(len+1);//要为\0分配一个空间<br>char</em> d = dest;<br>char* s = &amp;src[len-1];//指向最后一个字符<br>while( len– != 0 )<br><em>d++=</em>s–;<br>*d = 0;//尾部要加\0<br>printf(“%s\n”,dest);<br>free(dest);// 使用完，应当释放空间，以免造成内存汇泄露<br>return 0;<br>}<br>方法2：<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>main()<br>{<br>char str[]=”hello,world”;<br>int len=strlen(str);<br>char t;<br>for(int i=0; i&lt;len/2; i++)<br>{<br>t=str[i];<br>str[i]=str[len-i-1]; str[len-i-1]=t;<br>}<br>printf(“%s”,str);<br>return 0;<br>}<br>8、请问下面程序有什么错误?<br>  int a[60][250][1000],i,j,k;<br>  for(k=0;k&lt;=1000;k++)<br>  for(j=0;j&lt;250;j++)<br>   for(i=0;i&lt;60;i++)<br>   a[i][j][k]=0;<br>答案：把循环语句内外换一下</p>
<p>9、请问下面程序会出现什么情况?<br>.   #define Max_CB 500<br>  void LmiQueryCSmd(Struct MSgCB * pmsg)<br>   {<br>   unsigned char ucCmdNum;<br>   ……</p>
<p>   for(ucCmdNum=0;ucCmdNum&lt;Max_CB;ucCmdNum++)<br>   {<br>   ……;<br>   }<br>答案：死循环</p>
<p>10、以下3个有什么区别<br>char * const p; //常量指针，p的值不可以修改<br>char const * p；//指向常量的指针，指向的常量值不可以改<br>const char *p； //和char const *p</p>
<p>11、写出下面的结果<br>char str1[] = “abc”;<br>char str2[] = “abc”;</p>
<p>const char str3[] = “abc”;<br>const char str4[] = “abc”;</p>
<p>const char *str5 = “abc”;<br>const char *str6 = “abc”;</p>
<p>char *str7 = “abc”;<br>char *str8 = “abc”;</p>
<p>cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;</p>
<p>结果是：0 0 1 1<br>解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；<br>而str5,str6,str7,str8是指针，它们指向相同的常量区域。</p>
<p>12、以下代码中的两个sizeof用法有问题吗？<br>void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母<br>{<br>  for( size_t i=0; i&lt;sizeof(str)/sizeof(str[0]); ++i )<br>    if( ‘a’&lt;=str[i] &amp;&amp; str[i]&lt;=’z’ )<br>      str[i] -= (‘a’-‘A’ );<br>}<br>char str[] = “aBcDe”;<br>cout &lt;&lt; “str字符长度为: “ &lt;&lt; sizeof(str)/sizeof(str[0]) &lt;&lt; endl;<br>UpperCase( str );<br>cout &lt;&lt; str &lt;&lt; endl;<br>答：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。</p>
<p>13、写出输出结果<br>main()<br>{<br> int a[5]={1,2,3,4,5};<br>  int <em>ptr=(int *)(&amp;a+1);<br>printf(“%d,%d”,</em>(a+1),<em>(ptr-1));<br>}<br>输出：2,5<br>*(a+1）就是a[1]，</em>(ptr-1)就是a[4],执行结果是2，5<br>&amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）<br>int <em>ptr=(int *)(&amp;a+1);<br>则ptr实际是&amp;(a[5]),也就是a+5<br>原因如下：<br>&amp;a是数组指针，其类型为 int (</em>)[5];<br>而指针加1要根据指针类型加上一定的值，<br>不同类型的指针+1之后增加的大小不同<br>a是长度为5的int数组指针，所以要加 5<em>sizeof(int)<br>所以ptr实际是a[5]<br>但是prt与(&amp;a+1)类型是不一样的(这点很重要)<br>所以prt-1只会减去sizeof(int</em>)<br>a,&amp;a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&amp;a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&amp;a+1是下一个对象的地址，即a[5].<br>14、请问以下代码有什么问题：<br>int  main()<br>{<br>char a;<br>char <em>str=&a;<br>strcpy(str,”hello”);<br>printf(str);<br>return 0;<br>}<br>没有为str分配内存空间，将会发生异常<br>问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。<br>char</em> s=”AAA”;<br>printf(“%s”,s);<br>s[0]=’B’;<br>printf(“%s”,s);<br>有什么错？<br>“AAA”是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。<br>cosnt char* s=”AAA”;<br>然后又因为是常量，所以对是s[0]的赋值操作是不合法的。</p>
<p>15、有以下表达式：<br>int a=248; b=4;int const c=21;const int <em>d=&a;<br>int *const e=&b;int const *f const =&a;<br>请问下列表达式哪些会被编译器禁止？为什么？<br>*c=32;d=&b;</em>d=43;e=34;e=&a;f=0x321f;<br>*c 这是个什么东东，禁止<br>*d 说了是const， 禁止<br>e = &amp;a 说了是const 禁止<br>const *f const =&a; 禁止</p>
<p>16、交换两个变量的值，不使用第三个变量。<br>即a=3,b=5,交换之后a=5,b=3;<br>有两种解法, 一种用算术算法, 一种用^(异或)<br>a = a + b;<br>b = a - b;<br>a = a - b;<br>or<br>a = a^b;// 只能对int,char..<br>b = a^b;<br>a = a^b;<br>or<br>a ^= b ^= a;<br>17、下面的程序会出现什么结果<br>.#include &lt;stdio.h&gt;<br> #include &lt;stdlib.h&gt;<br> void getmemory(char *p)<br> {<br>  p=(char *) malloc(100);<br>  strcpy(p,”hello world”);<br> }<br> int main( )<br> {<br>  char *str=NULL;<br>  getmemory(str);<br>  printf(“%s/n”,str);<br>  free(str);<br>  return 0;<br>  }<br>程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险</p>
<p>18、下面的语句会出现什么结果？<br>char szstr[10];<br>  strcpy(szstr,”0123456789”);<br>答案：长度不一样，会造成非法的OS，应该改为char szstr[11]；</p>
<p>19、(void <em>)ptr 和 (</em>(void<strong>))ptr的结果是否相同？<br>答：其中ptr为同一个指针<br>.(void <em>)ptr 和 (</em>(void</strong>))ptr值是相同的</p>
<p>20、问函数既然不会被其它函数调用，为什么要返回1？<br>int main()<br>  {<br>  int x=3;<br>  printf(“%d”,x);<br>  return 1;<br>  }<br>答：mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息</p>
<p>21、对绝对地址0x100000赋值且想让程序跳转到绝对地址是0x100000去执行<br>(unsigned int<em>)0x100000 = 1234;<br>首先要将0x100000强制转换成函数指针,即:<br>(void (</em>)())0x100000<br>然后再调用它:<br><em>((void (</em>)())0x100000)();<br>用typedef可以看得更直观些:<br>typedef void(*)() voidFuncPtr;<br>*((voidFuncPtr)0x100000)();</p>
<p>22、输出多少？并分析过程<br>unsigned short A = 10;<br>printf(“~A = %u\n”, ~A);</p>
<p>char c=128;<br>printf(“c=%d\n”,c);<br>  第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285<br>第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。<br>这两道题都是在考察二进制向int或uint转换时的最高位处理。</p>
<p>23、分析下面的程序：<br>void GetMemory(char **p,int num)<br>{<br>  *p=(char *)malloc(num);<br>}<br>int main()<br>{<br>  char *str=NULL;<br>  GetMemory(&amp;str,100);<br>  strcpy(str,”hello”);<br>  free(str);<br>  if(str!=NULL)<br>  {<br>    strcpy(str,”world”);<br>  }<br>  printf(“\n str is %s”,str);<br>  getchar();<br>}<br>问输出结果是什么？希望大家能说说原因，先谢谢了<br>输出str is world。<br>free 只是释放的str指向的内存空间,它本身的值还是存在的.<br>所以free之后，有一个好的习惯就是将str=NULL.<br>此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,<br>尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。<br>这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。<br>当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。<br>24、char a[10],strlen(a)为什么等于15？运行的结果<br>#include “stdio.h”<br>#include “string.h”</p>
<p>void main()<br>{<br>char aa[10];<br>printf(“%d”,strlen(aa));<br>}</p>
<p>sizeof()和初不初始化，没有关系；<br>strlen()和初始化有关。</p>
<p>char (<em>str)[20];/*str是一个数组指针，即指向数组的指针．</em>/<br>char <em>str[20];/*str是一个指针数组，其元素为指针型数据．</em>/</p>
<p>25、long a=0x801010;a+5=?<br>答：0x801010用二进制表示为：“1000 0000 0001 0000 0001 0000”，十进制的值为8392720，再加上5就是8392725</p>
<p>26、给定结构struct A<br>{<br>    char t:：4;<br>    char k:4;<br>    unsigned short i:8;<br>    unsigned long m;<br>};问sizeof(A) = ?<br>给定结构struct A<br>{<br>    char t:4; 4位<br>    char k:4; 4位<br>    unsigned short i:8; 8位<br>    unsigned long m; // 偏移2字节保证4字节对齐<br>}; // 共8字节</p>
<p>27、下面的函数实现在一个数上加一个数，有什么错误？请改正。<br>int add_n ( int n )<br>{<br>  static int i = 100;<br>  i += n;<br>  return i;<br>}<br>当你第二次调用时得不到正确的结果，难道你写个函数就是为了调用一次？问题就出在 static上<br>28、给出下面程序的答案<br>#include&lt;iostream.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;malloc.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;memory.h&gt;<br>typedef struct  AA<br>{<br>    int b1:5;<br>    int b2:2;<br>}AA;<br>void main()<br>{<br>    AA aa;<br>    char cc[100];<br>     strcpy(cc,”0123456789abcdefghijklmnopqrstuvwxyz”);<br>    memcpy(&amp;aa,cc,sizeof(AA));<br>    cout &lt;&lt; aa.b1 &lt;&lt;endl;<br>    cout &lt;&lt; aa.b2 &lt;&lt;endl;<br>}<br>答案是 -16和１<br>首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit.<br>经过strcpy和memcpy后,aa的4个字节所存放的值是:<br>0,1,2,3的ASC码，即00110000,00110001,00110010,00110011<br>所以，最后一步：显示的是这４个字节的前５位，和之后的２位<br>分别为：10000,和01<br>因为int是有正负之分　　所以：答案是-16和１</p>
<p>29、求函数返回值，输入x=9999;<br>int func （ x ）<br>{<br>  int countx = 0;<br>  while ( x )<br>  {<br>    countx ++;<br>    x = x&amp;(x-1);<br>  }<br>  return countx;<br>}<br>结果呢？<br>知道了这是统计9999的二进制数值中有多少个1的函数，且有<br>9999＝9×1024＋512＋256＋15</p>
<p>9×1024中含有1的个数为2；<br>512中含有1的个数为1；<br>256中含有1的个数为1；<br>15中含有1的个数为4；<br>故共有1的个数为8，结果为8。<br>1000 - 1 = 0111，正好是原数取反。这就是原理。<br>用这种方法来求1的个数是很效率很高的。<br>不必去一个一个地移位。循环次数最少。</p>
<p>30、分析：<br>struct bit<br>{  int a:3;<br>  int  b:2;<br>  int c:3;<br>};<br>int main()<br>{<br> bit s;<br> char <em>c=(char</em>)&s;<br>  cout&lt;&lt;sizeof(bit)&lt;&lt;endl;<br> *c=0x99;<br>  cout &lt;&lt; s.a &lt;&lt;endl &lt;&lt;s.b&lt;&lt;endl&lt;&lt;s.c&lt;&lt;endl;<br>   int a=-1;<br>  printf(“%x”,a);<br> return 0;<br>}<br>输出为什么是<br>4<br>1<br>-1<br>-4<br>ffffffff<br>因为0x99在内存中表示为 100 11 001 , a = 001, b = 11, c = 100<br>当c为有符合数时, c = 100, 最高1为表示c为负数，负数在计算机用补码表示，所以c = -4;同理<br>b = -1;<br>当c为有符合数时, c = 100,即 c = 4,同理 b = 3</p>
<p>31、下面这个程序执行后会有什么错误或者效果:<br> #define MAX 255<br> int main()<br>{<br>  unsigned char A[MAX],i;//i被定义为unsigned char<br>  for (i=0;i&lt;=MAX;i++)<br>   A[i]=i;<br>}<br>解答：死循环加数组越界访问（C/C++不进行数组越界检查）<br>MAX=255<br>数组A的下标范围为:0..MAX-1,这是其一..<br>其二.当i循环到255时,循环内执行:<br> A[255]=255;<br>这句本身没有问题..但是返回for (i=0;i&lt;=MAX;i++)语句时,<br>由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.</p>
<p>32、写出sizeof(struct name1)=,sizeof(struct name2)=的结果<br>struct name1{<br>  char  str;<br>  short x;<br>  int  num;<br>}</p>
<p>struct name2{<br>  char str;<br>  int num;<br>  short x;<br>}</p>
<p>sizeof(struct name1)=8,sizeof(struct name2)=12<br>在第二个结构中，为保证num按四个字节对齐，char后必须留出3字节的空间；同时为保证整个结构的自然对齐（这里是4字节对齐），在x后还要补齐2个字节，这样就是12字节。</p>
<p>33、struct s1<br>{<br> int i: 8;<br> int j: 4;<br> int a: 3;<br> double b;<br>};</p>
<p>struct s2<br>{<br> int i: 8;<br> int j: 4;<br> double b;<br> int a:3;<br>};</p>
<p>printf(“sizeof(s1)= %d\n”, sizeof(s1));<br>printf(“sizeof(s2)= %d\n”, sizeof(s2));<br>result: 16, 24<br>第一个struct s1<br>{<br> int i: 8;<br> int j: 4;<br> int a: 3;<br> double b;<br>};<br>理论上是这样的，首先是i在相对0的位置，占8位一个字节，然后，j就在相对一个字节的位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放在那里了，然后是a，要在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算过来是2字节2位的样子，由于double是8字节的，因此要在相对0要是8个字节的位置上放下，因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16字节。<br>第二个最后会对照是不是结构体内最大数据的倍数，不是的话，会补成是最大数据的倍数</p>
<p>34、在对齐为4的情况下<br>struct BBB<br>{<br>  long num；<br>  char <em>name;<br>  short int data;<br>  char ha;<br>  short ba[5];<br>}*p;<br>p=0x1000000;<br>p+0x200=<strong><strong>;<br>(Ulong)p+0x200=</strong></strong>;<br>(char</em>)p+0x200=____;<br>希望各位达人给出答案和原因，谢谢拉<br>解答：假设在32位CPU上，<br>sizeof(long) = 4 bytes<br>sizeof(char *) = 4 bytes<br>sizeof(short int) = sizeof(short) = 2 bytes<br>sizeof(char) = 1 bytes</p>
<p>由于是4字节对齐，<br>sizeof(struct BBB) = sizeof(<em>p)<br>= 4 + 4 + 2 + 1 + 1/*补齐</em>/ + 2<em>5 + 2/*补齐</em>/ = 24 bytes  (经Dev-C++验证)</p>
<p>p=0x1000000;<br>p+0x200=____;<br>  = 0x1000000 + 0x200*24</p>
<p>(Ulong)p+0x200=____;<br>  = 0x1000000 + 0x200</p>
<p>(char<em>)p+0x200=____;<br>  = 0x1000000 + 0x200</em>4</p>
<p>35、找错<br>Void test1()<br>{<br>char string[10];<br>char* str1=”0123456789”;<br>strcpy(string, str1);// 溢出，应该包括一个存放’\0’的字符string[11]<br>}</p>
<p>Void test2()<br>{<br>char string[10], str1[10];<br>for(I=0; I&lt;10;I++)<br>{<br>str1[i] =’a’;<br>}<br>strcpy(string, str1);// I，i没有声明。<br>}</p>
<p>Void test3(char* str1)<br>{<br>char string[10];<br>if(strlen(str1)&lt;=10)// 改成&lt;10,字符溢出，将strlen改为sizeof也可以<br>{<br>strcpy(string, str1);<br>}<br>}</p>
<p>36、写出输出结果<br>void g(int**);<br>int main()<br>{<br>int line[10],i;<br>int *p=line; //p是地址的地址<br>for (i=0;i&lt;10;i++)<br>{<br>*p=i;<br>g(&amp;p);//数组对应的值加1<br>}<br>for(i=0;i&lt;10;i++)<br>printf(“%d\n”,line[i]);<br>return 0;<br>}</p>
<p>void g(int<strong>p)<br>{<br>(</strong>p)++;<br>(*p)++;// 无效<br>}<br>输出：<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>37、写出程序运行结果<br>int sum(int a)<br>{<br>auto int c=0;<br>static int b=3;<br>c+=1;<br>b+=2;<br>return(a+b+c);<br>}</p>
<p>void main()<br>{<br>int I;<br>int a=2;<br>for(I=0;I&lt;5;I++)<br>{<br>printf(“%d,”, sum(a));<br>}<br>}<br>// static会保存上次结果，记住这一点，剩下的自己写<br>输出：8,10,12,14,16,</p>
<p>38、评价代码<br>int func(int a)<br>{<br>int b;<br>switch(a)<br>{<br>case 1: 30;<br>case 2: 20;<br>case 3: 16;<br>default: 0<br>}<br>return b;<br>}<br>则func(1)=?<br>// b定义后就没有赋值</p>
<p>int a[3];<br>a[0]=0; a[1]=1; a[2]=2;<br>int *p, *q;<br>p=a;<br>q=&amp;a[2];<br>则a[q-p]=a[2]<br>解释：指针一次移动一个int但计数为1</p>
<p>39、请问一下程序将输出什么结果？<br>char *RetMenory(void)<br>{<br>    char p[] = “hellow world”;<br>    return p;<br>}<br>void Test(void)<br>{<br>    char *str = NULL;<br>    str = RetMemory();<br>    printf(str);<br>}<br>RetMenory执行完毕，p资源被回收，指向未知地址。返回地址，str的内容应是不可预测的, 打印的应该是str的地址</p>
<p>40、写出输出结果<br>typedef struct<br> {<br>   int a:2;<br>   int b:2;<br>   int c:1;<br> }test;</p>
<p> test t;<br> t.a = 1;<br> t.b = 3;<br> t.c = 1;</p>
<p> printf(“%d”,t.a);<br> printf(“%d”,t.b);<br> printf(“%d”,t.c);</p>
<p>t.a为01,输出就是1<br>t.b为11，输出就是－1<br>t.c为1，输出也是-1<br>3个都是有符号数int嘛。<br>这是位扩展问题<br>01<br>11<br>1<br>编译器进行符号扩展</p>
<p>41、对下面程序进行分析<br>void test2()<br>{<br>  char string[10], str1[10];<br>  int i;<br>  for(i=0; i&lt;10; i++)<br>  {<br>   str1[i] = ‘a’;<br>  }<br>  strcpy( string, str1 );<br>}<br>解答：如果面试者指出字符数组str1不能在数组内结束可以给3分；如果面试者指出strcpy(string, str1)调用使得从str1内存起复制到string内存起所复制的字节数具有不确定性可以给7分，在此基础上指出库函数strcpy工作方式的给10分；<br>str1不能在数组内结束:因为str1的存储为：{a,a,a,a,a,a,a,a,a,a},没有’\0’(字符串结束符)，所以不能结束<br>strcpy( char *s1,char *s2)他的工作原理是，扫描s2指向的内存，逐个字符付到s1所指向的内存，直到碰到’\0’,因为str1结尾没有’\0’，所以具有不确定性，不知道他后面还会付什么东东。<br>正确应如下<br>void test2()<br>{<br>  char string[10], str1[10];<br>  int i;<br>  for(i=0; i&lt;9; i++)<br>  {<br>   str1[i] = ‘a’+i; //把abcdefghi赋值给字符数组<br>  }<br>  str[i]=’\0’;//加上结束符<br>  strcpy( string, str1 );<br>}</p>
<p>42、分析：<br>int arr[] = {6,7,8,9,10};<br>int <em>ptr = arr;<br>*(ptr++)+=123;<br>printf(“ %d %d ”, *ptr, *(++ptr));<br>输出：8 8<br>过程：对于</em>(ptr++)+=123;先做加法6+123，然后++，指针指向7；对于printf(“ %d %d ”, *ptr, *(++ptr));从后往前执行，指针先++，指向8，然后输出8，紧接着再输出8</p>
<p>43、分析下面的代码：<br>char *a = “hello”;<br>char *b = “hello”;<br>if(a= =b)<br>printf(“YES”);<br>else<br>printf(“NO”);<br>这个简单的面试题目,我选输出 no(对比的应该是指针地址吧),可在VC是YES 在C是NO<br>lz的呢，是一个常量字符串。位于静态存储区，它在程序生命期内恒定不变。如果编译器优化的话，会有可能a和b同时指向同一个hello的。则地址相同。如果编译器没有优化，那么就是两个不同的地址，则不同</p>
<p>44、写出输出结果<br>#include &lt;stdio.h&gt;<br>void foo(int m, int n)<br>{<br>  printf(“m=%d, n=%d\n”, m, n);<br>}</p>
<p>int main()<br>{<br>  int b = 3;<br>  foo(b+=3, ++b);<br>  printf(“b=%d\n”, b);<br>return 0;<br>}<br>输出：m=7,n=4,b=7(VC6.0)<br>这种方式和编译器中得函数调用关系相关即先后入栈顺序。不过不同<br>编译器得处理不同。也是因为C标准中对这种方式说明为未定义，所以<br>各个编译器厂商都有自己得理解，所以最后产生得结果完全不同。<br>因为这样，所以遇见这种函数，我们首先要考虑我们得编译器会如何处理<br>这样得函数，其次看函数得调用方式，不同得调用方式，可能产生不同得<br>结果。最后是看编译器优化。</p>
<p>45、找出错误<br>#include  string.h<br>main(void)<br>{  char  <em>src=”hello,world”;<br>  char  *dest=NULL;<br>  dest=(char  *)malloc(strlen(src));<br>  int  len=strlen(str);<br>  char  *d=dest;<br>  char  *s=src[len];<br>  while(len–!=0)<br>   d++=s–;<br>  printf(“%s”,dest);<br>}<br>找出错误！！<br>#include  “string.h”<br>#include “stdio.h”<br>#include “malloc.h”<br>main(void)<br>{<br>char  *src=”hello,world”;<br>  char  *dest=NULL;<br>  dest=(char  *)malloc(sizeof(char)</em>(strlen(src)+1));<br>  int  len=strlen(src);<br>  char  <em>d=dest;<br>  char  *s=src+len-1;<br>  while(len–!=0)<br>   *d++=</em>s–;<br>*d=’\0’;<br>  printf(“%s”,dest);<br>}</p>
<p>第三部分：编程题<br>1、读文件file1.txt的内容（例如）：<br>12<br>34<br>56<br>输出到file2.txt：<br>56<br>34<br>12<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</p>
<p>int main(void)<br>{<br>     int MAX = 10;<br>int *a = (int *)malloc(MAX * sizeof(int));<br>int *b;</p>
<p>FILE *fp1;<br>FILE *fp2;</p>
<p>fp1 = fopen(“a.txt”,”r”);<br>if(fp1 == NULL)<br>{printf(“error1”);<br>  exit(-1);<br>}</p>
<p>  fp2 = fopen(“b.txt”,”w”);<br>if(fp2 == NULL)<br>{printf(“error2”);<br>  exit(-1);<br>}</p>
<p>int i = 0;<br>  int j = 0;</p>
<p>while(fscanf(fp1,”%d”,&amp;a[i]) != EOF)<br>{<br>i++;<br>j++;<br>if(i &gt;= MAX)<br>{<br>MAX = 2 * MAX;<br>b = (int*)realloc(a,MAX * sizeof(int));<br>if(b == NULL)<br>{<br>printf(“error3”);<br>exit(-1);<br>}<br>a = b;<br>}<br>}</p>
<p>for(;–j &gt;= 0;)<br>  fprintf(fp2,”%d\n”,a[j]);</p>
<p>fclose(fp1);<br>fclose(fp2);</p>
<p>return 0;</p>
<p>}</p>
<p>2、输出和为一个给定整数的所有组合<br>例如n=5<br>5=1+4；5=2+3（相加的数不能重复）<br>则输出<br>1，4；2，3。<br>#include &lt;stdio.h&gt;</p>
<p>int main(void)<br>{<br>unsigned long int i,j,k;</p>
<p>printf(“please input the number\n”);<br>scanf(“%d”,&amp;i);<br>  if( i % 2 == 0)<br>    j = i / 2;<br>else<br>j = i / 2 + 1;</p>
<p>printf(“The result is \n”);<br>  for(k = 0; k &lt; j; k++)<br>   printf(“%d = %d + %d\n”,i,k,i - k);<br>return 0;<br>}</p>
<p>#include &lt;stdio.h&gt;<br>void main()<br>{<br>unsigned long int a,i=1;<br>scanf(“%d”,&amp;a);<br>if(a%2==0)<br>{<br>   for(i=1;i&lt;a/2;i++)<br>   printf(“%d”,a,a-i);<br>}<br>else<br>for(i=1;i&lt;=a/2;i++)<br>    printf(“ %d, %d”,i,a-i);<br>}</p>
<p>3、递规反向输出字符串的例子,可谓是反序的经典例程.<br>void inverse(char *p)<br>{<br>  if( *p = = ‘\0’ )<br>return;<br>  inverse( p+1 );<br>  printf( “%c”, *p );<br>}</p>
<p>int main(int argc, char *argv[])<br>{<br>  inverse(“abc\0”);</p>
<p>  return 0;<br>}<br>对1的另一种做法：<br>#include &lt;stdio.h&gt;<br>void test(FILE *fread, FILE *fwrite)<br>{<br>    char buf[1024] = {0};<br>    if (!fgets(buf, sizeof(buf), fread))<br>        return;<br>    test( fread, fwrite );<br>    fputs(buf, fwrite);<br>}<br>int main(int argc, char *argv[])<br>{<br>    FILE *fr = NULL;<br>    FILE *fw = NULL;<br>    fr = fopen(“data”, “rb”);<br>    fw = fopen(“dataout”, “wb”);<br>    test(fr, fw);<br>    fclose(fr);<br>    fclose(fw);<br>    return 0;<br>}</p>
<p>4、写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。函数接口为：int find_orderk(const int* narry,const int n,const int k)<br>要求算法复杂度不能是O(n^2）<br>谢谢！<br>可以先用快速排序进行排序，其中用另外一个进行地址查找<br>代码如下，在VC++6.0运行通过。给分吧^-^</p>
<p>//快速排序</p>
<p>#include<iostream></iostream></p>
<p>usingnamespacestd;</p>
<p>intPartition (int*L,intlow,int high)<br>{<br>inttemp = L[low];<br>intpt = L[low];</p>
<p>while (low &lt; high)<br>{<br>while (low &lt; high &amp;&amp; L[high] &gt;= pt)<br>–high;<br>L[low] = L[high];<br>while (low &lt; high &amp;&amp; L[low] &lt;= pt)<br>++low;<br>L[low] = temp;<br>}<br>L[low] = temp;</p>
<p>returnlow;<br>}</p>
<p>voidQSort (int*L,intlow,int high)<br>{<br>if (low &lt; high)<br>{<br>intpl = Partition (L,low,high);</p>
<p>QSort (L,low,pl - 1);<br>QSort (L,pl + 1,high);<br>}<br>}</p>
<p>intmain ()<br>{<br>intnarry[100],addr[100];<br>intsum = 1,t;</p>
<p>cout &lt;&lt; “Input number:” &lt;&lt; endl;<br>cin &gt;&gt; t;</p>
<p>while (t != -1)<br>{<br>narry[sum] = t;<br>addr[sum - 1] = t;<br>sum++;</p>
<p>cin &gt;&gt; t;<br>}</p>
<p>sum -= 1;<br>QSort (narry,1,sum);</p>
<p>for (int i = 1; i &lt;= sum;i++)<br>cout &lt;&lt; narry[i] &lt;&lt; ‘\t’;<br>cout &lt;&lt; endl;</p>
<p>intk;<br>cout &lt;&lt; “Please input place you want:” &lt;&lt; endl;<br>cin &gt;&gt; k;</p>
<p>intaa = 1;<br>intkk = 0;<br>for (;;)<br>{<br>if (aa == k)<br>break;<br>if (narry[kk] != narry[kk + 1])<br>{<br>aa += 1;<br>kk++;<br>}</p>
<p>}</p>
<p>cout &lt;&lt; “The NO.” &lt;&lt; k &lt;&lt; “number is:” &lt;&lt; narry[sum - kk] &lt;&lt; endl;<br>cout &lt;&lt; “And it’s place is:” ;<br>for (i = 0;i &lt; sum;i++)<br>{<br>if (addr[i] == narry[sum - kk])<br>cout &lt;&lt; i &lt;&lt; ‘\t’;<br>}</p>
<p>return0;<br>}</p>
<p>5、两路归并排序<br>Linklist <em>unio(Linklist *p,Linklist *q){<br>linklist *R,</em>pa,<em>qa,</em>ra;<br>pa=p;<br>qa=q;<br>R=ra=p;<br>while(pa-&gt;next!=NULL&amp;&amp;qa-&gt;next!=NULL){<br>if(pa-&gt;data&gt;qa-&gt;data){<br>ra-&gt;next=qa;<br>qa=qa-&gt;next;<br>}<br>else{<br>ra-&gt;next=pa;<br>pa=pa-&gt;next;<br>}<br>}<br>if(pa-&gt;next!=NULL)<br>ra-&gt;next=pa;<br>if(qa-&gt;next!=NULL)<br>ra-&gt;next==qa;<br>return R;<br>}</p>
<p>6、用递归算法判断数组a[N]是否为一个递增数组。<br>递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回false结束：<br>bool fun( int a[], int n )<br>{<br>if( n= =1 )<br>return true;<br>if( n= =2 )<br>return a[n-1] &gt;= a[n-2];<br>return fun( a,n-1) &amp;&amp; ( a[n-1] &gt;= a[n-2] );<br>}</p>
<p>7、单连表的建立，把’a’–’z’26个字母插入到连表中，并且倒叙，还要打印！<br>方法1：<br>typedef struct val<br>{  int date_1;<br>  struct val <em>next;<br>}</em>p;</p>
<p>void main(void)<br>{  char c;</p>
<p>  for(c=122;c&gt;=97;c–)<br>    { p.date=c;<br>     p=p-&gt;next;<br>    }</p>
<p>  p.next=NULL;<br>}<br>}<br>方法2：<br>node *p = NULL;<br>node *q = NULL;</p>
<p>node <em>head = (node</em>)malloc(sizeof(node));<br>head-&gt;data = ‘ ‘;head-&gt;next=NULL;</p>
<p>node <em>first = (node</em>)malloc(sizeof(node));<br>first-&gt;data = ‘a’;first-&gt;next=NULL;head-&gt;next = first;<br>p = first;</p>
<p>int longth = ‘z’ - ‘b’;<br>int i=0;<br>while ( i&lt;=longth )<br>{<br>node <em>temp = (node</em>)malloc(sizeof(node));<br>temp-&gt;data = ‘b’+i;temp-&gt;next=NULL;q=temp;</p>
<p>head-&gt;next = temp; temp-&gt;next=p;p=q;<br>i++;<br>}</p>
<p>print(head);</p>
<p>8、请列举一个软件中时间换空间或者空间换时间的例子。<br>void swap(int a,int b)<br>{<br>int c; c=a;a=b;b=a;<br>}<br>—&gt;空优<br>void swap(int a,int b)<br>{<br>a=a+b;b=a-b;a=a-b;<br>}</p>
<p>9、outputstr所指的值为123456789<br>int continumax(char *outputstr, char *inputstr)<br>{<br>char *in = inputstr, *out = outputstr, *temp, *final;<br>int count = 0, maxlen = 0;</p>
<p>while( *in != ‘\0’ )<br>{<br>if( *in &gt; 47 &amp;&amp; *in &lt; 58 )<br>{<br>for(temp = in; *in &gt; 47 &amp;&amp; *in &lt; 58 ; in++ )<br>count++;<br>}<br>else<br>in++;</p>
<p>if( maxlen &lt; count )<br>{<br>maxlen = count;<br>count = 0;<br>final = temp;<br>}<br>}<br>for(int i = 0; i &lt; maxlen; i++)<br>{<br>*out = *final;<br>out++;<br>final++;<br>}<br>*out = ‘\0’;<br>return maxlen;<br>}</p>
<p>10、不用库函数,用C语言实现将一整型数字转化为字符串<br>方法1：<br>int getlen(char <em>s){<br>  int n;<br>  for(n = 0; <em>s != ‘\0’; s++)<br>      n++;<br>  return n;<br>}<br>void reverse(char s[])<br>{<br>  int c,i,j;<br>  for(i = 0,j = getlen(s) - 1; i &lt; j; i++,j–){<br>    c = s[i];<br>    s[i] = s[j];<br>    s[j] = c;<br>  }<br>}<br>void itoa(int n,char s[])<br>{<br>  int i,sign;<br>  if((sign = n) &lt; 0)<br>    n = -n;<br>  i = 0;<br>  do{/</em>以反序生成数字</em>/<br>   s[i++] = n%10 + ‘0’;/<em>get next number</em>/<br>  }while((n /= 10) &gt; 0);/<em>delete the number</em>/</p>
<p>  if(sign &lt; 0)<br>   s[i++] = ‘-‘;</p>
<p>  s[i] = ‘\0’;<br>  reverse(s);<br>}<br>方法2:<br>#include <iostream><br>using namespace std;</iostream></p>
<p>void itochar(int num);</p>
<p>void itochar(int num)<br>{<br>int i = 0;<br>int j ;<br>char stra[10];<br>char strb[10];<br>while ( num )<br>{<br>stra[i++]=num%10+48;<br>num=num/10;<br>}<br>stra[i] = ‘\0’;<br>for( j=0; j &lt; i; j++)<br>{<br>strb[j] = stra[i-j-1];<br>}<br>strb[j] = ‘\0’;<br>cout&lt;&lt;strb&lt;&lt;endl;</p>
<p>}<br>int main()<br>{<br>int num;<br>cin&gt;&gt;num;<br>itochar(num);<br>return 0;<br>}</p>
<p>11、求组合数： 求n个数（1….n）中k个数的组合….<br>      如：combination(5,3)<br> 要求输出：543，542，541，532，531，521，432，431，421，321，<br>#include&lt;stdio.h&gt;</p>
<p>int pop(int *);<br>int push(int );<br>void combination(int ,int );</p>
<p>int stack[3]={0};<br>top=-1;</p>
<p>int main()<br>{<br>int n,m;<br>printf(“Input two numbers:\n”);<br>while( (2!=scanf(“%d%*c%d”,&amp;n,&amp;m)) )<br>{<br>fflush(stdin);<br>printf(“Input error! Again:\n”);<br>}<br>combination(n,m);<br>printf(“\n”);<br>}<br>void combination(int m,int n)<br>{<br>int temp=m;<br>push(temp);<br>while(1)<br>{<br>if(1==temp)<br>{<br>if(pop(&amp;temp)&amp;&amp;stack[0]==n) //当栈底元素弹出&amp;&amp;为可能取的最小值，循环退出<br>break;<br>}<br>else if( push(–temp))<br>{<br>printf(“%d%d%d  “,stack[0],stack[1],stack[2]);//§&auml;¨ì¤@?<br>pop(&amp;temp);<br>}<br>}<br>}<br>int push(int i)<br>{<br>stack[++top]=i;<br>if(top&lt;2)<br>return 0;<br>else<br>return 1;<br>}<br>int pop(int *i)<br>{<br>*i=stack[top–];<br>if(top&gt;=0)<br>return 0;<br>else<br>return 1;<br>}</p>
<p>12、用指针的方法，将字符串“ABCD1234efgh”前后对调显示<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;dos.h&gt;<br>int main()<br>{<br>  char str[] = “ABCD1234efgh”;<br>  int length = strlen(str);<br>  char * p1 = str;<br>  char * p2 = str + length - 1;<br>  while(p1 &lt; p2)<br>  {<br>    char c = *p1;<br>    *p1 = *p2;<br>    *p2 = c;<br>    ++p1;<br>    –p2;<br>  }<br>  printf(“str now is %s\n”,str);<br>  system(“pause”);<br>  return 0;<br>}</p>
<p>13、有一分数序列：1/2,1/4,1/6,1/8……，用函数调用的方法，求此数列前20项的和<br>#include &lt;stdio.h&gt;<br>double getValue()<br>{<br>  double result = 0;<br>  int i = 2;<br>  while(i &lt; 42)<br>  {<br>    result += 1.0 / i;//一定要使用1.0做除数，不能用1，否则结果将自动转化成整数，即0.000000<br>    i += 2;<br>  }<br>  return result;<br>}<br>int main()<br>{<br>  printf(“result is %f\n”, getValue());<br>  system(“pause”);<br>  return 0;<br>}</p>
<p>14、有一个数组a[1000]存放0–1000;要求每隔二个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。<br>以7个数为例：<br>  {0,1,2,3,4,5,6,7} 0–&gt;1–&gt;2（删除）–&gt;3–&gt;4–&gt;5(删除)–&gt;6–&gt;7–&gt;0（删除），如此循环直到最后一个数被删除。<br>方法1：数组<br>#include <iostream><br>using namespace std;<br>#define null 1000</iostream></p>
<p>int main()<br>{<br>int arr[1000];<br>for (int i=0;i&lt;1000;++i)<br>arr[i]=i;<br>int j=0;<br>int count=0;<br>while(count&lt;999)<br>{<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>j=(++j)%1000;<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>j=(++j)%1000;<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>arr[j]=null;<br>++count;<br>}<br>while(arr[j]==null)<br>j=(++j)%1000;</p>
<p>cout&lt;&lt;j&lt;&lt;endl;<br>return 0;<br>}方法2：链表<br>#include<iostream><br>using namespace std;<br>#define null 0<br>struct node<br>{<br>int data;<br>node* next;<br>};<br>int main()<br>{<br>node* head=new node;<br>head-&gt;data=0;<br>head-&gt;next=null;<br>node* p=head;<br>for(int i=1;i&lt;1000;i++)<br>{<br>node* tmp=new node;<br>tmp-&gt;data=i;<br>tmp-&gt;next=null;<br>head-&gt;next=tmp;<br>head=head-&gt;next;<br>}<br>head-&gt;next=p;<br>while(p!=p-&gt;next)<br>{<br>p-&gt;next-&gt;next=p-&gt;next-&gt;next-&gt;next;<br>p=p-&gt;next-&gt;next;<br>}<br>cout&lt;<p->data;<br>return 0;<br>}<br>方法3：通用算法<br>#include &lt;stdio.h&gt;<br>#define MAXLINE 1000  //元素个数<br>/*<br>MAXLINE  元素个数<br>a[]    元素数组<br>R[]    指针场<br>suffix   下标<br>index   返回最后的下标序号<br>values   返回最后的下标对应的值<br>start   从第几个开始<br>K     间隔<br>*/<br>int find_n(int a[],int R[],int K,int&amp; index,int&amp; values,int s=0) {<br>  int suffix;<br>  int front_node,current_node;<br>  suffix=0;<br>   if(s==0) {<br>   current_node=0;<br>   front_node=MAXLINE-1;<br>   }<br>   else {<br>   current_node=s;<br>   front_node=s-1;<br>   }<br>    while(R[front_node]!=front_node) {<br>      printf(“%d\n”,a[current_node]);<br>      R[front_node]=R[current_node];<br>      if(K==1) {<br>       current_node=R[front_node];<br>       continue;<br>      }<br>      for(int i=0;i&lt;K;i++){<br>        front_node=R[front_node];<br>      }<br>      current_node=R[front_node];<br>    }<br> index=front_node;<br> values=a[front_node];</p-></iostream></p>
<p> return 0;<br>}<br>int main(void) {<br>int a[MAXLINE],R[MAXLINE],suffix,index,values,start,i,K;<br>suffix=index=values=start=0;<br>K=2;</p>
<p>for(i=0;i&lt;MAXLINE;i++) {<br>a[i]=i;<br>R[i]=i+1;<br>}<br>R[i-1]=0;<br>find_n(a,R,K,index,values,2);<br>printf(“the value is %d,%d\n”,index,values);<br>return 0;<br>}</p>
<p>15、实现strcmp<br>int StrCmp(const char <em>str1, const char *str2)<br>做是做对了，没有抄搞，比较乱<br>int StrCmp(const char *str1, const char *str2)<br>{<br>  assert(str1 &amp;&amp; srt2);<br>  while (</em>str1 &amp;&amp; <em>str2 &amp;&amp; *str1 == *str2) {<br>    str1++, str2++;<br>  }<br>  if (</em>str1 &amp;&amp; <em>str2)<br>    return (</em>str1-<em>str2);<br>  elseif (</em>str1 &amp;&amp; <em>str2==0)<br>    return 1;<br>  elseif (</em>str1 = = 0 &amp;&amp; *str2)<br>    return -1;<br>  else<br>    return 0;<br>}</p>
<p>int StrCmp(const char <em>str1, const char *str2)<br>{<br>     //省略判断空指针(自己保证)<br>while(</em>str1 &amp;&amp; <em>str1++ = = *str2++);<br>return *str1-</em>str2;<br>}</p>
<p>16、实现子串定位<br>int FindSubStr(const char <em>MainStr, const char *SubStr)<br>做是做对了，没有抄搞，比较乱<br>int MyStrstr(const char</em> MainStr, const char* SubStr)<br>{<br>const char *p;<br>const char *q;<br>const char * u = MainStr;</p>
<p>//assert((MainStr!=NULL)&amp;&amp;( SubStr!=NULL));//用断言对输入进行判断<br>while(<em>MainStr) //内部进行递增<br>{<br>p = MainStr;<br>q = SubStr;<br>while(</em>q &amp;&amp; <em>p &amp;&amp; *p++ == *q++);<br>if(!</em>q )<br>{<br>return MainStr - u +1 ;//MainStr指向当前起始位，u指向<br>}<br>MainStr ++;<br>}<br>return -1;<br>}</p>
<p>17、已知一个单向链表的头，请写出删除其某一个结点的算法，要求，先找到此结点，然后删除。<br>slnodetype <em>Delete(slnodetype *Head,int key){}中if(Head-&gt;number==key)<br>{<br>Head=Pointer-&gt;next;<br>free(Pointer);<br>break;<br>}<br>Back = Pointer;<br>    Pointer=Pointer-&gt;next;<br>if(Pointer-&gt;number==key)<br>{<br>      Back-&gt;next=Pointer-&gt;next;<br>free(Pointer);<br>break;<br>}<br>void delete(Node</em> p)<br>{<br>  if(Head = Node)</p>
<p>  while(p)<br>}</p>
<p>18、有1,2,….一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数.（华为）<br>#include&lt;iostream.h&gt;</p>
<p>int main()<br>{<br>  int a[]  = {10,6,9,5,2,8,4,7,1,3};<br>  int len = sizeof(a) / sizeof(int);<br>  int temp;</p>
<p>  for(int i = 0; i &lt; len; )<br>  {<br>temp = a[a[i] - 1];<br>a[a[i] - 1] = a[i];<br>a[i] = temp;</p>
<p>if ( a[i] == i + 1)<br> i++;<br>  }<br>  for (int j = 0; j &lt; len; j++)<br>   cout&lt;&lt;a[j]&lt;&lt;”,”;</p>
<p>  return 0;<br>}</p>
<p>19、写出程序把一个链表中的接点顺序倒排<br>typedef struct linknode<br>{<br>int data;<br>struct linknode <em>next;<br>}node;<br>//将一个链表逆置<br>node *reverse(node *head)<br>{<br>node *p,</em>q,*r;<br>p=head;<br>q=p-&gt;next;<br>while(q!=NULL)<br>{<br>r=q-&gt;next;<br>q-&gt;next=p;<br>p=q;<br>q=r;<br>}</p>
<p>head-&gt;next=NULL;<br>head=p;<br>return head;<br>}</p>
<p>20、写出程序删除链表中的所有接点<br>void del_all(node *head)<br>{<br>node *p;<br>while(head!=NULL)<br>{<br>p=head-&gt;next;<br>free(head);<br>head=p;<br>}<br>cout&lt;&lt;”释放空间成功!”&lt;&lt;endl;<br>}</p>
<p>21、两个字符串，s,t;把t字符串插入到s字符串中，s字符串有足够的空间存放t字符串<br>void insert(char <em>s, char *t, int i)<br>{<br>char *q = t;<br>char *p =s;<br>if(q == NULL)return;<br>while(</em>p!=’\0’)<br>{<br>p++;<br>}<br>while(<em>q!=0)<br>{<br>*p=</em>q;<br>p++;<br>q++;<br>}<br>*p = ‘\0’;<br>}</p>
<p>22、写一个函数，功能：完成内存之间的拷贝<br>memcpy source code:<br>  270 void* memcpy( void *dst, const void *src, unsigned int len )<br>  271 {<br>  272   register char *d;<br>  273   register char *s;<br>  27<br>  275   if (len == 0)<br>  276    return dst;<br>  277<br>  278   if (is_overlap(dst, src, len, len))<br>  279    complain3(“memcpy”, dst, src, len);<br>  280<br>  281   if ( dst &gt; src ) {<br>  282    d = (char *)dst + len - 1;<br>  283    s = (char *)src + len - 1;<br>  284    while ( len &gt;= 4 ) {<br>  285      *d– = *s–;<br>  286      *d– = *s–;<br>  287      *d– = *s–;<br>  288      *d– = *s–;<br>  289      len -= 4;<br>  290    }<br>  291    while ( len– ) {<br>  292      *d– = *s–;<br>  293    }<br>  294   } else if ( dst &lt; src ) {<br>  295    d = (char *)dst;<br>  296    s = (char *)src;<br>  297    while ( len &gt;= 4 ) {<br>  298      *d++ = *s++;<br>  299      *d++ = *s++;<br>  300      *d++ = *s++;<br>  301      *d++ = *s++;<br>  302      len -= 4;<br>  303    }<br>  304    while ( len– ) {<br>  305      *d++ = *s++;<br>  306    }<br>  307   }<br>  308   return dst;<br>  309 }</p>
<p>23、公司考试这种题目主要考你编写的代码是否考虑到各种情况，是否安全（不会溢出）<br>各种情况包括：<br>１、参数是指针，检查指针是否有效<br>２、检查复制的源目标和目的地是否为同一个，若为同一个，则直接跳出<br>３、读写权限检查<br>４、安全检查，是否会溢出<br>memcpy拷贝一块内存，内存的大小你告诉它<br>strcpy是字符串拷贝，遇到’\0’结束</p>
<p>/* memcpy ─── 拷贝不重叠的内存块 <em>/<br>void memcpy(void</em> pvTo, void* pvFrom, size_t size)<br>{<br>void* pbTo = (byte<em>)pvTo;<br>void</em> pbFrom = (byte*)pvFrom;<br>ASSERT(pvTo != NULL &amp;&amp; pvFrom != NULL); //检查输入指针的有效性<br>ASSERT(pbTo&gt;=pbFrom+size || pbFrom&gt;=pbTo+size);//检查两个指针指向的内存是否重叠<br>while(size–&gt;0)<br>*pbTo++ == *pbFrom++;<br>return(pvTo);<br>}</p>
<p>24、两个字符串，s,t;把t字符串插入到s字符串中，s字符串有足够的空间存放t字符串<br>void insert(char *s, char *t, int i)<br>{<br>memcpy(&amp;s[strlen(t)+i],&amp;s[i],strlen(s)-i);<br>memcpy(&amp;s[i],t,strlen(t));<br>s[strlen(s)+strlen(t)]=’\0’;<br>}</p>
<p>25、编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是由同一字符组成的。<br>char * search(char <em>cpSource, char ch)<br>{<br>     char *cpTemp=NULL, *cpDest=NULL;<br>     int iTemp, iCount=0;<br>     while(</em>cpSource)<br>     {<br>         if(<em>cpSource == ch)<br>         {<br>             iTemp = 0;<br>             cpTemp = cpSource;<br>             while(</em>cpSource == ch)<br>++iTemp, ++cpSource;<br>             if(iTemp &gt; iCount)<br>iCount = iTemp, cpDest = cpTemp;<br>    if(!*cpSource)<br>break;<br>         }<br>         ++cpSource;<br> }<br> return cpDest;<br>}   </p>
<p>26、请编写一个 C 函数，该函数在给定的内存区域搜索给定的字符，并返回该字符所在位置索引值。<br>int search(char *cpSource, int n, char ch)<br>{<br>     int i;<br>     for(i=0; i&lt;n &amp;&amp; *(cpSource+i) != ch; ++i);<br>     return i;<br>}</p>
<p>27、给定字符串A和B,输出A和B中的最大公共子串。<br>比如A=”aocdfe” B=”pmcdfa” 则输出”cdf”<br>*/<br>//Author: azhen<br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#include&lt;string.h&gt;</p>
<p>char *commanstring(char shortstring[], char longstring[])<br>{<br>int i, j;</p>
<p>char *substring=malloc(256);</p>
<p>if(strstr(longstring, shortstring)!=NULL)        //如果……，那么返回shortstring<br>return shortstring; </p>
<p>for(i=strlen(shortstring)-1;i&gt;0; i–)         //否则，开始循环计算<br>{<br>for(j=0; j&lt;=strlen(shortstring)-i; j++){<br>memcpy(substring, &amp;shortstring[j], i);<br>substring[i]=’\0’;<br>if(strstr(longstring, substring)!=NULL)<br>return substring;<br>}<br>}<br>return NULL;<br>}</p>
<p>main()<br>{<br>char *str1=malloc(256);<br>char *str2=malloc(256);<br>char *comman=NULL;</p>
<p>gets(str1);<br>gets(str2);</p>
<p>if(strlen(str1)&gt;strlen(str2))             //将短的字符串放前面<br>comman=commanstring(str2, str1);<br>else<br>comman=commanstring(str1, str2);</p>
<p>printf(“the longest comman string is: %s\n”, comman);<br>}<br>28、写一个函数比较两个字符串str1和str2的大小，若相等返回0，若str1大于<br>str2返回1，若str1小于str2返回－1<br>int strcmp ( const char * src,const char * dst)<br>{<br>    int ret = 0 ;<br>    while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) &amp;&amp; *dst)<br>{<br>        ++src;<br>++dst;<br>}<br>    if ( ret &lt; 0 )<br>        ret = -1 ;<br>    else if ( ret &gt; 0 )<br>        ret = 1 ;<br>    return( ret );<br>}</p>
<p>29、求1000！的未尾有几个0（用素数相乘的方法来做，如72=2<em>2</em>2<em>3</em>3）;<br>求出1-&gt;1000里,能被5整除的数的个数n1,能被25整除的数的个数n2,能被125整除的数的个数n3,<br>能被625整除的数的个数n4.<br>1000!末尾的零的个数=n1+n2+n3+n4;<br>#include&lt;stdio.h&gt;<br>#define NUM 1000</p>
<p>int find5(int num){<br>int ret=0;<br>while(num%5==0){<br>num/=5;<br>ret++;<br>}<br>return ret;<br>}<br>int main(){<br>int result=0;<br>int i;<br>for(i=5;i&lt;=NUM;i+=5)<br>{<br>result+=find5(i);<br>}<br>printf(“ the total zero number is %d\n”,result);<br>return 0;<br>}</p>
<p>30、有双向循环链表结点定义为：<br>struct node<br>{ int data;<br>struct node <em>front,</em>next;<br>};<br>有两个双向循环链表A，B，知道其头指针为：pHeadA,pHeadB，请写一函数将两链表中data值相同的结点删除<br>BOOL DeteleNode(Node *pHeader, DataType Value)<br>{<br>if (pHeader == NULL) return;</p>
<p>BOOL bRet = FALSE;<br>Node *pNode = pHead;<br>while (pNode != NULL)<br>{<br>if (pNode-&gt;data == Value)<br>{<br>if (pNode-&gt;front == NULL)<br>{<br>pHeader = pNode-&gt;next;<br>pHeader-&gt;front = NULL;<br>}<br>else<br>{<br>if (pNode-&gt;next != NULL)<br>{<br>pNode-&gt;next-&gt;front = pNode-&gt;front;<br>}<br>pNode-&gt;front-&gt;next = pNode-&gt;next;<br>}</p>
<p>Node *pNextNode = pNode-&gt;next;<br>delete pNode;<br>pNode = pNextNode;</p>
<p>bRet = TRUE;<br>//不要break或return, 删除所有<br>}<br>else<br>{<br>pNode = pNode-&gt;next;<br>}<br>}</p>
<p>return bRet;<br>}</p>
<p>void DE(Node *pHeadA, Node *pHeadB)<br>{<br>if (pHeadA == NULL || pHeadB == NULL)<br>{<br>return;<br>}</p>
<p>Node *pNode = pHeadA;<br>while (pNode != NULL)<br>{<br>if (DeteleNode(pHeadB, pNode-&gt;data))<br>{<br>if (pNode-&gt;front == NULL)<br>{<br>pHeadA = pNode-&gt;next;<br>pHeadA-&gt;front = NULL;<br>}<br>else<br>{<br>pNode-&gt;front-&gt;next = pNode-&gt;next;<br>if (pNode-&gt;next != NULL)<br>{<br>pNode-&gt;next-&gt;front = pNode-&gt;front;<br>}<br>}<br>Node *pNextNode = pNode-&gt;next;<br>delete pNode;<br>pNode = pNextNode;<br>}<br>else<br>{<br>pNode = pNode-&gt;next;<br>}<br>}<br>}</p>
<p>31、编程实现：找出两个字符串中最大公共子字符串,如”abccade”,”dgcadde”的最大子串为”cad”<br>int GetCommon(char <em>s1, char *s2, char *</em>r1, char **r2)<br>{<br>int len1 = strlen(s1);<br>int len2 = strlen(s2);<br>int maxlen = 0;</p>
<p>for(int i = 0; i &lt; len1; i++)<br>{<br>for(int j = 0; j &lt; len2; j++)<br>{<br>if(s1[i] == s2[j])<br>{<br>int as = i, bs = j, count = 1;<br>while(as + 1 &lt; len1 &amp;&amp; bs + 1 &lt; len2 &amp;&amp; s1[++as] == s2[++bs])<br>count++;</p>
<p>if(count &gt; maxlen)<br>{<br>maxlen = count;<br>*r1 = s1 + i;<br>*r2 = s2 + j;<br>}<br>}<br>}<br>}</p>
<p>32、编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数<br>char* test3(long num) {<br>char* buffer = (char*)malloc(11);<br>buffer[0] = ‘0’;<br>buffer[1] = ‘x’;<br>buffer[10] = ‘\0’;</p>
<p>char* temp = buffer + 2;<br>for (int i=0; i &lt; 8; i++) {<br>temp[i] = (char)(num&lt;&lt;4*i&gt;&gt;28);<br>temp[i] = temp[i] &gt;= 0 ? temp[i] : temp[i] + 16;<br>temp[i] = temp[i] &lt; 10 ? temp[i] + 48 : temp[i] + 55;<br>}<br>return buffer;<br>}</p>
<p>33、输入N, 打印 N*N 矩阵<br>比如 N = 3，打印：</p>
<p>1  2  3<br>8  9  4<br>7  6  5</p>
<p>N = 4，打印：</p>
<p>1  2  3  4<br>12  13  14  5<br>11  16  15  6<br>10  9  8  7<br>解答：<br>1 #define N 15<br>int s[N][N];<br>void main()<br>{<br>int k = 0, i = 0, j = 0;<br>int a = 1;<br>for( ; k &lt; (N+1)/2; k++ )<br>{<br>while( j &lt; N-k ) s[i][j++] = a++; i++; j–;<br>while( i &lt; N-k ) s[i++][j] = a++; i–; j–;<br>while( j &gt; k-1 ) s[i][j–] = a++; i–; j++;<br>while( i &gt; k )  s[i–][j] = a++; i++; j++;<br>}<br>for( i = 0; i &lt; N; i++ )<br>{<br>for( j = 0; j &lt; N; j++ )<br>cout &lt;&lt; s[i][j] &lt;&lt; ‘\t’;<br>cout &lt;&lt; endl;<br>}<br>}<br>2 define MAX_N  100<br>int matrix[MAX_N][MAX_N];</p>
<p>/*<br> <em>（x,y）：第一个元素的坐标<br> \</em> start：第一个元素的值<br> * n：矩阵的大小<br> */<br>void SetMatrix(int x, int y, int start, int n) {<br>  int i, j;</p>
<p>  if (n &lt;= 0)   //递归结束条件<br>    return;<br>  if (n == 1) {  //矩阵大小为1时<br>    matrix[x][y] = start;<br>    return;<br>  }<br>  for (i = x; i &lt; x + n-1; i++)  //矩阵上部<br>    matrix[y][i] = start++;</p>
<p>  for (j = y; j &lt; y + n-1; j++)  //右部<br>    matrix[j][x+n-1] = start++;</p>
<p>  for (i = x+n-1; i &gt; x; i–)   //底部<br>    matrix[y+n-1][i] = start++;</p>
<p>  for (j = y+n-1; j &gt; y; j–)   //左部<br>    matrix[j][x] = start++;</p>
<p>  SetMatrix(x+1, y+1, start, n-2);  //递归<br>}</p>
<p>void main() {<br>  int i, j;<br>  int n;</p>
<p>  scanf(“%d”, &amp;n);<br>  SetMatrix(0, 0, 1, n);</p>
<p>  //打印螺旋矩阵<br>  for(i = 0; i &lt; n; i++) {<br>   for (j = 0; j &lt; n; j++)<br>printf(“%4d”, matrix[i][j]);<br>   printf(“\n”);<br>  }<br>}</p>
<p>34、斐波拉契数列递归实现的方法如下：<br> int  Funct( int n )<br>{<br>  if(n==0) return 1;<br>  if(n==1) return 1;<br>  retrurn  Funct(n-1) + Funct(n-2);<br>}<br>请问，如何不使用递归，来实现上述函数？<br>请教各位高手！<br>解答：int  Funct( int n )  //  n 为非负整数<br>{<br>  int a=0;<br>  int b=1;<br>  int c;<br>  if(n==0) c=1;<br>  else if(n==1) c=1;<br>  else for(int i=2;i&lt;=n;i++)  //应该n从2开始算起<br>  {<br>   c=a+b;<br>   a=b;<br>   b=c;<br>  }<br>  return c;<br>}<br>解答：<br>现在大多数系统都是将低字位放在前面，而结构体中位域的申明一般是先声明高位。<br>100  的二进制是 001 100 100<br>低位在前  高位在后<br>001—-s3<br>100—-s2<br>100—-s1<br>所以结果应该是 1<br>如果先申明的在低位则：<br>001—-s1<br>100—-s2<br>100—-s3<br>结果是 4<br>1、原题跟little-endian，big-endian没有关系<br>2、原题跟位域的存储空间分配有关，到底是从低字节分配还是从高字节分配，从Dev C++和VC7.1上看，都是从低字节开始分配，并且连续分配，中间不空，不像谭的书那样会留空位<br>3、原题跟编译器有关，编译器在未用堆栈空间的默认值分配上有所不同，Dev C++未用空间分配为<br>01110111b，VC7.1下为11001100b,所以在Dev C++下的结果为5，在VC7.1下为1。</p>
<p>注：PC一般采用little-endian，即高高低低，但在网络传输上，一般采用big-endian，即高低低高，华为是做网络的，所以可能考虑big-endian模式，这样输出结果可能为4</p>
<p>35、判断一个字符串是不是回文<br>int IsReverseStr(char <em>aStr)<br>{<br>int i,j;<br>int found=1;<br>if(aStr==NULL)<br>return -1;<br>j=strlen(aStr);<br>for(i=0;i&lt;j/2;i++)<br>if(</em>(aStr+i)!=*(aStr+j-i-1))<br>{<br>found=0;<br>break;<br>}<br>return found;<br>}</p>
<p>36、Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p>数组实现：<br>#include &lt;stdio.h&gt;<br>#include &lt;malloc.h&gt;<br>int Josephu(int n, int m)<br>{<br> int flag, i, j = 0;<br> int *arr = (int *)malloc(n * sizeof(int));<br> for (i = 0; i &lt; n; ++i)<br>  arr[i] = 1;<br> for (i = 1; i &lt; n; ++i)<br> {<br>  flag = 0;<br>  while (flag &lt; m)<br>  {<br>   if (j == n)<br>    j = 0;<br>   if (arr[j])<br>    ++flag;<br>   ++j;<br>  }<br>  arr[j - 1] = 0;<br>  printf(“第%4d个出局的人是：%4d号\n”, i, j);<br> }<br> free(arr);<br> return j;<br>}<br>int main()<br>{<br> int n, m;<br> scanf(“%d%d”, &amp;n, &amp;m);<br> printf(“最后胜利的是%d号！\n”, Josephu(n, m));<br> system(“pause”);<br> return 0;<br>}<br>链表实现：<br>#include &lt;stdio.h&gt;<br>#include &lt;malloc.h&gt;<br>typedef struct Node<br>{<br> int index;<br> struct Node *next;<br>}JosephuNode;<br>int Josephu(int n, int m)<br>{<br> int i, j;<br> JosephuNode *head, *tail;<br> head = tail = (JosephuNode *)malloc(sizeof(JosephuNode));<br> for (i = 1; i &lt; n; ++i)<br> {<br>  tail-&gt;index = i;<br>  tail-&gt;next = (JosephuNode *)malloc(sizeof(JosephuNode));<br>  tail = tail-&gt;next;<br> }<br> tail-&gt;index = i;<br> tail-&gt;next = head;</p>
<p> for (i = 1; tail != head; ++i)<br> {<br>  for (j = 1; j &lt; m; ++j)<br>  {<br>   tail = head;<br>   head = head-&gt;next;<br>  }<br>  tail-&gt;next = head-&gt;next;<br>  printf(“第%4d个出局的人是：%4d号\n”, i, head-&gt;index);<br>  free(head);<br>  head = tail-&gt;next;<br> }<br> i = head-&gt;index;<br> free(head);<br> return i;<br>}<br>int main()<br>{<br> int n, m;<br> scanf(“%d%d”, &amp;n, &amp;m);<br> printf(“最后胜利的是%d号！\n”, Josephu(n, m));<br> system(“pause”);<br> return 0;<br>}</p>
<p>37、已知strcpy函数的原型是：<br>    char * strcpy(char * strDest,const char * strSrc);<br>  1.不调用库函数，实现strcpy函数。<br>  2.解释为什么要返回char <em>。<br>  解说：<br>  1.strcpy的实现代码<br>    char * strcpy(char * strDest,const char * strSrc)<br>    {<br>        if ((strDest==NULL)||(strSrc==NULL)) file://[/1]<br>            throw “Invalid argument(s)”; //[2]<br>        char * strDestCopy=strDest;  file://[/3]<br>        while ((</em>strDest++=<em>strSrc++)!=’\0’); file://[/4]<br>        return strDestCopy;<br>    }<br>  错误的做法：<br>  [1]<br>  (A)不检查指针的有效性，说明答题者不注重代码的健壮性。<br>  (B)检查指针的有效性时使用((!strDest)||(!strSrc))或(!(strDest&amp;&amp;strSrc))，说明答题者对C语言中类型的隐式转换没有深刻认识。在本例中char *转换为bool即是类型隐式转换，这种功能虽然灵活，但更多的是导致出错概率增大和维护成本升高。所以C++专门增加了bool、true、false三个关键字以提供更安全的条件表达式。<br>  (C)检查指针的有效性时使用((strDest==0)||(strSrc==0))，说明答题者不知道使用常量的好处。直接使用字面常量（如本例中的0）会减少程序的可维护性。0虽然简单，但程序中可能出现很多处对指针的检查，万一出现笔误，编译器不能发现，生成的程序内含逻辑错误，很难排除。而使用NULL代替0，如果出现拼写错误，编译器就会检查出来。<br>  [2]<br>  (A)return new string(“Invalid argument(s)”);，说明答题者根本不知道返回值的用途，并且他对内存泄漏也没有警惕心。从函数中返回函数体内分配的内存是十分危险的做法，他把释放内存的义务抛给不知情的调用者，绝大多数情况下，调用者不会释放内存，这导致内存泄漏。<br>  (B)return 0;，说明答题者没有掌握异常机制。调用者有可能忘记检查返回值，调用者还可能无法检查返回值（见后面的链式表达式）。妄想让返回值肩负返回正确值和异常值的双重功能，其结果往往是两种功能都失效。应该以抛出异常来代替返回值，这样可以减轻调用者的负担、使错误不会被忽略、增强程序的可维护性。<br>  [3]<br>  (A)忘记保存原始的strDest值，说明答题者逻辑思维不严密。<br>  [4]<br>  (A)循环写成while (</em>strDest++=<em>strSrc++);，同<a href="B">1</a>。<br>  (B)循环写成while (</em>strSrc!=’\0’) <em>strDest++=</em>strSrc++;，说明答题者对边界条件的检查不力。循环体结束后，strDest字符串的末尾没有正确地加上’\0’。</p>
      <!-- reward -->
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
    </div>
    <!-- copyright -->
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
        </li>
      </ul>
    </div>
    <footer class="article-footer">
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>
<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://www.kangxh.xyz/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%984/" alt="微信分享二维码">
    </div>
</div>
<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li></ul>
    </footer>
  </div>
  <nav class="article-nav">
      <a href="/2021/03/09/C%E8%AF%AD%E8%A8%80%E4%B8%ADqsort%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
            C语言中qsort用法
        </div>
      </a>
      <a href="/2021/03/09/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%981/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">C语言面试题1</div>
      </a>
  </nav>
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "lC7lsHHM0HSqJA3yOqH70saX-gzGzoHsz",
    app_key: "mCkqEEjUbhRIHjXJ7mtxTgfA",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }
  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }
  #vcomments-box #vcomments {
    background-color: #fff;
  }
  .v .vlist .vcard .vh {
    padding-right: 20px;
  }
  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>
</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Mystery
      </li>
    </ul>
    <ul>
      <li>
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
      </li>
    </ul>
    <ul>
      <li>
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
      </li>
    </ul>
    <ul>
    </ul>
    <ul>
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Mysterious Blog"></a>
  </div>
  <ul class="nav nav-main">
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    <li class="nav-item">
      <a class="nav-item-link" href="/player">影音</a>
    </li>
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>
<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    <div class="reward-item">
      <img class="reward-img" src="https://gitee.com/LYmystery/PicGo/raw/master/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    <div class="reward-item">
      <img class="reward-img" src="https://gitee.com/LYmystery/PicGo/raw/master/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
  </div>
</div>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Tocbot -->
<script src="/js/tocbot.min.js"></script>
<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>
<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))
        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>
<!-- MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>
<!-- Katex -->
<!-- busuanzi  -->
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<!-- ClickLove -->
<!-- ClickBoom1 -->
<!-- ClickBoom2 -->
<!-- CodeCopy -->
<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
<!-- CanvasBackground -->
    <div id="music">
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=0&height=32"></iframe>
</div>
<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
  </div>
</body>
</html>